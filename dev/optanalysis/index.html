<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Optimization Analysis · JET.jl</title><meta name="title" content="Optimization Analysis · JET.jl"/><meta property="og:title" content="Optimization Analysis · JET.jl"/><meta property="twitter:title" content="Optimization Analysis · JET.jl"/><meta name="description" content="Documentation for JET.jl."/><meta property="og:description" content="Documentation for JET.jl."/><meta property="twitter:description" content="Documentation for JET.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">JET.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">README</a></li><li><a class="tocitem" href="../tutorial/">Tutorial</a></li><li><span class="tocitem">Analyses</span><ul><li><a class="tocitem" href="../jetanalysis/">Error Analysis</a></li><li class="is-active"><a class="tocitem" href>Optimization Analysis</a><ul class="internal"><li><a class="tocitem" href="#optanalysis-quick-start"><span>Quick Start</span></a></li><li><a class="tocitem" href="#cthulhu-integration"><span>Integration with Cthulhu</span></a></li><li><a class="tocitem" href="#optanalysis-entry"><span>Entry Points</span></a></li><li><a class="tocitem" href="#optanalysis-config"><span>Configurations</span></a></li></ul></li></ul></li><li><a class="tocitem" href="../config/">Configurations</a></li><li><a class="tocitem" href="../internals/">Internals</a></li><li><span class="tocitem"><code>AbstractAnalyzer</code> Framework</span><ul><li><a class="tocitem" href="../generated-plugin-api/">API</a></li><li><input class="collapse-toggle" id="menuitem-6-2" type="checkbox"/><label class="tocitem" for="menuitem-6-2"><span class="docs-label">Examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../generated-plugin-examples/dispatch_analysis/">Dispatch Analysis</a></li><li><a class="tocitem" href="../generated-plugin-examples/find_unstable_api/">&quot;Unstable API&quot; Analysis</a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Analyses</a></li><li class="is-active"><a href>Optimization Analysis</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Optimization Analysis</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/aviatesk/JET.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/aviatesk/JET.jl/blob/master/docs/src/optanalysis.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="optanalysis"><a class="docs-heading-anchor" href="#optanalysis">Optimization Analysis</a><a id="optanalysis-1"></a><a class="docs-heading-anchor-permalink" href="#optanalysis" title="Permalink"></a></h1><p>Successful type inference and optimization are key to high-performing Julia programs. But as mentioned in <a href="https://docs.julialang.org/en/v1/manual/performance-tips/">the performance tips</a>, there are some chances where Julia can not infer the types of your program very well and can not optimize it well accordingly.</p><p>While there are many possibilities of &quot;type-instabilities&quot;, like usage of non-constant global variable most notably, probably the most tricky one would be <a href="https://docs.julialang.org/en/v1/manual/performance-tips/#man-performance-captured">&quot;captured variable&quot;</a> – Julia can not really well infer the type of variable that is observed and modified by both inner function and enclosing one. And such type instabilities can lead to various optimization failures. One of the most common barriers to performance is known as &quot;runtime dispatch&quot;, which happens when a matching method can&#39;t be resolved by the compiler due to the lack of type information and it is looked up at runtime instead. Since runtime dispatch is caused by poor type information, it often indicates the compiler could not do other optimizations including inlining and scalar replacements of aggregates.</p><p>In order to avoid such problems, we usually inspect the output of <a href="https://docs.julialang.org/en/v1/base/base/#Base.code_typed"><code>code_typed</code></a> or its family, and check if there is anywhere type is not well inferred and optimization was not successful. But the problem is that one needs to have enough knowledge about inference and optimization in order to interpret the output. Another problem is that they can only present the &quot;final&quot; output of the inference and optimization, and we can not inspect the entire call graph and may miss finding where a problem actually happened and how the type-instability has been propagated. There is a nice package called <a href="https://github.com/JuliaDebug/Cthulhu.jl">Cthulhu.jl</a>, which allows us to look at the outputs of <code>code_typed</code> by <em>descending</em> into a call tree, recursively and interactively. The workflow with Cthulhu is much more efficient and powerful, but still, it requires much familiarity with the Julia compiler and it tends to be tedious.</p><p>So, why not automate it? JET implements such an analyzer that investigates the optimized representation of your program and <em>automatically</em> detects anywhere the compiler failed in optimization. Especially, it can find where Julia creates captured variables, where runtime dispatch will happen, and where Julia gives up the optimization work due to unresolvable recursive function call.</p><p><a href="https://timholy.github.io/SnoopCompile.jl/stable/tutorials/snoop_inference_analysis/">SnoopCompile also detects inference failures</a>, but JET and SnoopCompile use different mechanisms: JET performs <em>static</em> analysis of a particular call, while SnoopCompile performs <em>dynamic</em> analysis of new inference. As a consequence, JET&#39;s detection of inference failures is reproducible (you can run the same analysis repeatedly and get the same result) but terminates at any non-inferable node of the call graph: you will miss runtime dispatch in any non-inferable callees. Conversely, SnoopCompile&#39;s detection of inference failures can explore the entire callgraph, but only for those portions that have not been previously inferred, and the analysis cannot be repeated in the same session.</p><h2 id="optanalysis-quick-start"><a class="docs-heading-anchor" href="#optanalysis-quick-start">Quick Start</a><a id="optanalysis-quick-start-1"></a><a class="docs-heading-anchor-permalink" href="#optanalysis-quick-start" title="Permalink"></a></h2><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using JET</code></pre><p>JET exports <a href="#JET.@report_opt"><code>@report_opt</code></a>, which analyzes the entire call graph of a given generic function call, and then reports detected performance pitfalls.</p><p>As a first example, let&#39;s see how we can find and fix runtime dispatches using JET:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; n = rand(Int); # non-constant global variable</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; make_vals(n) = n ≥ 0 ? (zero(n):n) : (n:zero(n));</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; function sumup(f)
           # this function uses the non-constant global variable `n` here
           # and it makes every succeeding operations type-unstable
           vals = make_vals(n)
           s = zero(eltype(vals))
           for v in vals
               s += f(v)
           end
           return s
       end;</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @report_opt sumup(sin) # runtime dispatches will be reported</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr7">═════ 7 possible errors found ═════</span>
<span class="sgr91">┌ </span><span class="sgr1">sumup(</span><span class="sgr90">f</span>::typeof(sin)<span class="sgr1">)</span> <span class="sgr91">@ Main ./REPL[3]:4</span>
<span class="sgr91">│ runtime dispatch detected: </span><span class="sgr1">Main.make_vals(%1<span class="sgr96">::Any</span>)<span class="sgr96">::Any</span></span>
<span class="sgr91">└────────────────────</span>
<span class="sgr91">┌ </span><span class="sgr1">sumup(</span><span class="sgr90">f</span>::typeof(sin)<span class="sgr1">)</span> <span class="sgr91">@ Main ./REPL[3]:5</span>
<span class="sgr91">│ runtime dispatch detected: </span><span class="sgr1">Main.eltype(%2<span class="sgr96">::Any</span>)<span class="sgr96">::Any</span></span>
<span class="sgr91">└────────────────────</span>
<span class="sgr91">┌ </span><span class="sgr1">sumup(</span><span class="sgr90">f</span>::typeof(sin)<span class="sgr1">)</span> <span class="sgr91">@ Main ./REPL[3]:5</span>
<span class="sgr91">│ runtime dispatch detected: </span><span class="sgr1">Main.zero(%3<span class="sgr96">::Any</span>)<span class="sgr96">::Any</span></span>
<span class="sgr91">└────────────────────</span>
<span class="sgr91">┌ </span><span class="sgr1">sumup(</span><span class="sgr90">f</span>::typeof(sin)<span class="sgr1">)</span> <span class="sgr91">@ Main ./REPL[3]:6</span>
<span class="sgr91">│ runtime dispatch detected: </span><span class="sgr1">iterate(%2<span class="sgr96">::Any</span>)<span class="sgr96">::Any</span></span>
<span class="sgr91">└────────────────────</span>
<span class="sgr91">┌ </span><span class="sgr1">sumup(</span><span class="sgr90">f</span>::typeof(sin)<span class="sgr1">)</span> <span class="sgr91">@ Main ./REPL[3]:7</span>
<span class="sgr91">│ runtime dispatch detected: </span><span class="sgr1">f<span class="sgr96">::typeof(sin)</span>(%11<span class="sgr96">::Any</span>)<span class="sgr96">::Any</span></span>
<span class="sgr91">└────────────────────</span>
<span class="sgr91">┌ </span><span class="sgr1">sumup(</span><span class="sgr90">f</span>::typeof(sin)<span class="sgr1">)</span> <span class="sgr91">@ Main ./REPL[3]:7</span>
<span class="sgr91">│ runtime dispatch detected: </span><span class="sgr1">(%10<span class="sgr96">::Any</span> Main.:+ %13<span class="sgr96">::Any</span>)<span class="sgr96">::Any</span></span>
<span class="sgr91">└────────────────────</span>
<span class="sgr91">┌ </span><span class="sgr1">sumup(</span><span class="sgr90">f</span>::typeof(sin)<span class="sgr1">)</span> <span class="sgr91">@ Main ./REPL[3]:8</span>
<span class="sgr91">│ runtime dispatch detected: </span><span class="sgr1">iterate(%2<span class="sgr96">::Any</span>, %12<span class="sgr96">::Any</span>)<span class="sgr96">::Any</span></span>
<span class="sgr91">└────────────────────</span></code></pre><p>JET&#39;s analysis result will be dynamically updated when we (re-)define functions<sup class="footnote-reference"><a id="citeref-1" href="#footnote-1" class="footnote-ref">[1]</a><span class="footnote-preview" id="fn-1"></span></sup>, and we can &quot;hot-fix&quot; the runtime dispatches within the same running Julia session like this:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; # we can pass parameters as a function argument instead, and then everything will be type-stable
       function sumup(f, n)
           vals = make_vals(n)
           s = zero(eltype(vals))
           for v in vals
               # NOTE here we may get union type like `s::Union{Int,Float64}`,
               # but Julia can optimize away such small unions (thus no runtime dispatch)
               s += f(v)
           end
           return s
       end;</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @report_opt sumup(sin, rand(Int)) # now runtime dispatch free !</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr92">No errors detected</span></code></pre><p><code>@report_opt</code> can also report the existence of captured variables, which are really better to be eliminated within performance-sensitive context:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; # the examples below are all adapted from https://docs.julialang.org/en/v1/manual/performance-tips/#man-performance-captured
       function abmult(r::Int)
           if r &lt; 0
               r = -r
           end
           # the closure assigned to `f` make the variable `r` captured
           f = x -&gt; x * r
           return f
       end;</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @report_opt abmult(42)</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr7">═════ 3 possible errors found ═════</span>
<span class="sgr91">┌ </span><span class="sgr1">abmult(</span><span class="sgr90">r</span>::Int64<span class="sgr1">)</span> <span class="sgr91">@ Main ./REPL[1]:2</span>
<span class="sgr91">│ captured variable `r` detected</span>
<span class="sgr91">└────────────────────</span>
<span class="sgr91">┌ </span><span class="sgr1">abmult(</span><span class="sgr90">r</span>::Int64<span class="sgr1">)</span> <span class="sgr91">@ Main ./REPL[1]:2</span>
<span class="sgr91">│ runtime dispatch detected: </span><span class="sgr1">(%3<span class="sgr96">::Any</span> Main.:&lt; 0)<span class="sgr96">::Any</span></span>
<span class="sgr91">└────────────────────</span>
<span class="sgr91">┌ </span><span class="sgr1">abmult(</span><span class="sgr90">r</span>::Int64<span class="sgr1">)</span> <span class="sgr91">@ Main ./REPL[1]:3</span>
<span class="sgr91">│ runtime dispatch detected: </span><span class="sgr1">Main.:-(%8<span class="sgr96">::Any</span>)<span class="sgr96">::Any</span></span>
<span class="sgr91">└────────────────────</span></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; function abmult(r0::Int)
           # we can improve the type stability of the variable `r` like this,
           # but it is still captured
           r::Int = r0
           if r &lt; 0
               r = -r
           end
           f = x -&gt; x * r
           return f
       end;</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @report_opt abmult(42)</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr7">═════ 1 possible error found ═════</span>
<span class="sgr91">┌ </span><span class="sgr1">abmult(</span><span class="sgr90">r0</span>::Int64<span class="sgr1">)</span> <span class="sgr91">@ Main ./REPL[3]:4</span>
<span class="sgr91">│ captured variable `r` detected</span>
<span class="sgr91">└────────────────────</span></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; function abmult(r::Int)
           if r &lt; 0
               r = -r
           end
           # we can try to eliminate the capturing
           # and now this function would be the most performing
           f = let r = r
               x -&gt; x * r
           end
           return f
       end;</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @report_opt abmult(42)</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr92">No errors detected</span></code></pre><p>With the <a href="../config/#result-config"><code>target_modules</code></a> configuration, we can easily limit the analysis scope to a specific module context:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; # problem: when ∑1/n exceeds `x` ?
       function compute(x)
           r = 1
           s = 0.0
           n = 1
           @time while r &lt; x
               s += 1/n
               if s ≥ r
                   # `println` call is full of runtime dispatches for good reasons
                   # and we&#39;re not interested in type-instabilities within this call
                   # since we know it&#39;s only called a few times
                   println(&quot;round $r/$x has been finished&quot;)
                   r += 1
               end
               n += 1
           end
           return n, s
       end</code><code class="nohighlight hljs ansi" style="display:block;">compute (generic function with 1 method)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @report_opt compute(30) # bunch of reports will be reported from the `println` call</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr7">═════ 16 possible errors found ═════</span>
<span class="sgr35">┌ </span><span class="sgr1">compute(</span><span class="sgr90">x</span>::Int64<span class="sgr1">)</span> <span class="sgr35">@ Main ./REPL[1]:5</span>
<span class="sgr35">│</span><span class="sgr91">┌ </span><span class="sgr1">println(</span><span class="sgr90">x</span>::String<span class="sgr1">)</span> <span class="sgr91">@ Base ./coreio.jl:5</span>
<span class="sgr35">│</span><span class="sgr91">│ runtime dispatch detected: </span><span class="sgr1">print(%1<span class="sgr96">::IO</span>, x<span class="sgr96">::String</span>, &quot;\n&quot;)<span class="sgr96">::Nothing</span></span>
<span class="sgr35">│</span><span class="sgr91">└────────────────────</span>
<span class="sgr35">│</span><span class="sgr34">┌ </span><span class="sgr1">kwcall(</span>::@NamedTuple<span class="sgr90">{…}</span>, ::typeof(Base.time_print), <span class="sgr90">io</span>::IO, <span class="sgr90">elapsedtime</span>::Float64, <span class="sgr90">bytes</span>::Int64, <span class="sgr90">gctime</span>::Int64, <span class="sgr90">allocs</span>::Int64, <span class="sgr90">lock_conflicts</span>::Int64, <span class="sgr90">compile_time</span>::Float64, <span class="sgr90">recompile_time</span>::Float64, <span class="sgr90">newline</span>::Bool<span class="sgr1">)</span> <span class="sgr34">@ Base ./timing.jl:211</span>
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">┌ </span> <span class="sgr33">@ Base ./timing.jl:214</span>
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">┌ </span><span class="sgr1">sprint(</span>::Base.var&quot;#912#913&quot;<span class="sgr90">{Nothing, Float64, Int64, Int64, Int64, Float64, Float64, Bool, String}</span><span class="sgr1">)</span> <span class="sgr32">@ Base ./strings/io.jl:110</span>
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">┌ </span><span class="sgr1">sprint(</span>::Base.var&quot;#912#913&quot;<span class="sgr90">{…}</span>; <span class="sgr90">context</span>::Nothing, <span class="sgr90">sizehint</span>::Int64<span class="sgr1">)</span> <span class="sgr35">@ Base ./strings/io.jl:117</span>
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr91">┌ </span><span class="sgr1">(::Base.var&quot;#912#913&quot;{Nothing, Float64, Int64, Int64, Int64, Float64, Float64, Bool, String})(</span><span class="sgr90">io</span>::IOBuffer<span class="sgr1">)</span> <span class="sgr91">@ Base ./timing.jl:221</span>
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr91">│ runtime dispatch detected: </span><span class="sgr1">(%30<span class="sgr96">::Any</span> != 0)<span class="sgr96">::Any</span></span>
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr91">└────────────────────</span>
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr91">┌ </span><span class="sgr1">(::Base.var&quot;#912#913&quot;{Nothing, Float64, Int64, Int64, Int64, Float64, Float64, Bool, String})(</span><span class="sgr90">io</span>::IOBuffer<span class="sgr1">)</span> <span class="sgr91">@ Base ./timing.jl:223</span>
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr91">│ runtime dispatch detected: </span><span class="sgr1">(%68<span class="sgr96">::Any</span> != 0)<span class="sgr96">::Any</span></span>
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr91">└────────────────────</span>
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr91">┌ </span><span class="sgr1">(::Base.var&quot;#912#913&quot;{Nothing, Float64, Int64, Int64, Int64, Float64, Float64, Bool, String})(</span><span class="sgr90">io</span>::IOBuffer<span class="sgr1">)</span> <span class="sgr91">@ Base ./timing.jl:224</span>
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr91">│ runtime dispatch detected: </span><span class="sgr1">Base.prettyprint_getunits(%78<span class="sgr96">::Any</span>, %81<span class="sgr96">::Int64</span>, 1000)<span class="sgr96">::Tuple{Any, Any}</span></span>
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr91">└────────────────────</span>
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr91">┌ </span><span class="sgr1">(::Base.var&quot;#912#913&quot;{Nothing, Float64, Int64, Int64, Int64, Float64, Float64, Bool, String})(</span><span class="sgr90">io</span>::IOBuffer<span class="sgr1">)</span> <span class="sgr91">@ Base ./timing.jl:225</span>
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr91">│ runtime dispatch detected: </span><span class="sgr1">(%86<span class="sgr96">::Any</span> == 1)<span class="sgr96">::Any</span></span>
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr91">└────────────────────</span>
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr91">┌ </span><span class="sgr1">(::Base.var&quot;#912#913&quot;{Nothing, Float64, Int64, Int64, Int64, Float64, Float64, Bool, String})(</span><span class="sgr90">io</span>::IOBuffer<span class="sgr1">)</span> <span class="sgr91">@ Base ./timing.jl:226</span>
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr91">│ runtime dispatch detected: </span><span class="sgr1">Int(%93<span class="sgr96">::Any</span>)<span class="sgr96">::Any</span></span>
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr91">└────────────────────</span>
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr91">┌ </span><span class="sgr1">(::Base.var&quot;#912#913&quot;{Nothing, Float64, Int64, Int64, Int64, Float64, Float64, Bool, String})(</span><span class="sgr90">io</span>::IOBuffer<span class="sgr1">)</span> <span class="sgr91">@ Base ./timing.jl:226</span>
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr91">│ runtime dispatch detected: </span><span class="sgr1">(Base._cnt_units)[%86<span class="sgr96">::Any</span>]<span class="sgr96">::Any</span></span>
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr91">└────────────────────</span>
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr91">┌ </span><span class="sgr1">(::Base.var&quot;#912#913&quot;{Nothing, Float64, Int64, Int64, Int64, Float64, Float64, Bool, String})(</span><span class="sgr90">io</span>::IOBuffer<span class="sgr1">)</span> <span class="sgr91">@ Base ./timing.jl:226</span>
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr91">│ runtime dispatch detected: </span><span class="sgr1">(%100<span class="sgr96">::Any</span> == 1)<span class="sgr96">::Any</span></span>
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr91">└────────────────────</span>
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr91">┌ </span><span class="sgr1">(::Base.var&quot;#912#913&quot;{Nothing, Float64, Int64, Int64, Int64, Float64, Float64, Bool, String})(</span><span class="sgr90">io</span>::IOBuffer<span class="sgr1">)</span> <span class="sgr91">@ Base ./timing.jl:226</span>
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr91">│ runtime dispatch detected: </span><span class="sgr1">print(io<span class="sgr96">::IOBuffer</span>, %94<span class="sgr96">::Any</span>, %95<span class="sgr96">::Any</span>, %105<span class="sgr96">::String</span>)<span class="sgr96">::Any</span></span>
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr91">└────────────────────</span>
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr91">┌ </span><span class="sgr1">(::Base.var&quot;#912#913&quot;{Nothing, Float64, Int64, Int64, Int64, Float64, Float64, Bool, String})(</span><span class="sgr90">io</span>::IOBuffer<span class="sgr1">)</span> <span class="sgr91">@ Base ./timing.jl:228</span>
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr91">│ runtime dispatch detected: </span><span class="sgr1">Float64(%116<span class="sgr96">::Any</span>)<span class="sgr96">::Any</span></span>
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr91">└────────────────────</span>
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr91">┌ </span><span class="sgr1">(::Base.var&quot;#912#913&quot;{Nothing, Float64, Int64, Int64, Int64, Float64, Float64, Bool, String})(</span><span class="sgr90">io</span>::IOBuffer<span class="sgr1">)</span> <span class="sgr91">@ Base ./timing.jl:228</span>
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr91">│ runtime dispatch detected: </span><span class="sgr1">writefixed(%117<span class="sgr96">::Any</span>, 2)<span class="sgr96">::String</span></span>
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr91">└────────────────────</span>
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr91">┌ </span><span class="sgr1">(::Base.var&quot;#912#913&quot;{Nothing, Float64, Int64, Int64, Int64, Float64, Float64, Bool, String})(</span><span class="sgr90">io</span>::IOBuffer<span class="sgr1">)</span> <span class="sgr91">@ Base ./timing.jl:228</span>
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr91">│ runtime dispatch detected: </span><span class="sgr1">(Base._cnt_units)[%86<span class="sgr96">::Any</span>]<span class="sgr96">::Any</span></span>
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr91">└────────────────────</span>
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr91">┌ </span><span class="sgr1">(::Base.var&quot;#912#913&quot;{Nothing, Float64, Int64, Int64, Int64, Float64, Float64, Bool, String})(</span><span class="sgr90">io</span>::IOBuffer<span class="sgr1">)</span> <span class="sgr91">@ Base ./timing.jl:228</span>
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr91">│ runtime dispatch detected: </span><span class="sgr1">print(io<span class="sgr96">::IOBuffer</span>, %118<span class="sgr96">::String</span>, %119<span class="sgr96">::Any</span>, &quot; allocations: &quot;)<span class="sgr96">::Any</span></span>
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr91">└────────────────────</span>
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr91">┌ </span><span class="sgr1">(::Base.var&quot;#912#913&quot;{Nothing, Float64, Int64, Int64, Int64, Float64, Float64, Bool, String})(</span><span class="sgr90">io</span>::IOBuffer<span class="sgr1">)</span> <span class="sgr91">@ Base ./timing.jl:233</span>
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr91">│ runtime dispatch detected: </span><span class="sgr1">(%147<span class="sgr96">::Any</span> != 0)<span class="sgr96">::Any</span></span>
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr91">└────────────────────</span>
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr91">┌ </span><span class="sgr1">(::Base.var&quot;#912#913&quot;{Nothing, Float64, Int64, Int64, Int64, Float64, Float64, Bool, String})(</span><span class="sgr90">io</span>::IOBuffer<span class="sgr1">)</span> <span class="sgr91">@ Base ./timing.jl:239</span>
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr91">│ runtime dispatch detected: </span><span class="sgr1">(%178<span class="sgr96">::Any</span> != 0)<span class="sgr96">::Any</span></span>
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr91">└────────────────────</span>
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr91">┌ </span><span class="sgr1">(::Base.var&quot;#912#913&quot;{Nothing, Float64, Int64, Int64, Int64, Float64, Float64, Bool, String})(</span><span class="sgr90">io</span>::IOBuffer<span class="sgr1">)</span> <span class="sgr91">@ Base ./timing.jl:246</span>
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr91">│ runtime dispatch detected: </span><span class="sgr1">(%216<span class="sgr96">::Any</span> != 0)<span class="sgr96">::Any</span></span>
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr91">└────────────────────</span></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @report_opt target_modules=(@__MODULE__,) compute(30) # focus on what we wrote, and no error should be reported</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr92">No errors detected</span></code></pre><p>There is also <a href="#optanalysis-config"><code>function_filter</code></a>, which can ignore specific function calls.</p><p><a href="#JET.@test_opt"><code>@test_opt</code></a> can be used to assert that a given function call is free from performance pitfalls. It is fully integrated with <a href="https://docs.julialang.org/en/v1/stdlib/Test/"><code>Test</code> standard library</a>&#39;s unit-testing infrastructure, and we can use it like other <code>Test</code> macros e.g. <code>@test</code>:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; @test_opt sumup(cos)</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr91"><span class="sgr1">JET-test failed</span></span> at <span class="sgr1">REPL[1]:1</span>
  Expression: <span class="sgr90">#= REPL[1]:1 =#</span> JET.@test_opt sumup(cos)
  <span class="sgr7">═════ 7 possible errors found ═════</span>
  <span class="sgr91">┌ </span><span class="sgr1">sumup(</span><span class="sgr90">f</span>::typeof(cos)<span class="sgr1">)</span> <span class="sgr91">@ Main ./REPL[3]:4</span>
  <span class="sgr91">│ runtime dispatch detected: </span><span class="sgr1">Main.make_vals(%1<span class="sgr96">::Any</span>)<span class="sgr96">::Any</span></span>
  <span class="sgr91">└────────────────────</span>
  <span class="sgr91">┌ </span><span class="sgr1">sumup(</span><span class="sgr90">f</span>::typeof(cos)<span class="sgr1">)</span> <span class="sgr91">@ Main ./REPL[3]:5</span>
  <span class="sgr91">│ runtime dispatch detected: </span><span class="sgr1">Main.eltype(%2<span class="sgr96">::Any</span>)<span class="sgr96">::Any</span></span>
  <span class="sgr91">└────────────────────</span>
  <span class="sgr91">┌ </span><span class="sgr1">sumup(</span><span class="sgr90">f</span>::typeof(cos)<span class="sgr1">)</span> <span class="sgr91">@ Main ./REPL[3]:5</span>
  <span class="sgr91">│ runtime dispatch detected: </span><span class="sgr1">Main.zero(%3<span class="sgr96">::Any</span>)<span class="sgr96">::Any</span></span>
  <span class="sgr91">└────────────────────</span>
  <span class="sgr91">┌ </span><span class="sgr1">sumup(</span><span class="sgr90">f</span>::typeof(cos)<span class="sgr1">)</span> <span class="sgr91">@ Main ./REPL[3]:6</span>
  <span class="sgr91">│ runtime dispatch detected: </span><span class="sgr1">iterate(%2<span class="sgr96">::Any</span>)<span class="sgr96">::Any</span></span>
  <span class="sgr91">└────────────────────</span>
  <span class="sgr91">┌ </span><span class="sgr1">sumup(</span><span class="sgr90">f</span>::typeof(cos)<span class="sgr1">)</span> <span class="sgr91">@ Main ./REPL[3]:7</span>
  <span class="sgr91">│ runtime dispatch detected: </span><span class="sgr1">f<span class="sgr96">::typeof(cos)</span>(%11<span class="sgr96">::Any</span>)<span class="sgr96">::Any</span></span>
  <span class="sgr91">└────────────────────</span>
  <span class="sgr91">┌ </span><span class="sgr1">sumup(</span><span class="sgr90">f</span>::typeof(cos)<span class="sgr1">)</span> <span class="sgr91">@ Main ./REPL[3]:7</span>
  <span class="sgr91">│ runtime dispatch detected: </span><span class="sgr1">(%10<span class="sgr96">::Any</span> Main.:+ %13<span class="sgr96">::Any</span>)<span class="sgr96">::Any</span></span>
  <span class="sgr91">└────────────────────</span>
  <span class="sgr91">┌ </span><span class="sgr1">sumup(</span><span class="sgr90">f</span>::typeof(cos)<span class="sgr1">)</span> <span class="sgr91">@ Main ./REPL[3]:8</span>
  <span class="sgr91">│ runtime dispatch detected: </span><span class="sgr1">iterate(%2<span class="sgr96">::Any</span>, %12<span class="sgr96">::Any</span>)<span class="sgr96">::Any</span></span>
  <span class="sgr91">└────────────────────</span>
  
ERROR: <span class="sgr91">There was an error during testing</span></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @test_opt target_modules=(@__MODULE__,) compute(30)</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr32"><span class="sgr1">Test Passed</span></span></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; using Test</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @testset &quot;check type-stabilities&quot; begin
           @test_opt sumup(cos) # should fail
       
           n = rand(Int)
           @test_opt sumup(cos, n) # should pass
       
           @test_opt target_modules=(@__MODULE__,) compute(30) # should pass
       
           @test_opt broken=true compute(30) # should pass with the &quot;broken&quot; annotation
       end</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr37">check type-stabilities: </span><span class="sgr91"><span class="sgr1">JET-test failed</span></span> at <span class="sgr1">REPL[4]:2</span>
  Expression: <span class="sgr90">#= REPL[4]:2 =#</span> JET.@test_opt sumup(cos)
  <span class="sgr7">═════ 7 possible errors found ═════</span>
  <span class="sgr91">┌ </span><span class="sgr1">sumup(</span><span class="sgr90">f</span>::typeof(cos)<span class="sgr1">)</span> <span class="sgr91">@ Main ./REPL[3]:4</span>
  <span class="sgr91">│ runtime dispatch detected: </span><span class="sgr1">Main.make_vals(%1<span class="sgr96">::Any</span>)<span class="sgr96">::Any</span></span>
  <span class="sgr91">└────────────────────</span>
  <span class="sgr91">┌ </span><span class="sgr1">sumup(</span><span class="sgr90">f</span>::typeof(cos)<span class="sgr1">)</span> <span class="sgr91">@ Main ./REPL[3]:5</span>
  <span class="sgr91">│ runtime dispatch detected: </span><span class="sgr1">Main.eltype(%2<span class="sgr96">::Any</span>)<span class="sgr96">::Any</span></span>
  <span class="sgr91">└────────────────────</span>
  <span class="sgr91">┌ </span><span class="sgr1">sumup(</span><span class="sgr90">f</span>::typeof(cos)<span class="sgr1">)</span> <span class="sgr91">@ Main ./REPL[3]:5</span>
  <span class="sgr91">│ runtime dispatch detected: </span><span class="sgr1">Main.zero(%3<span class="sgr96">::Any</span>)<span class="sgr96">::Any</span></span>
  <span class="sgr91">└────────────────────</span>
  <span class="sgr91">┌ </span><span class="sgr1">sumup(</span><span class="sgr90">f</span>::typeof(cos)<span class="sgr1">)</span> <span class="sgr91">@ Main ./REPL[3]:6</span>
  <span class="sgr91">│ runtime dispatch detected: </span><span class="sgr1">iterate(%2<span class="sgr96">::Any</span>)<span class="sgr96">::Any</span></span>
  <span class="sgr91">└────────────────────</span>
  <span class="sgr91">┌ </span><span class="sgr1">sumup(</span><span class="sgr90">f</span>::typeof(cos)<span class="sgr1">)</span> <span class="sgr91">@ Main ./REPL[3]:7</span>
  <span class="sgr91">│ runtime dispatch detected: </span><span class="sgr1">f<span class="sgr96">::typeof(cos)</span>(%11<span class="sgr96">::Any</span>)<span class="sgr96">::Any</span></span>
  <span class="sgr91">└────────────────────</span>
  <span class="sgr91">┌ </span><span class="sgr1">sumup(</span><span class="sgr90">f</span>::typeof(cos)<span class="sgr1">)</span> <span class="sgr91">@ Main ./REPL[3]:7</span>
  <span class="sgr91">│ runtime dispatch detected: </span><span class="sgr1">(%10<span class="sgr96">::Any</span> Main.:+ %13<span class="sgr96">::Any</span>)<span class="sgr96">::Any</span></span>
  <span class="sgr91">└────────────────────</span>
  <span class="sgr91">┌ </span><span class="sgr1">sumup(</span><span class="sgr90">f</span>::typeof(cos)<span class="sgr1">)</span> <span class="sgr91">@ Main ./REPL[3]:8</span>
  <span class="sgr91">│ runtime dispatch detected: </span><span class="sgr1">iterate(%2<span class="sgr96">::Any</span>, %12<span class="sgr96">::Any</span>)<span class="sgr96">::Any</span></span>
  <span class="sgr91">└────────────────────</span>
  
<span class="sgr1">Test Summary:          | <span class="sgr32">Pass  </span><span class="sgr91">Fail  </span><span class="sgr33">Broken  </span><span class="sgr36">Total  </span>Time</span>
check type-stabilities | <span class="sgr32">   2  </span><span class="sgr91">   1  </span><span class="sgr33">     1  </span><span class="sgr36">    4  </span>0.4s
RNG of the outermost testset: Random.Xoshiro(0x732ec090fcb704bd, 0x9a913f7799a668a4, 0xae4eb6f8a09cacfb, 0x1dcba99a0df446a2, 0x7afdb5094e678dfe)
ERROR: <span class="sgr91">Some tests did not pass: 2 passed, 1 failed, 0 errored, 1 broken.</span></code></pre><h2 id="cthulhu-integration"><a class="docs-heading-anchor" href="#cthulhu-integration">Integration with Cthulhu</a><a id="cthulhu-integration-1"></a><a class="docs-heading-anchor-permalink" href="#cthulhu-integration" title="Permalink"></a></h2><p>If you identify inference problems, you may want to fix them. Cthulhu can be a useful tool for gaining more insight, and JET integrates nicely with Cthulhu.</p><p>To exploit Cthulhu, you first need to split the overall report into individual inference failures:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; report = @report_opt sumup(sin);</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; rpts = JET.get_reports(report)</code><code class="nohighlight hljs ansi" style="display:block;">7-element Vector{JET.InferenceErrorReport}:
 RuntimeDispatchReport(<span class="sgr91">runtime dispatch detected: </span><span class="sgr1">Main.make_vals(%1<span class="sgr96">::Any</span>)<span class="sgr96">::Any</span></span>)
 RuntimeDispatchReport(<span class="sgr91">runtime dispatch detected: </span><span class="sgr1">Main.eltype(%2<span class="sgr96">::Any</span>)<span class="sgr96">::Any</span></span>)
 RuntimeDispatchReport(<span class="sgr91">runtime dispatch detected: </span><span class="sgr1">Main.zero(%3<span class="sgr96">::Any</span>)<span class="sgr96">::Any</span></span>)
 RuntimeDispatchReport(<span class="sgr91">runtime dispatch detected: </span><span class="sgr1">iterate(%2<span class="sgr96">::Any</span>)<span class="sgr96">::Any</span></span>)
 RuntimeDispatchReport(<span class="sgr91">runtime dispatch detected: </span><span class="sgr1">f<span class="sgr96">::typeof(sin)</span>(%11<span class="sgr96">::Any</span>)<span class="sgr96">::Any</span></span>)
 RuntimeDispatchReport(<span class="sgr91">runtime dispatch detected: </span><span class="sgr1">(%10<span class="sgr96">::Any</span> Main.:+ %13<span class="sgr96">::Any</span>)<span class="sgr96">::Any</span></span>)
 RuntimeDispatchReport(<span class="sgr91">runtime dispatch detected: </span><span class="sgr1">iterate(%2<span class="sgr96">::Any</span>, %12<span class="sgr96">::Any</span>)<span class="sgr96">::Any</span></span>)</code></pre><div class="admonition is-success" id="Tip-13f1c904e936ab99"><header class="admonition-header">Tip<a class="admonition-anchor" href="#Tip-13f1c904e936ab99" title="Permalink"></a></header><div class="admonition-body"><p>If <code>rpts</code> is a long list, consider using <code>urpts = unique(reportkey, rpts)</code> to trim it. See <a href="../internals/#JET.reportkey"><code>reportkey</code></a>.</p></div></div><p>Now you can <code>ascend</code> individual reports:</p><pre><code class="nohighlight hljs">julia&gt; using Cthulhu

julia&gt; ascend(rpts[1])
Choose a call for analysis (q to quit):
     runtime dispatch to make_vals(%1::Any)::Any
 &gt;     sumup(::typeof(sin))

Open an editor at a possible caller of
  Tuple{typeof(make_vals), Any}
or browse typed code:
 &gt; &quot;REPL[7]&quot;, sumup: lines [4]
   Browse typed code</code></pre><p><code>ascend</code> will show the full call-chain to reach a particular runtime dispatch; in this case, it was our entry point, but in other cases it may be deeper in the call graph. In this case, we&#39;ve interactively moved the selector <code>&gt;</code> down to the <code>sumup</code> call (you cannot descend into the <code>&quot;runtime dispatch to...&quot;</code> as there is no known code associated with it) and hit <code>&lt;Enter&gt;</code>, at which point Cthulhu showed us that the call to <code>make_vals(::Any)</code> occured only on line 4 of the definition of <code>sumup</code> (which we entered at the REPL). Cthulhu is now prompting us to either open the code in an editor (which will fail in this case, since there is no associated file!) or view the type-annoted code. If we select the &quot;Browse typed code&quot; option we see</p><pre><code class="nohighlight hljs">sumup(f) @ Main REPL[7]:1
 1 function sumup(f::Core.Const(sin))::Any
 2     # this function uses the non-constant global variable `n` here
 3     # and it makes every succeeding operations type-unstable
 4     vals::Any = make_vals(n::Any)::Any
 5     s::Any = zero(eltype(vals::Any)::Any)::Any
 6     for v::Any in vals::Any::Any
 7         (s::Any += f::Core.Const(sin)(v::Any)::Any)::Any
 8     end
 9     return s::Any
10 end
Select a call to descend into or ↩ to ascend. [q]uit. [b]ookmark.
⋮</code></pre><p>with red highlighting to indicate the non-inferable arguments.</p><p>For more information, you&#39;re encouraged to read Cthulhu&#39;s documentation, which includes a video tutorial better-suited to this interactive tool.</p><h2 id="optanalysis-entry"><a class="docs-heading-anchor" href="#optanalysis-entry">Entry Points</a><a id="optanalysis-entry-1"></a><a class="docs-heading-anchor-permalink" href="#optanalysis-entry" title="Permalink"></a></h2><h3 id="optanalysis-interactive-entry"><a class="docs-heading-anchor" href="#optanalysis-interactive-entry">Interactive Entry Points</a><a id="optanalysis-interactive-entry-1"></a><a class="docs-heading-anchor-permalink" href="#optanalysis-interactive-entry" title="Permalink"></a></h3><p>The optimization analysis offers interactive entry points that can be used in the same way as <a href="../jetanalysis/#JET.@report_call"><code>@report_call</code></a> and <a href="../jetanalysis/#JET.report_call"><code>report_call</code></a>:</p><article><details class="docstring" open="true"><summary id="JET.@report_opt"><a class="docstring-binding" href="#JET.@report_opt"><code>JET.@report_opt</code></a> — <span class="docstring-category">Macro</span></summary><section><div><pre><code class="language-julia hljs">@report_opt [jetconfigs...] f(args...)</code></pre><p>Evaluates the arguments to a function call, determines their types, and then calls <a href="#JET.report_opt"><code>report_opt</code></a> on the resulting expression.</p><p>The <a href="../config/#general-configurations">general configurations</a> and <a href="#optanalysis-config">the optimization analysis specific configurations</a> can be specified as an optional argument.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aviatesk/JET.jl/blob/736a3aceb8095e6200ecd68dcfaa8d07a41e4d3a/src/analyzers/optanalyzer.jl#L398-L406">source</a></section></details></article><article><details class="docstring" open="true"><summary id="JET.report_opt"><a class="docstring-binding" href="#JET.report_opt"><code>JET.report_opt</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">report_opt(f, [types]; jetconfigs...) -&gt; JETCallResult
report_opt(tt::Type{&lt;:Tuple}; jetconfigs...) -&gt; JETCallResult
report_opt(mi::Core.MethodInstance; jetconfigs...) -&gt; JETCallResult</code></pre><p>Analyzes a function call with the given type signature to detect optimization failures and unresolved method dispatches.</p><p>The <a href="../config/#general-configurations">general configurations</a> and <a href="#optanalysis-config">the optimization analysis specific configurations</a> can be specified as a keyword argument.</p><p>See <a href="#optanalysis">the documentation of the optimization analysis</a> for more details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aviatesk/JET.jl/blob/736a3aceb8095e6200ecd68dcfaa8d07a41e4d3a/src/analyzers/optanalyzer.jl#L380-L392">source</a></section></details></article><h3 id="optanalysis-test-integration"><a class="docs-heading-anchor" href="#optanalysis-test-integration"><code>Test</code> Integration</a><a id="optanalysis-test-integration-1"></a><a class="docs-heading-anchor-permalink" href="#optanalysis-test-integration" title="Permalink"></a></h3><p>As with <a href="../jetanalysis/#jetanalysis">the default error analysis</a>, the optimization analysis also offers the integration with <a href="https://docs.julialang.org/en/v1/stdlib/Test/"><code>Test</code> standard library</a>:</p><article><details class="docstring" open="true"><summary id="JET.@test_opt"><a class="docstring-binding" href="#JET.@test_opt"><code>JET.@test_opt</code></a> — <span class="docstring-category">Macro</span></summary><section><div><pre><code class="language-julia hljs">@test_opt [jetconfigs...] [broken=false] [skip=false] f(args...)</code></pre><p>Runs <a href="#JET.@report_opt"><code>@report_opt jetconfigs... f(args...)</code></a> and tests that the function call <code>f(args...)</code> is free from optimization failures and unresolved method dispatches that <code>@report_opt</code> can detect.</p><p>As with <a href="#JET.@report_opt"><code>@report_opt</code></a>, the <a href="../config/#general-configurations">general configurations</a> and <a href="#optanalysis-config">optimization analysis specific configurations</a> can be specified as an optional argument:</p><pre><code class="language-julia-repl hljs">julia&gt; function f(n)
            r = sincos(n)
            # `println` is full of runtime dispatches,
            # but we can ignore the corresponding reports from `Base`
            # with the `target_modules` configuration
            println(r)
            return r
       end;

julia&gt; @test_opt target_modules=(@__MODULE__,) f(10)
Test Passed
  Expression: #= REPL[3]:1 =# JET.@test_call analyzer = JET.OptAnalyzer target_modules = (#= REPL[3]:1 =# @__MODULE__(),) f(10)</code></pre><p>Like <a href="../jetanalysis/#JET.@test_call"><code>@test_call</code></a>, <code>@test_opt</code> is fully integrated with the <a href="https://docs.julialang.org/en/v1/stdlib/Test/"><code>Test</code> standard library</a>. See <a href="../jetanalysis/#JET.@test_call"><code>@test_call</code></a> for the details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aviatesk/JET.jl/blob/736a3aceb8095e6200ecd68dcfaa8d07a41e4d3a/src/analyzers/optanalyzer.jl#L411-L439">source</a></section></details></article><article><details class="docstring" open="true"><summary id="JET.test_opt"><a class="docstring-binding" href="#JET.test_opt"><code>JET.test_opt</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">test_opt(f, [types]; broken::Bool = false, skip::Bool = false, jetconfigs...)
test_opt(tt::Type{&lt;:Tuple}; broken::Bool = false, skip::Bool = false, jetconfigs...)</code></pre><p>Runs <a href="#JET.report_opt"><code>report_opt</code></a> on a function call with the given type signature and tests that it is free from optimization failures and unresolved method dispatches that <code>report_opt</code> can detect. Except that it takes a type signature rather than a call expression, this function works in the same way as <a href="#JET.@test_opt"><code>@test_opt</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aviatesk/JET.jl/blob/736a3aceb8095e6200ecd68dcfaa8d07a41e4d3a/src/analyzers/optanalyzer.jl#L444-L452">source</a></section></details></article><h3 id="optanalysis-toplevel-entry"><a class="docs-heading-anchor" href="#optanalysis-toplevel-entry">Top-level Entry Points</a><a id="optanalysis-toplevel-entry-1"></a><a class="docs-heading-anchor-permalink" href="#optanalysis-toplevel-entry" title="Permalink"></a></h3><p>By default, JET doesn&#39;t offer top-level entry points for the optimization analysis, because it&#39;s usually used for only a selective portion of your program. But if you want you can just use <a href="../jetanalysis/#JET.report_file"><code>report_file</code></a> or similar top-level entry points with specifying <code>analyzer = OptAnalyzer</code> configuration in order to apply the optimization analysis on a top-level script, e.g. <code>report_file(&quot;path/to/file.jl&quot;; analyzer = OptAnalyzer)</code>.</p><h2 id="optanalysis-config"><a class="docs-heading-anchor" href="#optanalysis-config">Configurations</a><a id="optanalysis-config-1"></a><a class="docs-heading-anchor-permalink" href="#optanalysis-config" title="Permalink"></a></h2><p>In addition to the <a href="../config/#general-configurations">general configurations</a>, the optimization analysis can take the following specific configurations:</p><article><details class="docstring" open="true"><summary id="JET.OptAnalyzer"><a class="docstring-binding" href="#JET.OptAnalyzer"><code>JET.OptAnalyzer</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>Every <a href="#optanalysis-entry">entry point of optimization analysis</a> can accept any of the <a href="../config/#general-configurations">general configurations</a> as well as the following additional configurations that are specific to the optimization analysis.</p><hr/><ul><li><p><code>skip_noncompileable_calls::Bool = true</code>:<br/>Julia&#39;s runtime dispatch is &quot;powerful&quot; because it can always compile code with concrete runtime arguments so that <a href="https://docs.julialang.org/en/v1/manual/performance-tips/#kernel-functions">a &quot;kernel&quot; function</a> runs very effectively even if it&#39;s called from a type-instable call site. This means, we (really) often accept that some parts of our code are not inferred statically, and rather we want to just rely on information that is only available at runtime. To model this programming style, the optimization analyzer by default does NOT report any optimization failures or runtime dispatches detected within non-concrete calls (more correctly, &quot;non-compileable&quot; calls are ignored: see also the note below). We can turn off this <code>skip_noncompileable_calls</code> configuration to get type-instabilities within those calls.</p><pre><code class="language-julia-repl hljs"># the following examples are adapted from https://docs.julialang.org/en/v1/manual/performance-tips/#kernel-functions
julia&gt; function fill_twos!(a)
           for i = eachindex(a)
               a[i] = 2
           end
       end;

julia&gt; function strange_twos(n)
           a = Vector{rand(Bool) ? Int64 : Float64}(undef, n)
           fill_twos!(a)
           return a
       end;

# by default, only type-instabilities within concrete call (i.e. `strange_twos(3)`) are reported
# and those within non-concrete calls (`fill_twos!(a)`) are not reported
julia&gt; @report_opt strange_twos(3)
═════ 2 possible errors found ═════
┌ strange_twos(n::Int64) @ Main ./REPL[23]:2
│ runtime dispatch detected: %33::Type{Vector{_A}} where _A(undef, n::Int64)::Vector
└────────────────────
┌ strange_twos(n::Int64) @ Main ./REPL[23]:3
│ runtime dispatch detected: fill_twos!(%34::Vector)::Any
└────────────────────

# we can get reports from non-concrete calls with `skip_noncompileable_calls=false`
julia&gt; @report_opt skip_noncompileable_calls=false strange_twos(3)
┌ strange_twos(n::Int64) @ Main ./REPL[23]:3
│┌ fill_twos!(a::Vector) @ Main ./REPL[22]:3
││┌ setindex!(A::Vector, x::Int64, i1::Int64) @ Base ./array.jl:1014
│││ runtime dispatch detected: convert(%5::Any, x::Int64)::Any
││└────────────────────
│┌ fill_twos!(a::Vector) @ Main ./REPL[22]:3
││ runtime dispatch detected: ((a::Vector)[%13::Int64] = 2::Any)
│└────────────────────
┌ strange_twos(n::Int64) @ Main ./REPL[23]:2
│ runtime dispatch detected: %33::Type{Vector{_A}} where _A(undef, n::Int64)::Vector
└────────────────────
┌ strange_twos(n::Int64) @ Main ./REPL[23]:3
│ runtime dispatch detected: fill_twos!(%34::Vector)::Any
└────────────────────</code></pre><div class="admonition is-info" id="Non-compileable-calls-80a8e25296c729f1"><header class="admonition-header">Non-compileable calls<a class="admonition-anchor" href="#Non-compileable-calls-80a8e25296c729f1" title="Permalink"></a></header><div class="admonition-body"><p>Julia runtime system sometimes generate and execute native code of an abstract call. More technically, when some of call arguments are annotated as <code>@nospecialize</code>, Julia compiles the call even if those <code>@nospecialize</code>d arguments aren&#39;t fully concrete. <code>skip_noncompileable_calls = true</code> also respects this behavior, i.e. doesn&#39;t skip compileable abstract calls:</p><pre><code class="language-julia-repl hljs">julia&gt; function maybesin(x)
           if isa(x, Number)
               return sin(x)
           else
               return 0
           end
       end;

julia&gt; report_opt((Vector{Any},)) do xs
           for x in xs
               # This `maybesin` call is dynamically dispatched since `maybesin(::Any)`
               # is not compileable. Therefore, JET by default will only report the
               # runtime dispatch of `maybesin` while it will not report the runtime
               # dispatch within `maybesin(::Any)`.
               s = maybesin(x)
               s !== 0 &amp;&amp; return s
           end
       end
═════ 1 possible error found ═════
┌ (::var&quot;#3#4&quot;)(xs::Vector{Any}) @ Main ./REPL[3]:7
│ runtime dispatch detected: maybesin(%19::Any)::Any
└────────────────────

julia&gt; function maybesin(@nospecialize x) # mark `x` with `@nospecialize`
           if isa(x, Number)
               return sin(x)
           else
               return 0
           end
       end;

julia&gt; report_opt((Vector{Any},)) do xs
           for x in xs
               # Now `maybesin` is marked with `@nospecialize` allowing `maybesin(::Any)`
               # to be resolved statically and compiled. Thus JET will not report the
               # runtime dispatch of `maybesin(::Any)`, although it now reports the
               # runtime dispatch _within_ `maybesin(::Any)`.
               s = maybesin(x)
               s !== 0 &amp;&amp; return s
           end
       end
═════ 1 possible error found ═════
┌ (::var&quot;#5#6&quot;)(xs::Vector{Any}) @ Main ./REPL[5]:7
│┌ maybesin(x::Any) @ Main ./REPL[4]:3
││ runtime dispatch detected: sin(%3::Number)::Any
│└────────────────────</code></pre></div></div></li></ul><hr/><ul><li><p><code>function_filter = @nospecialize(f)-&gt;true</code>:<br/>A predicate which takes a function object and returns <code>false</code> to skip runtime dispatch analysis on calls of the function. This configuration is particularly useful when your program uses a function that is intentionally designed to use runtime dispatch.</p><pre><code class="language-julia-repl hljs"># ignore `Compiler.widenconst` calls (since it&#39;s designed to be runtime-dispatched):
julia&gt; function_filter(@nospecialize f) = f !== Compiler.widenconst;

julia&gt; @test_opt function_filter=function_filter f(args...)
...</code></pre></li></ul><hr/></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aviatesk/JET.jl/blob/736a3aceb8095e6200ecd68dcfaa8d07a41e4d3a/src/analyzers/optanalyzer.jl#L1-L130">source</a></section></details></article><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-1"><a class="tag is-link" href="#citeref-1">1</a>Technically, it&#39;s fully integrated with <a href="https://julialang.org/blog/2020/08/invalidations/">Julia&#39;s method invalidation system</a>.</li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../jetanalysis/">« Error Analysis</a><a class="docs-footer-nextpage" href="../config/">Configurations »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Sunday 15 February 2026 13:57">Sunday 15 February 2026</span>. Using Julia version 1.12.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
