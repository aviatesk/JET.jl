var documenterSearchIndex = {"docs":
[{"location":"tutorial/#JET-tutorial","page":"Tutorial","title":"JET tutorial","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"JET leverages the Julia compiler's inference to check user code for type instability and type errors. This tutorial will demonstrate how to use JET effectively. It presupposes the reader has working knowledge of Julia, and understands Julian concepts such as \"dynamic dispatch\" and \"type stability\" - see the Julia documentation for explanation of these concepts.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Because JET relies on the compiler's type inference, it is not able to effectively analyze type unstable code. Making your code type stable is a prerequisite for effectively using JET's type error analysis. Therefore, we will begin by showing how to use JET to fix type instabilities.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"First of all, you need to install JET: JET is a standard Julia package. So you can just install it via Julia's built-in package manager and use it just like any other package:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> using Pkg; Pkg.add(\"JET\")\n[ some output elided ]\n\njulia> using JET","category":"page"},{"location":"tutorial/#Detecting-type-instability-with-@report_opt","page":"Tutorial","title":"Detecting type instability with @report_opt","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"JET exports a function report_opt and the related macro @report_opt. It works similar to the function/macro pair (@)code_warntype from Base - except that it automatically analyses all the way down the function chain, and that it only displays any issues found.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"For example, suppose we have the function:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"add_one_first(x) = first(x) + 1;","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Any type instabilities of a given function call can be analysed thus:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"@report_opt add_one_first([1])\n@report_opt add_one_first(Any[1])","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"You can see that add_one_first is type stable when called with a Vector{Int}, but it leads to dynamic dispatch when called with Vector{Any}.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Suppose now we have two levels of type instability, where one type instability \"hides behind\" another type instability, as in this example:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"add_one_first(x) = first(x) + 1;\nfunc_var = add_one_first;\nf(x) = func_var(x);\n@report_opt f(Any[1])","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The dynamic dispatch we see here come from the fact that func_var is an untyped global variable. Remember that add_one_first was also type unstable when called with a Vector{Any}. So why doesn't @report_opt report that second type instability from calling add_one_first(::Vector{Any})? The reason is that because the Julia compiler does not know at compile time that func_var is equal to add_one_first, JET cannot \"see through\" the first type instability and see that add_one_first(Any[1]) will eventually be called.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"If we fix the first instability by defining the global variable my_func_var as const:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"const my_func_var = add_one_first;","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Then the compiler knows that add_one_first will be called, and the second type instability from this function is revealed:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"f(x) = my_func_var(x)\n@report_opt f(Any[1])","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Sometimes, type instability only shows up much deeper into a call chain, several functions deep. This is not a problem for JET. In the example below, JET sees type instability ~10 function calls deep:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"@report_opt sum(Any[1])","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"As mentioned above, effective use of JET begins with liberal use of @report_opt to eliminate or reduce any dynamic dispatch, such that the Julia compiler is not blinded by dynamic dispatch.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"After the program has been made as type stable as possible, it's time to use @report_call to find type errors.","category":"page"},{"location":"tutorial/#Analyse-methods-with-@report_call","page":"Tutorial","title":"Analyse methods with @report_call","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The function/macro pair report_call and @report_call works just like (@)report_opt - but where the latter reports dynamic dispatch, the former finds type errors.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The @report_call macro analyses function calls like so:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"@report_call sum(['a'])","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"In this example, JET found two possible type errors:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"If the input vector is empty, the function call will error with a MethodError after attempting to call zero(Char).\nIf the input vector has two or more elements, the call will error after attempting to call +(::Char, ::Char).","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Note that these type errors show up even though the input vector had exactly one element, and so neither of these errors would actually occur at runtime if sum(['a']) had been executed. This happens because JET analyses the code on a type level, only looking at the code generated with the input types. It does not analyze what will actually happen with the given input value.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Note also that the two possible errors shown are mutally exclusive - no input will lead to both errors. Nonetheless, JET is able to detect both possibilities, because it analyses all possible branches in the generated function call.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"In contrast, if we analyse the same sum method on a Vector{Int} instead of Vector{Char}:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"@report_call sum([1])","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The two errors above do not appear. These errors do not apply to Vector{Int}, because zero(Int) is well-defined and so is +(::Int, ::Int). This illustrates that JET does not analyze methods, but rather function calls with specific types. More precisely, JET analyses so-called methodinstances, since methodinstances are compiled whereas methods are not.","category":"page"},{"location":"tutorial/#Analyse-whole-packages-with-report_package","page":"Tutorial","title":"Analyse whole packages with report_package","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"As shown above, methods cannot be analyzed, but only methodinstances, i.e. methods plus the types of their arguments. Most packages, however, define only methods, and do not contain callsites. That is, they do not have any information about the types that these methods will be called with.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"However, JET is able to do limited analysis using only the method signature extracted from the method definition. For example, if I define this simple function:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"first_plus_n(itr, n::Real) = first(itr) + n;","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":", then at the very least, we can guarantee that itr isa Any and n isa Real. Hence, JET can analyze the methodinstance first_plus_n(::Any, ::Real), using only the method definition.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The JET function report_package extracts all method definitions in a package, and using the extracted signatures, runs report_call on them. For example, the package BioSymbols can be analysed like this:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> using JET\n\njulia> report_package(BioSymbols)\n[ output elided ]","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Note that report_package is less precise than @report_call, because method signatures of idiomatic Julia code are often very generic, so there is less type information in the signature itself than there is when given concrete argument types.","category":"page"},{"location":"tutorial/#Usage-tips","page":"Tutorial","title":"Usage tips","text":"","category":"section"},{"location":"tutorial/#Use-@report_opt-before-@report_call","page":"Tutorial","title":"Use @report_opt before @report_call","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"JET works best on type-stable code. Iron out type instabilities using @report_opt before using @report_call","category":"page"},{"location":"tutorial/#Filtering-away-false-positives","page":"Tutorial","title":"Filtering away false positives","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"It is common to find that JET finds lots of errors in your functions, which all derive from type instability and type issues in your dependencies. In fact, type issues from dependencies are often so plentiful they flood your analysis with false positives, which can make working with JET harder.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"To reduce false positives, you can use the keywords ignored_modules and target_modules.Both take an iterable of modules.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The former removes any errors that originate from any of the given modules, while the latter removes any errors except ones originating from these modules.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"For example, in the REPL (which is in module Main), we can define:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"g(x) = first(x) + 1","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"This throws in a Base function if we pass nothing into it:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"@report_call g(nothing)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Since the error originates from Base, we can filter the error away by ignoring Base, or equivalently, we may retain only the ones from Main. Note that we pass (Base,) as a 1-element Tuple of modules:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"@report_call ignored_modules=(Base,) g(nothing)\n@report_call target_modules=(@__MODULE__,) g(nothing)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The AnyFrameModule construct can be used to filter for (or against) any error where any of the function calls in the callchain originates from the given module. For example, in the example above, the function call begins in Main and ends in Base, so the callchain includes both modules. Ignoring AnyFrameModule(Base) or AnyFrameModule(Main) will then ignore the error:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"@report_call ignored_modules=(AnyFrameModule(Base),) g(nothing)\n@report_call ignored_modules=(AnyFrameModule(@__MODULE__),) g(nothing)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Similarly, the error would be retained if target_modules would have been AnyFrameModule(Base) or AnyFrameModule(Main).","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Beware that this filtering may filter away legitimate problems in your package. In the example above, if your code calls f(nothing), the error may originate from Base, but it's clearly an error in your own code to call f(nothing). So it is recommended to only filter away modules if they produce so many false positives that it makes using JET difficult.","category":"page"},{"location":"tutorial/#Analyze-scripts-and-apps-by-using-a-main-function","page":"Tutorial","title":"Analyze scripts and apps by using a main function","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Scripts and apps called from the command line have a single logical entry point. If you wrap the logic in a main function, JET can analyse the entire script.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"For example, suppose you made this command-line script which added two numbers from the command line:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"a = parse(Int, first(ARGS))\nb = parse(Int, last(ARGS))\nprintln(a + b)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"You could rewrite this as:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"function main()\n    a = parse(Int, first(ARGS))\n    b = parse(Int, last(ARGS))\n    println(a + b)\nend\n\nmain()","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":", and then analyse the script with JET using @report_call main(). Using a main function has the further advantage that it makes it for other people to understand what your script does when invoked.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Alternatively, JET also provides the function report_file, which you can call like:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> report_file(\"my_script.jl\")","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":", which will be equivalent to checking @report_call main(), if the script contains a main() call at top level.","category":"page"},{"location":"tutorial/#Analyze-packages-using-a-representative-workload","page":"Tutorial","title":"Analyze packages using a representative workload","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"As shown above, packages can be analysed with report_package. However, generic type signatures often used in packages lead to imprecise inference and thus imprecise analysis.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"To improve analysis, you can create a file src/workload.jl in your package, which uses all (or most) functionality of the package. The function could look like:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"function exercise_mypkg()\n    data = MyPkg.load_data()\n    transformed = MyPkg.transform_data(data)\n    # [ etc ...]\nend","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Because such usage necessarily requires passing concrete types to your functions, calling @report_call exercise_mypkg() leads to more precise analysis than report_package.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Furthermore, once you have written a function like exercise_mypkg, you can use a package like PrecompileTools to precompile the function, which will thus precompile all code exercised in the function, significantly reducing your package's latency.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Conversely, if you've already implemented a precompile workload, you can do the following:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using MyPkg, JET, MethodAnalysis\nmis = methodinstances(MyPkg)    # get all the compiled methodinstances for functions owned by the package\n# Now let's filter out the ones that pass without issue\nbadmis = filter(mis) do mi\n    !isempty(JET.get_reports(report_call(mi)))\nend","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Then you can inspect the methodinstances in badmis individually with report_call(mi).","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"There are two caveats to note:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"methodinstances(MyPkg) only covers functions owned by MyPkg. If MyPkg defines an \"extension\" method OtherPkg.f(...), any corresponding methodinstances would appear in the list for OtherPkg.\nif you disable precompilation for your development version of the package, you'll get a greatly-reduced list of methodinstances that does not reflect ordinary usage. This style of JET analysis should only be performed on packages that are actively using their precompilation workloads.","category":"page"},{"location":"optanalysis/#optanalysis","page":"Optimization Analysis","title":"Optimization Analysis","text":"","category":"section"},{"location":"optanalysis/","page":"Optimization Analysis","title":"Optimization Analysis","text":"Successful type inference and optimization are key to high-performing Julia programs. But as mentioned in the performance tips, there are some chances where Julia can not infer the types of your program very well and can not optimize it well accordingly.","category":"page"},{"location":"optanalysis/","page":"Optimization Analysis","title":"Optimization Analysis","text":"While there are many possibilities of \"type-instabilities\", like usage of non-constant global variable most notably, probably the most tricky one would be \"captured variable\" – Julia can not really well infer the type of variable that is observed and modified by both inner function and enclosing one. And such type instabilities can lead to various optimization failures. One of the most common barriers to performance is known as \"runtime dispatch\", which happens when a matching method can't be resolved by the compiler due to the lack of type information and it is looked up at runtime instead. Since runtime dispatch is caused by poor type information, it often indicates the compiler could not do other optimizations including inlining and scalar replacements of aggregates.","category":"page"},{"location":"optanalysis/","page":"Optimization Analysis","title":"Optimization Analysis","text":"In order to avoid such problems, we usually inspect the output of code_typed or its family, and check if there is anywhere type is not well inferred and optimization was not successful. But the problem is that one needs to have enough knowledge about inference and optimization in order to interpret the output. Another problem is that they can only present the \"final\" output of the inference and optimization, and we can not inspect the entire call graph and may miss finding where a problem actually happened and how the type-instability has been propagated. There is a nice package called Cthulhu.jl, which allows us to look at the outputs of code_typed by descending into a call tree, recursively and interactively. The workflow with Cthulhu is much more efficient and powerful, but still, it requires much familiarity with the Julia compiler and it tends to be tedious.","category":"page"},{"location":"optanalysis/","page":"Optimization Analysis","title":"Optimization Analysis","text":"So, why not automate it? JET implements such an analyzer that investigates the optimized representation of your program and automatically detects anywhere the compiler failed in optimization. Especially, it can find where Julia creates captured variables, where runtime dispatch will happen, and where Julia gives up the optimization work due to unresolvable recursive function call.","category":"page"},{"location":"optanalysis/","page":"Optimization Analysis","title":"Optimization Analysis","text":"SnoopCompile also detects inference failures, but JET and SnoopCompile use different mechanisms: JET performs static analysis of a particular call, while SnoopCompile performs dynamic analysis of new inference. As a consequence, JET's detection of inference failures is reproducible (you can run the same analysis repeatedly and get the same result) but terminates at any non-inferable node of the call graph: you will miss runtime dispatch in any non-inferable callees. Conversely, SnoopCompile's detection of inference failures can explore the entire callgraph, but only for those portions that have not been previously inferred, and the analysis cannot be repeated in the same session.","category":"page"},{"location":"optanalysis/#optanalysis-quick-start","page":"Optimization Analysis","title":"Quick Start","text":"","category":"section"},{"location":"optanalysis/","page":"Optimization Analysis","title":"Optimization Analysis","text":"using JET","category":"page"},{"location":"optanalysis/","page":"Optimization Analysis","title":"Optimization Analysis","text":"JET exports @report_opt, which analyzes the entire call graph of a given generic function call, and then reports detected performance pitfalls.","category":"page"},{"location":"optanalysis/","page":"Optimization Analysis","title":"Optimization Analysis","text":"As a first example, let's see how we can find and fix runtime dispatches using JET:","category":"page"},{"location":"optanalysis/","page":"Optimization Analysis","title":"Optimization Analysis","text":"n = rand(Int); # non-constant global variable\nmake_vals(n) = n ≥ 0 ? (zero(n):n) : (n:zero(n));\nfunction sumup(f)\n    # this function uses the non-constant global variable `n` here\n    # and it makes every succeeding operations type-unstable\n    vals = make_vals(n)\n    s = zero(eltype(vals))\n    for v in vals\n        s += f(v)\n    end\n    return s\nend;\n@report_opt sumup(sin) # runtime dispatches will be reported","category":"page"},{"location":"optanalysis/","page":"Optimization Analysis","title":"Optimization Analysis","text":"JET's analysis result will be dynamically updated when we (re-)define functions[1], and we can \"hot-fix\" the runtime dispatches within the same running Julia session like this:","category":"page"},{"location":"optanalysis/","page":"Optimization Analysis","title":"Optimization Analysis","text":"# we can pass parameters as a function argument instead, and then everything will be type-stable\nfunction sumup(f, n)\n    vals = make_vals(n)\n    s = zero(eltype(vals))\n    for v in vals\n        # NOTE here we may get union type like `s::Union{Int,Float64}`,\n        # but Julia can optimize away such small unions (thus no runtime dispatch)\n        s += f(v)\n    end\n    return s\nend;\n\n@report_opt sumup(sin, rand(Int)) # now runtime dispatch free !","category":"page"},{"location":"optanalysis/","page":"Optimization Analysis","title":"Optimization Analysis","text":"[1]: Technically, it's fully integrated with Julia's method invalidation system.","category":"page"},{"location":"optanalysis/","page":"Optimization Analysis","title":"Optimization Analysis","text":"@report_opt can also report the existence of captured variables, which are really better to be eliminated within performance-sensitive context:","category":"page"},{"location":"optanalysis/","page":"Optimization Analysis","title":"Optimization Analysis","text":"# the examples below are all adapted from https://docs.julialang.org/en/v1/manual/performance-tips/#man-performance-captured\nfunction abmult(r::Int)\n    if r < 0\n        r = -r\n    end\n    # the closure assigned to `f` make the variable `r` captured\n    f = x -> x * r\n    return f\nend;\n@report_opt abmult(42)\n\nfunction abmult(r0::Int)\n    # we can improve the type stability of the variable `r` like this,\n    # but it is still captured\n    r::Int = r0\n    if r < 0\n        r = -r\n    end\n    f = x -> x * r\n    return f\nend;\n@report_opt abmult(42)\n\nfunction abmult(r::Int)\n    if r < 0\n        r = -r\n    end\n    # we can try to eliminate the capturing\n    # and now this function would be the most performing\n    f = let r = r\n        x -> x * r\n    end\n    return f\nend;\n@report_opt abmult(42)","category":"page"},{"location":"optanalysis/","page":"Optimization Analysis","title":"Optimization Analysis","text":"With the target_modules configuration, we can easily limit the analysis scope to a specific module context:","category":"page"},{"location":"optanalysis/","page":"Optimization Analysis","title":"Optimization Analysis","text":"# problem: when ∑1/n exceeds `x` ?\nfunction compute(x)\n    r = 1\n    s = 0.0\n    n = 1\n    @time while r < x\n        s += 1/n\n        if s ≥ r\n            # `println` call is full of runtime dispatches for good reasons\n            # and we're not interested in type-instabilities within this call\n            # since we know it's only called a few times\n            println(\"round $r/$x has been finished\")\n            r += 1\n        end\n        n += 1\n    end\n    return n, s\nend\n\n@report_opt compute(30) # bunch of reports will be reported from the `println` call\n\n@report_opt target_modules=(@__MODULE__,) compute(30) # focus on what we wrote, and no error should be reported","category":"page"},{"location":"optanalysis/","page":"Optimization Analysis","title":"Optimization Analysis","text":"There is also function_filter, which can ignore specific function calls.","category":"page"},{"location":"optanalysis/","page":"Optimization Analysis","title":"Optimization Analysis","text":"@test_opt can be used to assert that a given function call is free from performance pitfalls. It is fully integrated with Test standard library's unit-testing infrastructure, and we can use it like other Test macros e.g. @test:","category":"page"},{"location":"optanalysis/","page":"Optimization Analysis","title":"Optimization Analysis","text":"@test_opt sumup(cos)\n\n@test_opt target_modules=(@__MODULE__,) compute(30)\n\nusing Test\n\n@testset \"check type-stabilities\" begin\n    @test_opt sumup(cos) # should fail\n\n    n = rand(Int)\n    @test_opt sumup(cos, n) # should pass\n\n    @test_opt target_modules=(@__MODULE__,) compute(30) # should pass\n\n    @test_opt broken=true compute(30) # should pass with the \"broken\" annotation\nend","category":"page"},{"location":"optanalysis/#cthulhu-integration","page":"Optimization Analysis","title":"Integration with Cthulhu","text":"","category":"section"},{"location":"optanalysis/","page":"Optimization Analysis","title":"Optimization Analysis","text":"If you identify inference problems, you may want to fix them. Cthulhu can be a useful tool for gaining more insight, and JET integrates nicely with Cthulhu.","category":"page"},{"location":"optanalysis/","page":"Optimization Analysis","title":"Optimization Analysis","text":"To exploit Cthulhu, you first need to split the overall report into individual inference failures:","category":"page"},{"location":"optanalysis/","page":"Optimization Analysis","title":"Optimization Analysis","text":"report = @report_opt sumup(sin);\nrpts = JET.get_reports(report)","category":"page"},{"location":"optanalysis/","page":"Optimization Analysis","title":"Optimization Analysis","text":"tip: Tip\nIf rpts is a long list, consider using urpts = unique(reportkey, rpts) to trim it. See reportkey.","category":"page"},{"location":"optanalysis/","page":"Optimization Analysis","title":"Optimization Analysis","text":"Now you can ascend individual reports:","category":"page"},{"location":"optanalysis/","page":"Optimization Analysis","title":"Optimization Analysis","text":"julia> using Cthulhu\n\njulia> ascend(rpts[1])\nChoose a call for analysis (q to quit):\n     runtime dispatch to make_vals(%1::Any)::Any\n >     sumup(::typeof(sin))\n\nOpen an editor at a possible caller of\n  Tuple{typeof(make_vals), Any}\nor browse typed code:\n > \"REPL[7]\", sumup: lines [4]\n   Browse typed code","category":"page"},{"location":"optanalysis/","page":"Optimization Analysis","title":"Optimization Analysis","text":"ascend will show the full call-chain to reach a particular runtime dispatch; in this case, it was our entry point, but in other cases it may be deeper in the call graph. In this case, we've interactively moved the selector > down to the sumup call (you cannot descend into the \"runtime dispatch to...\" as there is no known code associated with it) and hit <Enter>, at which point Cthulhu showed us that the call to make_vals(::Any) occured only on line 4 of the definition of sumup (which we entered at the REPL). Cthulhu is now prompting us to either open the code in an editor (which will fail in this case, since there is no associated file!) or view the type-annoted code. If we select the \"Browse typed code\" option we see","category":"page"},{"location":"optanalysis/","page":"Optimization Analysis","title":"Optimization Analysis","text":"sumup(f) @ Main REPL[7]:1\n 1 function sumup(f::Core.Const(sin))::Any\n 2     # this function uses the non-constant global variable `n` here\n 3     # and it makes every succeeding operations type-unstable\n 4     vals::Any = make_vals(n::Any)::Any\n 5     s::Any = zero(eltype(vals::Any)::Any)::Any\n 6     for v::Any in vals::Any::Any\n 7         (s::Any += f::Core.Const(sin)(v::Any)::Any)::Any\n 8     end\n 9     return s::Any\n10 end\nSelect a call to descend into or ↩ to ascend. [q]uit. [b]ookmark.\n⋮","category":"page"},{"location":"optanalysis/","page":"Optimization Analysis","title":"Optimization Analysis","text":"with red highlighting to indicate the non-inferable arguments.","category":"page"},{"location":"optanalysis/","page":"Optimization Analysis","title":"Optimization Analysis","text":"For more information, you're encouraged to read Cthulhu's documentation, which includes a video tutorial better-suited to this interactive tool.","category":"page"},{"location":"optanalysis/#optanalysis-entry","page":"Optimization Analysis","title":"Entry Points","text":"","category":"section"},{"location":"optanalysis/#optanalysis-interactive-entry","page":"Optimization Analysis","title":"Interactive Entry Points","text":"","category":"section"},{"location":"optanalysis/","page":"Optimization Analysis","title":"Optimization Analysis","text":"The optimization analysis offers interactive entry points that can be used in the same way as @report_call and report_call:","category":"page"},{"location":"optanalysis/#JET.@report_opt","page":"Optimization Analysis","title":"JET.@report_opt","text":"@report_opt [jetconfigs...] f(args...)\n\nEvaluates the arguments to a function call, determines their types, and then calls report_opt on the resulting expression.\n\nThe general configurations and the optimization analysis specific configurations can be specified as an optional argument.\n\n\n\n\n\n","category":"macro"},{"location":"optanalysis/#JET.report_opt","page":"Optimization Analysis","title":"JET.report_opt","text":"report_opt(f, [types]; jetconfigs...) -> JETCallResult\nreport_opt(tt::Type{<:Tuple}; jetconfigs...) -> JETCallResult\nreport_opt(mi::Core.MethodInstance; jetconfigs...) -> JETCallResult\n\nAnalyzes a function call with the given type signature to detect optimization failures and unresolved method dispatches.\n\nThe general configurations and the optimization analysis specific configurations can be specified as a keyword argument.\n\nSee the documentation of the optimization analysis for more details.\n\n\n\n\n\n","category":"function"},{"location":"optanalysis/#optanalysis-test-integration","page":"Optimization Analysis","title":"Test Integration","text":"","category":"section"},{"location":"optanalysis/","page":"Optimization Analysis","title":"Optimization Analysis","text":"As with the default error analysis, the optimization analysis also offers the integration with Test standard library:","category":"page"},{"location":"optanalysis/#JET.@test_opt","page":"Optimization Analysis","title":"JET.@test_opt","text":"@test_opt [jetconfigs...] [broken=false] [skip=false] f(args...)\n\nRuns @report_opt jetconfigs... f(args...) and tests that the function call f(args...) is free from optimization failures and unresolved method dispatches that @report_opt can detect.\n\nAs with @report_opt, the general configurations and optimization analysis specific configurations can be specified as an optional argument:\n\njulia> function f(n)\n            r = sincos(n)\n            # `println` is full of runtime dispatches,\n            # but we can ignore the corresponding reports from `Base`\n            # with the `target_modules` configuration\n            println(r)\n            return r\n       end;\n\njulia> @test_opt target_modules=(@__MODULE__,) f(10)\nTest Passed\n  Expression: #= REPL[3]:1 =# JET.@test_call analyzer = JET.OptAnalyzer target_modules = (#= REPL[3]:1 =# @__MODULE__(),) f(10)\n\nLike @test_call, @test_opt is fully integrated with the Test standard library. See @test_call for the details.\n\n\n\n\n\n","category":"macro"},{"location":"optanalysis/#JET.test_opt","page":"Optimization Analysis","title":"JET.test_opt","text":"test_opt(f, [types]; broken::Bool = false, skip::Bool = false, jetconfigs...)\ntest_opt(tt::Type{<:Tuple}; broken::Bool = false, skip::Bool = false, jetconfigs...)\n\nRuns report_opt on a function call with the given type signature and tests that it is free from optimization failures and unresolved method dispatches that report_opt can detect. Except that it takes a type signature rather than a call expression, this function works in the same way as @test_opt.\n\n\n\n\n\n","category":"function"},{"location":"optanalysis/#optanalysis-toplevel-entry","page":"Optimization Analysis","title":"Top-level Entry Points","text":"","category":"section"},{"location":"optanalysis/","page":"Optimization Analysis","title":"Optimization Analysis","text":"By default, JET doesn't offer top-level entry points for the optimization analysis, because it's usually used for only a selective portion of your program. But if you want you can just use report_file or similar top-level entry points with specifying analyzer = OptAnalyzer configuration in order to apply the optimization analysis on a top-level script, e.g. report_file(\"path/to/file.jl\"; analyzer = OptAnalyzer).","category":"page"},{"location":"optanalysis/#optanalysis-config","page":"Optimization Analysis","title":"Configurations","text":"","category":"section"},{"location":"optanalysis/","page":"Optimization Analysis","title":"Optimization Analysis","text":"In addition to the general configurations, the optimization analysis can take the following specific configurations:","category":"page"},{"location":"optanalysis/#JET.OptAnalyzer","page":"Optimization Analysis","title":"JET.OptAnalyzer","text":"Every entry point of optimization analysis can accept any of the general configurations as well as the following additional configurations that are specific to the optimization analysis.\n\n\n\nskip_noncompileable_calls::Bool = true:\nJulia's runtime dispatch is \"powerful\" because it can always compile code with concrete runtime arguments so that a \"kernel\" function runs very effectively even if it's called from a type-instable call site. This means, we (really) often accept that some parts of our code are not inferred statically, and rather we want to just rely on information that is only available at runtime. To model this programming style, the optimization analyzer by default does NOT report any optimization failures or runtime dispatches detected within non-concrete calls (more correctly, \"non-compileable\" calls are ignored: see also the note below). We can turn off this skip_noncompileable_calls configuration to get type-instabilities within those calls.\n# the following examples are adapted from https://docs.julialang.org/en/v1/manual/performance-tips/#kernel-functions\njulia> function fill_twos!(a)\n           for i = eachindex(a)\n               a[i] = 2\n           end\n       end;\n\njulia> function strange_twos(n)\n           a = Vector{rand(Bool) ? Int64 : Float64}(undef, n)\n           fill_twos!(a)\n           return a\n       end;\n\n# by default, only type-instabilities within concrete call (i.e. `strange_twos(3)`) are reported\n# and those within non-concrete calls (`fill_twos!(a)`) are not reported\njulia> @report_opt strange_twos(3)\n═════ 2 possible errors found ═════\n┌ strange_twos(n::Int64) @ Main ./REPL[23]:2\n│ runtime dispatch detected: %33::Type{Vector{_A}} where _A(undef, n::Int64)::Vector\n└────────────────────\n┌ strange_twos(n::Int64) @ Main ./REPL[23]:3\n│ runtime dispatch detected: fill_twos!(%34::Vector)::Any\n└────────────────────\n\n# we can get reports from non-concrete calls with `skip_noncompileable_calls=false`\njulia> @report_opt skip_noncompileable_calls=false strange_twos(3)\n┌ strange_twos(n::Int64) @ Main ./REPL[23]:3\n│┌ fill_twos!(a::Vector) @ Main ./REPL[22]:3\n││┌ setindex!(A::Vector, x::Int64, i1::Int64) @ Base ./array.jl:1014\n│││ runtime dispatch detected: convert(%5::Any, x::Int64)::Any\n││└────────────────────\n│┌ fill_twos!(a::Vector) @ Main ./REPL[22]:3\n││ runtime dispatch detected: ((a::Vector)[%13::Int64] = 2::Any)\n│└────────────────────\n┌ strange_twos(n::Int64) @ Main ./REPL[23]:2\n│ runtime dispatch detected: %33::Type{Vector{_A}} where _A(undef, n::Int64)::Vector\n└────────────────────\n┌ strange_twos(n::Int64) @ Main ./REPL[23]:3\n│ runtime dispatch detected: fill_twos!(%34::Vector)::Any\n└────────────────────\nnote: Non-compileable calls\nJulia runtime system sometimes generate and execute native code of an abstract call. More technically, when some of call arguments are annotated as @nospecialize, Julia compiles the call even if those @nospecialized arguments aren't fully concrete. skip_noncompileable_calls = true also respects this behavior, i.e. doesn't skip compileable abstract calls:julia> function maybesin(x)\n           if isa(x, Number)\n               return sin(x)\n           else\n               return 0\n           end\n       end;\n\njulia> report_opt((Vector{Any},)) do xs\n           for x in xs\n               # This `maybesin` call is dynamically dispatched since `maybesin(::Any)`\n               # is not compileable. Therefore, JET by default will only report the\n               # runtime dispatch of `maybesin` while it will not report the runtime\n               # dispatch within `maybesin(::Any)`.\n               s = maybesin(x)\n               s !== 0 && return s\n           end\n       end\n═════ 1 possible error found ═════\n┌ (::var\"#3#4\")(xs::Vector{Any}) @ Main ./REPL[3]:7\n│ runtime dispatch detected: maybesin(%19::Any)::Any\n└────────────────────\n\njulia> function maybesin(@nospecialize x) # mark `x` with `@nospecialize`\n           if isa(x, Number)\n               return sin(x)\n           else\n               return 0\n           end\n       end;\n\njulia> report_opt((Vector{Any},)) do xs\n           for x in xs\n               # Now `maybesin` is marked with `@nospecialize` allowing `maybesin(::Any)`\n               # to be resolved statically and compiled. Thus JET will not report the\n               # runtime dispatch of `maybesin(::Any)`, although it now reports the\n               # runtime dispatch _within_ `maybesin(::Any)`.\n               s = maybesin(x)\n               s !== 0 && return s\n           end\n       end\n═════ 1 possible error found ═════\n┌ (::var\"#5#6\")(xs::Vector{Any}) @ Main ./REPL[5]:7\n│┌ maybesin(x::Any) @ Main ./REPL[4]:3\n││ runtime dispatch detected: sin(%3::Number)::Any\n│└────────────────────\n\n\n\nfunction_filter = @nospecialize(f)->true:\nA predicate which takes a function object and returns false to skip runtime dispatch analysis on calls of the function. This configuration is particularly useful when your program uses a function that is intentionally designed to use runtime dispatch.\n# ignore `Compiler.widenconst` calls (since it's designed to be runtime-dispatched):\njulia> function_filter(@nospecialize f) = f !== Compiler.widenconst;\n\njulia> @test_opt function_filter=function_filter f(args...)\n...\n\n\n\n\n\n\n\n","category":"type"},{"location":"generated-plugin-api/#AbstractAnalyzer-Framework","page":"API","title":"AbstractAnalyzer Framework","text":"","category":"section"},{"location":"generated-plugin-api/","page":"API","title":"API","text":"Pages = [\"generated-plugin-api.md\"]","category":"page"},{"location":"generated-plugin-api/","page":"API","title":"API","text":"JET offers an infrastructure to implement a \"plugin\" code analyzer. Actually, JET's default error analyzer is one specific instance of such a plugin analyzer built on top of the framework.","category":"page"},{"location":"generated-plugin-api/","page":"API","title":"API","text":"In this documentation we will try to elaborate the framework APIs and showcase example analyzers.","category":"page"},{"location":"generated-plugin-api/","page":"API","title":"API","text":"warning: Warning\nThe APIs described in this page is very experimental and subject to changes. And this documentation is also very WIP.","category":"page"},{"location":"generated-plugin-api/#Interfaces","page":"API","title":"Interfaces","text":"","category":"section"},{"location":"generated-plugin-api/#JET.JETInterface","page":"API","title":"JET.JETInterface","text":"JETInterface\n\nThis baremodule exports names that form the APIs of AbstractAnalyzer Framework. using JET.JETInterface loads all names that are necessary to define a plugin analysis.\n\n\n\n\n\n","category":"module"},{"location":"generated-plugin-api/#JET.AbstractAnalyzer","page":"API","title":"JET.AbstractAnalyzer","text":"abstract type AbstractAnalyzer <: AbstractInterpreter end\n\nAn interface type of analyzers that are built on top of JET's analyzer framework.\n\nWhen a new type NewAnalyzer implements the AbstractAnalyzer interface, it should be declared as subtype of AbstractAnalyzer, and is expected to implement the following interfaces:\n\nRequired interfaces\n\nJETInterface.AnalyzerState(analyzer::NewAnalyzer) -> AnalyzerState: Returns the AnalyzerState for analyzer::NewAnalyzer.\nJETInterface.AbstractAnalyzer(analyzer::NewAnalyzer, state::AnalyzerState) -> NewAnalyzer: Constructs a new NewAnalyzer instance in the middle of JET's top-level analysis or abstract interpretation, given the previous analyzer::NewAnalyzer and state::AnalyzerState.\nJETInterface.AnalysisToken(analyzer::NewAnalyzer) -> AnalysisToken: Returns a unique AnalysisToken object used for analyzer::NewAnalyzer.\n\nSee also AnalyzerState and AnalysisToken.\n\nExample\n\nJET.jl defines its default error analyzer BasicJETAnalyzer <: AbstractAnalyzer as the following (modified a bit for the sake of simplicity):\n\n# the default error analyzer for JET.jl\nstruct BasicJETAnalyzer <: AbstractAnalyzer\n    state::AnalyzerState\n    analysis_token::AnalysisToken\n    # ... other fields\nend\n\n# AbstractAnalyzer API requirements\nJETInterface.AnalyzerState(analyzer::BasicJETAnalyzer) = analyzer.state\nJETInterface.AbstractAnalyzer(analyzer::BasicJETAnalyzer, state::AnalyzerState) =\n    BasicJETAnalyzer(state, analyzer.analysis_token, ...)\nJETInterface.AnalysisToken(analyzer::BasicJETAnalyzer) = analyzer.analysis_token\n\n\n\n\n\n","category":"type"},{"location":"generated-plugin-api/#JET.AnalyzerState","page":"API","title":"JET.AnalyzerState","text":"mutable struct AnalyzerState\n    ...\nend\n\nThe mutable object that holds various states that are consumed by all AbstractAnalyzers.\n\n\n\nJETInterface.AnalyzerState(analyzer::AbstractAnalyzer) -> AnalyzerState\n\nIf NewAnalyzer implements the AbstractAnalyzer interface, NewAnalyzer should implement this AnalyzerState(analyzer::NewAnalyzer) -> AnalyzerState interface.\n\nA new AnalyzerState is supposed to be constructed using the general configurations passed as keyword arguments jetconfigs of the NewAnalyzer(; jetconfigs...) constructor, and the constructed AnalyzerState is usually kept within NewAnalyzer itself:\n\nfunction NewAnalyzer(world::UInt=Base.get_world_counter(); jetconfigs...)\n    ...\n    state = AnalyzerState(world; jetconfigs...)\n    return NewAnalyzer(..., state)\nend\nJETInterface.AnalyzerState(analyzer::NewAnalyzer) = analyzer.state\n\n\n\n\n\n","category":"type"},{"location":"generated-plugin-api/#JET.AnalysisToken-Tuple{JET.AbstractAnalyzer}","page":"API","title":"JET.AnalysisToken","text":"JETInterface.AnalysisToken(analyzer::AbstractAnalyzer) -> AnalysisToken\n\nReturns AnalysisToken for the given analyzer::AbstractAnalyzer. AbstractAnalyzer instances can share the same cache if they perform the same analysis, otherwise their cache should be separated.\n\nIf NewAnalyzer implements the AbstractAnalyzer interface, it must implement this function to return a consistent token for instances that should share the same cache.\n\n\n\n\n\n","category":"method"},{"location":"generated-plugin-api/#JET.ToplevelAbstractAnalyzer","page":"API","title":"JET.ToplevelAbstractAnalyzer","text":"abstract type ToplevelAbstractAnalyzer <: AbstractAnalyzer end\n\nA specialized interface type for analyzers that perform top-level analysis of Julia code.\n\nToplevelAbstractAnalyzer extends AbstractAnalyzer to provide clear separation between analyzers that support top-level analysis and those that don't, offering several key architectural benefits:\n\nType Safety: Only analyzers that explicitly extend ToplevelAbstractAnalyzer can be used with JET's virtual_process system, making it clear at compile time which analyzers support top-level analysis capabilities.\nResponsibility Separation: Analyzers like OptAnalyzer that don't perform top-level analysis are no longer required to handle top-level specific code paths, reducing complexity and improving performance.\n\nTop-Level Analysis Capabilities\n\nToplevelAbstractAnalyzer provides specialized functionality for analyzing top-level Julia constructs such as:\n\nGlobal variable assignments\nConstant declarations (const statements)\nModule definitions and imports\nMethod definitions at the top level\nPackage-level code execution\n\nThis analyzer type is used in virtual_process system to analyze Julia code as it would be executed at the top level, handling both concrete interpretation of some statements and abstract interpretation of others.\n\nUsage\n\nToplevelAbstractAnalyzer is typically used through JET's virtual process system:\n\n# Create a concrete interpreter with a toplevel analyzer\ninterp = JETConcreteInterpreter(JETAnalyzer(...))\nanalyzer = ToplevelAbstractAnalyzer(interp)\n\n# Analyze top-level code\nresult = analyze_and_report_text!(interp, \"x = 1; y = x + 1\")\n\nImplementation Requirements\n\nConcrete subtypes of ToplevelAbstractAnalyzer must implement all the interfaces required by AbstractAnalyzer, and will automatically inherit the specialized top-level analysis behaviors provided by this type.\n\nSee Also\n\nAbstractAnalyzer: The base analyzer interface\nJETAnalyzer: JET's default error analyzer that implements this interface\nvirtual_process: The main function that uses this analyzer type\nConcreteInterpreter: The concrete interpreter that works with this analyzer\n\n\n\n\n\n","category":"type"},{"location":"generated-plugin-api/#JET.valid_configurations","page":"API","title":"JET.valid_configurations","text":"JETInterface.valid_configurations(analyzer::AbstractAnalyzer) -> names or nothing\n\nReturns a set of names that are valid as a configuration for analyzer. names should be an iterator of Symbol. No validations are performed if nothing is returned.\n\n\n\n\n\n","category":"function"},{"location":"generated-plugin-api/#JET.aggregation_policy","page":"API","title":"JET.aggregation_policy","text":"JETInterface.aggregation_policy(analyzer::AbstractAnalyzer)\n\nDefines how analyzer aggregates InferenceErrorReports. This policy determines how duplicate or similar reports are identified and grouped. Defaults to default_aggregation_policy.\n\n\n\ndefault_aggregation_policy(report::InferenceErrorReport) -> DefaultReportIdentity\n\nReturns the default identity of report::InferenceErrorReport using DefaultReportIdentity, which aggregates reports based on their \"error location\".\n\nDefaultReportIdentity aggregates InferenceErrorReports by creating an identity based on:\n\nThe report type\nThe signature of the method where the error was found\nThe file and line number where the error occurred\n\nThis approach ignores the specific MethodInstance identity, allowing errors to be aggregated if they occur at the same file and line, under the assumption that errors at the same location are likely duplicates even if in different method specializations.\n\n\n\n\n\n","category":"function"},{"location":"generated-plugin-api/#JET.typeinf_world","page":"API","title":"JET.typeinf_world","text":"typeinf_world(analyzer::AbstractAnalyzer) -> world::Union{UInt,Nothing}\n\nReturn the world age to use for type inference performed by the given analyzer, or nothing to use the current world.\n\nWhen a specific world age is returned, the analyzer will invoke type inference within that fixed world using Base.invoke_in_world. This makes the analysis implementation more robust against potential invalidations that may be caused by loading external packages.\n\nThe default implementation returns nothing, meaning type inference runs in the latest world. Specific analyzer implementations may override this to return a fixed world age for stability.\n\n\n\n\n\n","category":"function"},{"location":"generated-plugin-api/#JET.VSCode.vscode_diagnostics_order","page":"API","title":"JET.VSCode.vscode_diagnostics_order","text":"vscode_diagnostics_order(analyzer::AbstractAnalyzer) -> Bool\n\nIf true (default) a diagnostic will be reported at entry site. Otherwise it's reported at error point.\n\n\n\n\n\n","category":"function"},{"location":"generated-plugin-api/#JET.InferenceErrorReport-Tuple{}","page":"API","title":"JET.InferenceErrorReport","text":"InferenceErrorReport\n\nIn order for Report <: InferenceErrorReport to implement the interface, it should satisfy the following requirements:\n\nRequired fields \nReport should have the following fields, which explains where and how this error is reported:\nvst::VirtualStackTrace: a virtual stack trace of the error\nsig::Signature: a signature of the error point\nNote that Report can have additional fields other than vst and sig to explain why this error is reported (mostly used for print_report_message).\nRequired overloads \n\nJETInterface.copy_report(report::Report) -> new::Report\nJETInterface.print_report_message(io::IO, report::Report)\nOptional overloads \n\nJETInterface.print_signature(::Report) -> Bool\nJETInterface.report_color(::Report) -> Symbol\n\nReport <: InferenceErrorReport is supposed to be constructed using the following constructor\n\nReport(::AbstractAnalyzer, state, spec_args...) -> Report\n\nwhere state can be either of:\n\nstate::Tuple{Union{Compiler.InferenceState, Compiler.OptimizationState}, Int64}: a state with the current program counter specified\nstate::InferenceState: a state with the current program counter set to state.currpc\nstate::InferenceResult: a state with the current program counter unknown\nstate::MethodInstance: a state with the current program counter unknown\n\nSee also: @jetreport, VirtualStackTrace, VirtualFrame\n\n\n\n\n\n","category":"method"},{"location":"generated-plugin-api/#JET.ToplevelErrorReport-Tuple{}","page":"API","title":"JET.ToplevelErrorReport","text":"ToplevelErrorReport()\n\nIn order for Report <: ToplevelErrorReport to implement the interface, it should satisfy the following requirements:\n\nRequired fields \nReport should have the following fields:\nfile::String: the filename of this error\nline::Int: the line number of this error\nRequired overloads \n\nJETInterface.print_report(io::IO, report::Report)\n\n\n\n\n\n","category":"method"},{"location":"generated-plugin-api/#JET.copy_report","page":"API","title":"JET.copy_report","text":"JETInterface.copy_report(orig::Report) where Report<:InferenceErrorReport -> new::Report\n\nReturns new new::Report, that should be identical to the original orig::Report, except that new.vst is copied from orig.vst so that the further modification on orig.vst that may happen in later abstract interpretation doesn't affect new.vst.\n\n\n\n\n\n","category":"function"},{"location":"generated-plugin-api/#JET.print_report","page":"API","title":"JET.print_report","text":"print_report(io::IO, report::ToplevelErrorReport)\n\nPrints a report of the top-level error report to the given io.\n\n\n\n\n\n","category":"function"},{"location":"generated-plugin-api/#JET.print_report_message","page":"API","title":"JET.print_report_message","text":"JETInterface.print_report_message(io::IO, report::Report) where Report<:InferenceErrorReport\n\nPrints to io and describes why report is reported.\n\n\n\n\n\n","category":"function"},{"location":"generated-plugin-api/#JET.print_signature","page":"API","title":"JET.print_signature","text":"JETInterface.print_signature(::Report) where Report<:InferenceErrorReport -> Bool\n\nConfigures whether or not to print the report signature when printing Report (defaults to true).\n\n\n\n\n\n","category":"function"},{"location":"generated-plugin-api/#JET.report_color","page":"API","title":"JET.report_color","text":"JETInterface.report_color(::Report) where Report<:InferenceErrorReport -> Symbol\n\nConfigures the color for Report (defaults to :red).\n\n\n\n\n\n","category":"function"},{"location":"generated-plugin-api/#JET.analyze_and_report_call!","page":"API","title":"JET.analyze_and_report_call!","text":"analyze_and_report_call!(analyzer::AbstractAnalyzer, f, [types]; jetconfigs...) -> JETCallResult\nanalyze_and_report_call!(analyzer::AbstractAnalyzer, tt::Type{<:Tuple}; jetconfigs...) -> JETCallResult\nanalyze_and_report_call!(analyzer::AbstractAnalyzer, mi::MethodInstance; jetconfigs...) -> JETCallResult\n\nA generic entry point to analyze a function call with AbstractAnalyzer. Finally returns the analysis result as JETCallResult. Note that this is intended to be used by developers of AbstractAnalyzer only. General users should use high-level entry points like report_call and report_opt.\n\n\n\n\n\n","category":"function"},{"location":"generated-plugin-api/#JET.call_test_ex","page":"API","title":"JET.call_test_ex","text":"call_test_ex(funcname::Symbol, testname::Symbol, ex0, __module__, __source__)\n\nAn internal utility function to implement a @test_call-like macro. See the implementation of @test_call.\n\n\n\n\n\n","category":"function"},{"location":"generated-plugin-api/#JET.func_test","page":"API","title":"JET.func_test","text":"func_test(func, testname::Symbol, args...; jetconfigs...)\n\nAn internal utility function to implement a test_call-like function. See the implementation of test_call.\n\n\n\n\n\n","category":"function"},{"location":"generated-plugin-api/#JET.analyze_and_report_file!","page":"API","title":"JET.analyze_and_report_file!","text":"analyze_and_report_file!(interp::ConcreteInterpreter, filename::AbstractString; jetconfigs...) -> JETToplevelResult\n\nA generic entry point to analyze a file with interp::ConcreteInterpreter. Finally returns the analysis result as JETToplevelResult. Note that this is intended to be used by developers of AbstractAnalyzer and ConcreteInterpreter only. General users should use high-level entry points like report_file.\n\n\n\n\n\n","category":"function"},{"location":"generated-plugin-api/#JET.analyze_and_report_package!","page":"API","title":"JET.analyze_and_report_package!","text":"analyze_and_report_package!(interp::ConcreteInterpreter,\n                            package::Union{AbstractString,Module,Nothing} = nothing;\n                            jetconfigs...) -> JETToplevelResult\n\nA generic entry point to analyze a package with interp::ConcreteInterpreter. Finally returns the analysis result as JETToplevelResult. Note that this is intended to be used by developers of AbstractAnalyzer and ConcreteInterpreter only. General users should use high-level entry points like report_package.\n\n\n\n\n\n","category":"function"},{"location":"generated-plugin-api/#JET.analyze_and_report_text!","page":"API","title":"JET.analyze_and_report_text!","text":"analyze_and_report_text!(interp::ConcreteInterpreter, text::AbstractString,\n                         filename::AbstractString = \"top-level\";\n                         jetconfigs...) -> JETToplevelResult\n\nA generic entry point to analyze a top-level code with interp::ConcreteInterpreter. Finally returns the analysis result as JETToplevelResult. Note that this is intended to be used by developers of AbstractAnalyzer and ConcreteInterpreter only. General users should use high-level entry points like report_text.\n\n\n\n\n\n","category":"function"},{"location":"generated-plugin-api/#JET.add_new_report!","page":"API","title":"JET.add_new_report!","text":"add_new_report!(analyzer::AbstractAnalyzer, result::InferenceResult, report::InferenceErrorReport)\n\nAdds a new error report to the analyzer's collection for a specific inference result.\n\nThis function associates an InferenceErrorReport with its corresponding result::InferenceResult in the analyzer's internal storage. The report becomes part of the analysis results that can be retrieved later using get_reports(analyzer, result).\n\nReports are stored in the order they are added, which can be important for maintaining the logical sequence of errors discovered during analysis.\n\n\n\n\n\n","category":"function"},{"location":"generated-plugin-api/#JET.@jetreport","page":"API","title":"JET.@jetreport","text":"@jetreport struct NewReport <: InferenceErrorReport\n    ...\nend\n\nA utility macro to define InferenceErrorReport. It can be very tedious to manually satisfy the InferenceErrorReport interfaces. JET internally uses this @jetreport utility macro, which takes a struct definition of InferenceErrorReport without the required fields specified, and automatically defines the struct as well as constructor definitions. If the report NewReport <: InferenceErrorReport is defined using @jetreport, then NewReport just needs to implement the print_report_message interface.\n\nFor example, JETAnalyzer's MethodErrorReport is defined as follows:\n\n@jetreport struct MethodErrorReport <: InferenceErrorReport\n    @nospecialize t # ::Union{Type, Vector{Type}}\n    union_split::Int\nend\nfunction print_report_message(io::IO, (; t, union_split)::MethodErrorReport)\n    print(io, \"no matching method found for \")\n    if union_split == 0\n        print_callsig(io, t)\n    else\n        ts = t::Vector{Any}\n        nts = length(ts)\n        for i = 1:nts\n            print_callsig(io, ts[i])\n            i == nts || print(io, \", \")\n        end\n        print(io, \" (\", nts, '/', union_split, \" union split)\")\n    end\nend\n\nand constructed as like MethodErrorReport(sv::InferenceState, atype::Any, 0).\n\n\n\n\n\n","category":"macro"},{"location":"generated-plugin-api/#Examples","page":"API","title":"Examples","text":"","category":"section"},{"location":"generated-plugin-api/","page":"API","title":"API","text":"Pages = [\"generated-plugin-examples/dispatch_analysis.md\", \"generated-plugin-examples/find_unstable_api.md\"]","category":"page"},{"location":"generated-plugin-examples/find_unstable_api/#\"Unstable-API\"-Analysis","page":"\"Unstable API\" Analysis","title":"\"Unstable API\" Analysis","text":"","category":"section"},{"location":"generated-plugin-examples/find_unstable_api/#Motivation","page":"\"Unstable API\" Analysis","title":"Motivation","text":"","category":"section"},{"location":"generated-plugin-examples/find_unstable_api/","page":"\"Unstable API\" Analysis","title":"\"Unstable API\" Analysis","text":"Julia doesn't have any facilities to truly hide module internals. This means, we can always access to whatever defined within a module and use it freely, but some of them may be considered as the module's \"internal\"s and subject to changes. When possible, we want to avoid their usages for better maintainability in the future. But the problem is, how can we automatically find them already used in an existing code ?","category":"page"},{"location":"generated-plugin-examples/find_unstable_api/","page":"\"Unstable API\" Analysis","title":"\"Unstable API\" Analysis","text":"This analysis is motivated by this discussion.","category":"page"},{"location":"generated-plugin-examples/find_unstable_api/#Implementation","page":"\"Unstable API\" Analysis","title":"Implementation","text":"","category":"section"},{"location":"generated-plugin-examples/find_unstable_api/","page":"\"Unstable API\" Analysis","title":"\"Unstable API\" Analysis","text":"Let's define \"unstable API\" s such that, they're","category":"page"},{"location":"generated-plugin-examples/find_unstable_api/","page":"\"Unstable API\" Analysis","title":"\"Unstable API\" Analysis","text":"undefined binding, or\nnot exported nor documented, if defined","category":"page"},{"location":"generated-plugin-examples/find_unstable_api/","page":"\"Unstable API\" Analysis","title":"\"Unstable API\" Analysis","text":"and now we can implement such analyzer that detects code that matches the definition above using JET.jl's pluggable-analysis framework.","category":"page"},{"location":"generated-plugin-examples/find_unstable_api/","page":"\"Unstable API\" Analysis","title":"\"Unstable API\" Analysis","text":"The implementation below is almost sound, under the assumption that the bindings are resolved statically. One thing to note is that, the analysis implements an heuristic to avoid false positives from \"language intrinsics\", for example, Base.indexed_iterate and Base.Broadcast.broadcasted. They're usually introduced into your code implicitly by Julia's iteration protocols and such, and we're not responsible for their details (thus not interested in their usages). But the problem is that the analyzer below doesn't distinguish those introduced by the language and those written by ourselves, and in the latter case we're certainly uses \"unstable API\" under the definition above.","category":"page"},{"location":"generated-plugin-examples/find_unstable_api/","page":"\"Unstable API\" Analysis","title":"\"Unstable API\" Analysis","text":"using JET\nusing JET.JETInterface   # to load APIs of the pluggable analysis framework\nusing JET: CC            # to inject a customized report pass","category":"page"},{"location":"generated-plugin-examples/find_unstable_api/","page":"\"Unstable API\" Analysis","title":"\"Unstable API\" Analysis","text":"First off, we define UnstableAPIAnalyzer, which is a new AbstractAnalyzer and will implement the customized report pass","category":"page"},{"location":"generated-plugin-examples/find_unstable_api/","page":"\"Unstable API\" Analysis","title":"\"Unstable API\" Analysis","text":"struct UnstableAPIAnalyzer{T} <: ToplevelAbstractAnalyzer\n    state::AnalyzerState\n    analysis_token::AnalysisToken\n    is_target_module::T\nend\nJETInterface.AnalyzerState(analyzer::UnstableAPIAnalyzer) = analyzer.state\nJETInterface.AbstractAnalyzer(analyzer::UnstableAPIAnalyzer, state::AnalyzerState) =\n    UnstableAPIAnalyzer(state, analyzer.analysis_token, analyzer.is_target_module)\nJETInterface.AnalysisToken(analyzer::UnstableAPIAnalyzer) = analyzer.analysis_token\n\nconst UNSTABLE_API_ANALYZER_CACHE = Dict{UInt, AnalysisToken}()","category":"page"},{"location":"generated-plugin-examples/find_unstable_api/","page":"\"Unstable API\" Analysis","title":"\"Unstable API\" Analysis","text":"Next, we overload some of Base.Compiler's abstract interpretation methods. In this analysis, we are interested in whether a binding that appears in a target code is an \"unstable API\" or not, and we can simply check if each abstract element appeared during abstract interpretation meets our criteria of \"unstable API\". For that purpose, it's suffice to overload CC.abstract_eval_special_value and CC.builtin_tfunction.","category":"page"},{"location":"generated-plugin-examples/find_unstable_api/","page":"\"Unstable API\" Analysis","title":"\"Unstable API\" Analysis","text":"function CC.abstract_eval_special_value(analyzer::UnstableAPIAnalyzer, @nospecialize(e), vtypes::CC.VarTable, sv::CC.InferenceState)\n    if analyzer.is_target_module(sv.mod) # we care only about what we wrote\n        report_unstable_api!(analyzer, sv, e)\n    end\n\n    # recurse into JET's default abstract interpretation routine\n    return @invoke CC.abstract_eval_special_value(analyzer::ToplevelAbstractAnalyzer, e, vtypes::CC.VarTable, sv::CC.InferenceState)\nend\n\nfunction CC.builtin_tfunction(analyzer::UnstableAPIAnalyzer, @nospecialize(f), argtypes::Vector{Any}, sv::CC.InferenceState)\n    if f === getfield\n        if length(argtypes) ≥ 2\n            a1, a2 = argtypes[1:2]\n            if isa(a1, Core.Const) && (v1 = a1.val; isa(v1, Module))\n                if isa(a2, Core.Const) && (v2 = a2.val; isa(v2, Symbol))\n                    if analyzer.is_target_module(sv.mod) || # we care only about what we wrote, but with relaxed filter\n                       (parent = sv.parent; isa(parent, CC.InferenceState) && analyzer.is_target_module(parent.mod))\n                        report_unstable_api!(analyzer, sv, GlobalRef(v1, v2))\n                    end\n                end\n            end\n        end\n    end\n\n    # recurse into JET's default abstract interpretation routine\n    return @invoke CC.builtin_tfunction(analyzer::ToplevelAbstractAnalyzer, f, argtypes::Vector{Any}, sv::CC.InferenceState)\nend","category":"page"},{"location":"generated-plugin-examples/find_unstable_api/","page":"\"Unstable API\" Analysis","title":"\"Unstable API\" Analysis","text":"Additionally, we can cut off the performance cost involved with Julia's native compiler's optimizations passes:","category":"page"},{"location":"generated-plugin-examples/find_unstable_api/","page":"\"Unstable API\" Analysis","title":"\"Unstable API\" Analysis","text":"CC.may_optimize(analyzer::UnstableAPIAnalyzer) = false","category":"page"},{"location":"generated-plugin-examples/find_unstable_api/","page":"\"Unstable API\" Analysis","title":"\"Unstable API\" Analysis","text":"Now we implement the body of our analysis. We define \"unstable API\"s such that they're:","category":"page"},{"location":"generated-plugin-examples/find_unstable_api/","page":"\"Unstable API\" Analysis","title":"\"Unstable API\" Analysis","text":"undefined binding, or\nnot exported nor documented, if defined","category":"page"},{"location":"generated-plugin-examples/find_unstable_api/","page":"\"Unstable API\" Analysis","title":"\"Unstable API\" Analysis","text":"and we're not interested in any other program properties other than whether our code contains \"unstable API\"s or not.","category":"page"},{"location":"generated-plugin-examples/find_unstable_api/","page":"\"Unstable API\" Analysis","title":"\"Unstable API\" Analysis","text":"And now we will define new InferenceErrorReport report type UnstableAPI, which represents the category 2, and implement a report pass to detect it.","category":"page"},{"location":"generated-plugin-examples/find_unstable_api/","page":"\"Unstable API\" Analysis","title":"\"Unstable API\" Analysis","text":"@jetreport struct UnstableAPI <: InferenceErrorReport\n    g::GlobalRef\nend\nfunction JETInterface.print_report_message(io::IO, (; g)::UnstableAPI)\n    (; mod, name) = g\n    mod = Base.binding_module(mod, name)\n    print(io, \"usage of unstable API `\", mod, '.', name, \"` found\")\nend\nJETInterface.report_color(::UnstableAPI) = :yellow\n\nfunction report_unstable_api!(analyzer::UnstableAPIAnalyzer, sv, @nospecialize(e))\n    if isa(e, GlobalRef)\n        (; mod, name) = e\n        isdefined(mod, name) || return false # this global reference falls into the category 1, should be caught by `UndefVarErrorReport` instead\n\n        mod = Base.binding_module(mod, name)\n        analyzer.is_target_module(mod) && return # we don't care about what we defined ourselves\n\n        if isunstable(mod, name)\n            add_new_report!(analyzer, sv.result, UnstableAPI(sv, e))\n        end\n    end\nend","category":"page"},{"location":"generated-plugin-examples/find_unstable_api/","page":"\"Unstable API\" Analysis","title":"\"Unstable API\" Analysis","text":"In the report pass above, isunstable will take the heavy lifting to find \"unstable API\"s. Here we will implement isunstable according to the definition above but with some heuristics to exclude language intrinsics, which can automatically be included into our code and aren't usually of our interest.","category":"page"},{"location":"generated-plugin-examples/find_unstable_api/","page":"\"Unstable API\" Analysis","title":"\"Unstable API\" Analysis","text":"function isunstable(mod, name)\n    # exclude language intrinsics\n    mod === Core && return false\n    x = getfield(mod, name)\n    x isa Core.Builtin && return false\n    (x === Base.indexed_iterate || x === Base.SizeUnknown) && return false # iteration protocol\n    (x === Base.Iterators.Filter || x === Base.Iterators.Flatten) && return false # iterator protocol\n    x === Base.Broadcast.broadcasted && return false # broadcast protocol\n    x === Base.kwerr && return false # ignore keyword lowering\n\n    return !isexported(mod, name) && !hasdoc(mod, name)\nend\n\nfunction isexported(mod, name)\n    mod = Base.binding_module(mod, name)\n    return Base.isexported(mod, name)\nend\n\n# adapted from https://github.com/JunoLab/CodeTools.jl/blob/56e7f0b514a7476864c27523bcf9d4bc04699ce1/src/summaries.jl#L24-L34\n\nusing Base.Docs\nfunction hasdoc(mod, name)\n    binding = Docs.Binding(mod, name)\n    for m in Docs.modules\n        meta = Docs.meta(m)\n        haskey(meta, binding) && return true\n        (; mod, var) = binding\n        isdefined(mod, var) && haskey(meta, getfield(mod, var)) && return true\n    end\n    return false\nend","category":"page"},{"location":"generated-plugin-examples/find_unstable_api/#Usages","page":"\"Unstable API\" Analysis","title":"Usages","text":"","category":"section"},{"location":"generated-plugin-examples/find_unstable_api/","page":"\"Unstable API\" Analysis","title":"\"Unstable API\" Analysis","text":"Now our analyzer is set up. Lastly we are going to set up analysis entry points using the analyzer.","category":"page"},{"location":"generated-plugin-examples/find_unstable_api/","page":"\"Unstable API\" Analysis","title":"\"Unstable API\" Analysis","text":"using InteractiveUtils # to use `gen_call_with_extracted_types_and_kwargs`\n\n# the constructor for creating a new configured `UnstableAPIAnalyzer` instance\nfunction UnstableAPIAnalyzer(world::UInt = Base.get_world_counter();\n    is_target_module = ==(@__MODULE__),\n    jetconfigs...)\n    state = AnalyzerState(world; jetconfigs...)\n    # use a globalized code cache (, which is separated by `InferenceParams` configurations)\n    cache_key = JET.compute_hash(state.inf_params)\n    analysis_token = get!(AnalysisToken, UNSTABLE_API_ANALYZER_CACHE, cache_key)\n    return UnstableAPIAnalyzer(state, analysis_token, is_target_module)\nend\nfunction report_unstable_api!(args...; jetconfigs...)\n    @nospecialize args jetconfigs\n    analyzer = UnstableAPIAnalyzer(; jetconfigs...)\n    return analyze_and_report_call!(analyzer, args...; jetconfigs...)\nend\nmacro report_unstable_api!(ex0...)\n    return InteractiveUtils.gen_call_with_extracted_types_and_kwargs(__module__, :report_unstable_api!, ex0)\nend","category":"page"},{"location":"generated-plugin-examples/find_unstable_api/#Simple-cases","page":"\"Unstable API\" Analysis","title":"Simple cases","text":"","category":"section"},{"location":"generated-plugin-examples/find_unstable_api/","page":"\"Unstable API\" Analysis","title":"\"Unstable API\" Analysis","text":"Let's first use the interactive analysis entries and try simple test cases.","category":"page"},{"location":"generated-plugin-examples/find_unstable_api/","page":"\"Unstable API\" Analysis","title":"\"Unstable API\" Analysis","text":"UnstableAPIAnalyzer can find an \"unstable\" function:","category":"page"},{"location":"generated-plugin-examples/find_unstable_api/","page":"\"Unstable API\" Analysis","title":"\"Unstable API\" Analysis","text":"function some_reflection_code(@nospecialize(f))\n    return any(Base.hasgenerator, methods(f)) # Base.hasgenerator is unstable\nend\n@report_unstable_api! some_reflection_code(sin)","category":"page"},{"location":"generated-plugin-examples/find_unstable_api/","page":"\"Unstable API\" Analysis","title":"\"Unstable API\" Analysis","text":"UnstableAPIAnalyzer can find an \"unstable\" global variable:","category":"page"},{"location":"generated-plugin-examples/find_unstable_api/","page":"\"Unstable API\" Analysis","title":"\"Unstable API\" Analysis","text":"module foo; bar = 1 end\nreport_unstable_api!((Any,)) do a\n    foo.bar + a # foo.bar is unstable\nend","category":"page"},{"location":"generated-plugin-examples/find_unstable_api/","page":"\"Unstable API\" Analysis","title":"\"Unstable API\" Analysis","text":"UnstableAPIAnalyzer can detect \"unstable API\"s even if they're imported binding or nested reference (, which will be resolve to getproperty)","category":"page"},{"location":"generated-plugin-examples/find_unstable_api/","page":"\"Unstable API\" Analysis","title":"\"Unstable API\" Analysis","text":"using Base: hasgenerator\nreport_unstable_api!((Any,)) do mi\n    # NOTE every function call appearing here is unstable\n    ci = hasgenerator(mi) ? CC.get_staged(mi) : Base.uncompressed_ast(mi)\nend","category":"page"},{"location":"generated-plugin-examples/find_unstable_api/#Analyze-a-real-world-package","page":"\"Unstable API\" Analysis","title":"Analyze a real-world package","text":"","category":"section"},{"location":"generated-plugin-examples/find_unstable_api/","page":"\"Unstable API\" Analysis","title":"\"Unstable API\" Analysis","text":"Finally we can use JET's top-level analysis entry points to analyze a whole script or package.","category":"page"},{"location":"generated-plugin-examples/find_unstable_api/","page":"\"Unstable API\" Analysis","title":"\"Unstable API\" Analysis","text":"Here we will run UnstableAPIAnalyzer on IRTools.jl, which uses Base.isgenerated, which is renamed to Base.hasgenerator in Julia v1.7 and invoked the discussion at https://github.com/JuliaLang/julia/pull/40745#issuecomment-850876150. Especially, it uses Base.isgenerator here, and you can see the analyzer correctly detects it if you run the following code with IRTools@v0.4.2 installed.","category":"page"},{"location":"generated-plugin-examples/find_unstable_api/","page":"\"Unstable API\" Analysis","title":"\"Unstable API\" Analysis","text":"# define an entry point for analyzing a package\nfunction report_package_unstable_api(args...; jetconfigs...)\n    analyzer = UnstableAPIAnalyzer(; jetconfigs...)\n    return analyze_and_report_package!(analyzer, args...; jetconfigs...)\nend\n\nusing Pkg #hide\nif \"IRTools\" in keys(Pkg.project().dependencies) #hide\nreport_package_unstable_api(\"IRTools\";\n                            # to only find errors detected within the module context of `IRTools`\n                            target_defined_modules=true)\nelse #hide\n@warn \"IRTools isn't installed in the current environment at $(Pkg.project().path)\" #hide\nend #hide","category":"page"},{"location":"generated-plugin-examples/find_unstable_api/","page":"\"Unstable API\" Analysis","title":"\"Unstable API\" Analysis","text":"═════ 59 possible errors found ═════\n┌ @ /Users/aviatesk/.julia/packages/IRTools/aSVI5/src/reflection/reflection.jl:39 Core.kwfunc(IRTools.Inner.invoke_meta)(Core.apply_type(Core.NamedTuple, (:world,))(Core.tuple(world)), IRTools.Inner.invoke_meta, T)\n│┌ @ /Users/aviatesk/.julia/packages/IRTools/aSVI5/src/reflection/reflection.jl:69 IRTools.Inner.#invoke_meta#6(world, _3, T)\n││┌ @ /Users/aviatesk/.julia/packages/IRTools/aSVI5/src/reflection/reflection.jl:74 Core.kwfunc(IRTools.Inner.meta)(Core.apply_type(Core.NamedTuple, (:types, :world))(Core.tuple(S, world)), IRTools.Inner.meta, T)\n│││┌ @ /Users/aviatesk/.julia/packages/IRTools/aSVI5/src/reflection/reflection.jl:38 IRTools.Inner.#meta#1(types, world, _3, T)\n││││┌ @ /Users/aviatesk/.julia/packages/IRTools/aSVI5/src/reflection/reflection.jl:43 Base._methods_by_ftype\n│││││ usage of unstable API `Base._methods_by_ftype` found\n││││└─────────────────────────────────────────────────────────────────────────────────\n││││┌ @ /Users/aviatesk/.julia/packages/IRTools/aSVI5/src/reflection/reflection.jl:49 Base.isgenerated\n│││││ usage of unstable API `Base.isgenerated` found\n││││└─────────────────────────────────────────────────────────────────────────────────\n││││┌ @ /Users/aviatesk/.julia/packages/IRTools/aSVI5/src/reflection/reflection.jl:49 Base.uncompressed_ast\n│││││ usage of unstable API `Base.uncompressed_ast` found\n││││└─────────────────────────────────────────────────────────────────────────────────\n││││┌ @ /Users/aviatesk/.julia/packages/IRTools/aSVI5/src/reflection/reflection.jl:54\n... # many other \"unstable API\"s detected","category":"page"},{"location":"generated-plugin-examples/find_unstable_api/","page":"\"Unstable API\" Analysis","title":"\"Unstable API\" Analysis","text":"","category":"page"},{"location":"generated-plugin-examples/find_unstable_api/","page":"\"Unstable API\" Analysis","title":"\"Unstable API\" Analysis","text":"This page was generated using Literate.jl.","category":"page"},{"location":"jetanalysis/#jetanalysis","page":"Error Analysis","title":"Error Analysis","text":"","category":"section"},{"location":"jetanalysis/","page":"Error Analysis","title":"Error Analysis","text":"Julia's type system is quite expressive and its type inference is strong enough to generate fairly optimized code from a highly generic program written in a concise syntax. But as opposed to other statically-compiled languages, Julia by design does not error nor warn anything even if it detects possible errors during its compilation process no matter how serious they are. In essence, Julia achieves highly generic and composable programming by delaying all the errors and warnings to the runtime.","category":"page"},{"location":"jetanalysis/","page":"Error Analysis","title":"Error Analysis","text":"This is a core design choice of the language. On the one hand, Julia's dynamism allows it to work in places where data types can not be fully decided ahead of runtime (e.g. when the program is duck-typed with generic pieces of code, or when the program consumes some data that is only known at runtime). On the other hand, with Julia, it's not straightforward to have such modern development experiences that a static language can typically offer, as like static type checking and rich IDE features.","category":"page"},{"location":"jetanalysis/","page":"Error Analysis","title":"Error Analysis","text":"JET is a trial to get the best of both worlds: can we have a sufficiently useful static checking without losing all the beauty of Julia's dynamism and composability? JET's approach is very different from \"gradual typing\", that is a common technique to bring static analysis into a dynamic language, as used for e.g. mypy for Python and TypeScript for JavaScript. Rather, JET's static analysis is powered by Julia's builtin type inference system, that is based on a technique called \"abstract interpretation\". This way JET can analyze just a normal Julia program and smartly detect possible errors statically, without requiring any additional setups like scattering type annotations just for the sake of analysis but preserving original polymorphism and composability of the program, as effectively as the Julia compiler can optimize your Julia program.","category":"page"},{"location":"jetanalysis/#jetanalysis-quick-start","page":"Error Analysis","title":"Quick Start","text":"","category":"section"},{"location":"jetanalysis/","page":"Error Analysis","title":"Error Analysis","text":"using JET","category":"page"},{"location":"jetanalysis/","page":"Error Analysis","title":"Error Analysis","text":"Let's start with the simplest example: how JET can find anything wrong with sum(\"julia\")? @report_call and report_call analyzes a given function call and report back possible problems. They can be used in a similar way as @code_typed and code_typed. Those interactive entry points are the easiest way to use JET:","category":"page"},{"location":"jetanalysis/","page":"Error Analysis","title":"Error Analysis","text":"@report_call sum(\"julia\")","category":"page"},{"location":"jetanalysis/","page":"Error Analysis","title":"Error Analysis","text":"So JET found two possible problems. Now let's see how they can occur in actual execution:","category":"page"},{"location":"jetanalysis/","page":"Error Analysis","title":"Error Analysis","text":"sum(\"julia\") # will lead to `MethodError: +(::Char, ::Char)`\nsum(\"\") # will lead to `MethodError: zero(Type{Char})`","category":"page"},{"location":"jetanalysis/","page":"Error Analysis","title":"Error Analysis","text":"We should note that @report_call sum(\"julia\") could detect both of those two different errors that can happen at runtime. This is because @report_call does a static analysis — it analyzes the function call in a way that does not rely on one instance of runtime execution, but rather it reasons about all the possible executions! This is one of the biggest advantages of static analysis because other alternatives to check software qualities like \"testing\" usually rely on some runtime execution and they can only cover a subset of all the possible executions.","category":"page"},{"location":"jetanalysis/","page":"Error Analysis","title":"Error Analysis","text":"As mentioned above, JET is designed to work with just a normal Julia program. Let's define new arbitrary functions and run JET on it:","category":"page"},{"location":"jetanalysis/","page":"Error Analysis","title":"Error Analysis","text":"function foo(s0)\n    a = []\n    for s in split(s0)\n        push!(a, bar(s))\n    end\n    return sum(a)\nend\n\nbar(s::String) = parse(Int, s)\n\n@report_call foo(\"1 2 3\")","category":"page"},{"location":"jetanalysis/","page":"Error Analysis","title":"Error Analysis","text":"Now let's fix this problematic code. First, we can fix the definition of bar so that it accepts generic AbstractString input. JET's analysis result can be dynamically updated when we refine a function definition, and so we just need to add a new bar(::AbstractString) definition. As for the second error, let's assume, for some reason, we're not interested in fixing it and we want to ignore errors that may happen within Base. Then we can use the target_modules configuration to limit the analysis scope to the current module context to ignore the possible error that may happen within sum(a)[1].","category":"page"},{"location":"jetanalysis/","page":"Error Analysis","title":"Error Analysis","text":"[1]: We used target_modules just for the sake of demonstration. To make it more   idiomatic, we should initialize a as typed vector a = Int[], and then we won't   get any problem from sum(a) even without the target_modules configuration.","category":"page"},{"location":"jetanalysis/","page":"Error Analysis","title":"Error Analysis","text":"# hot fix the definition of `bar`\nbar(s::AbstractString) = parse(Int, s)\n\n# now no errors should be reported !\n@report_call target_modules=(@__MODULE__,) foo(\"1 2 3\")","category":"page"},{"location":"jetanalysis/","page":"Error Analysis","title":"Error Analysis","text":"So far, we have used the default error analysis pass, which collects problems according to one specific (somewhat opinionated) definition of \"errors\". JET offers other error reporting passes, including the \"sound\" error detection as well as the simpler \"typo\" detection pass. They can be switched using the mode configuration:","category":"page"},{"location":"jetanalysis/","page":"Error Analysis","title":"Error Analysis","text":"function myifelse(cond, a, b)\n    if cond\n        return a\n    else\n        return b\n    end\nend\n\n# the default analysis pass doesn't report \"non-boolean (T) used in boolean context\" error\n# as far as there is a possibility when the condition \"can\" be bool (NOTE: Bool <: Integer)\nreport_call(myifelse, (Integer, Int, Int))\n\n# the sound analyzer doesn't permit such a case: it requires the type of a conditional value to be `Bool` strictly\nreport_call(myifelse, (Integer, Int, Int); mode=:sound)\n\nfunction strange_sum(a)\n    if rand(Bool)\n        undefsum(a)\n    else\n        sum(a)\n    end\nend\n\n# the default analysis pass will report both problems:\n# - `undefsum` is not defined\n# - `sum(a::Vector{Any})` can throw when `a` is empty\n@report_call strange_sum([])\n\n# the typo detection pass will only report the \"typo\"\n@report_call mode=:typo strange_sum([])","category":"page"},{"location":"jetanalysis/","page":"Error Analysis","title":"Error Analysis","text":"We can use @test_call and test_call to assert that your program is free from problems that @report_call can detect. They work nicely with Test standard library's unit-testing infrastructure:","category":"page"},{"location":"jetanalysis/","page":"Error Analysis","title":"Error Analysis","text":"@test_call target_modules=(@__MODULE__,) foo(\"1 2 3\")\n\nusing Test\n\n# we can get the nice summery using `@testset` !\n@testset \"JET testset\" begin\n    @test_call target_modules=(@__MODULE__,) foo(\"1 2 3\") # should pass\n\n    test_call(myifelse, (Integer, Int, Int); mode=:sound)\n\n    @test_call broken=true foo(\"1 2 3\") # `broken` and `skip` options are supported\n\n    @test foo(\"1 2 3\") == 6 # of course other `Test` macros can be used in the same place\nend","category":"page"},{"location":"jetanalysis/","page":"Error Analysis","title":"Error Analysis","text":"JET uses JET itself in its test pipeline: JET's static analysis has been proven to be very useful and helped its development a lot. If interested, take a peek at JET's \"self check\" testset.","category":"page"},{"location":"jetanalysis/","page":"Error Analysis","title":"Error Analysis","text":"Lastly, let's see the example that demonstrates JET can analyze a \"top-level\" program. The top-level analysis should be considered as a somewhat experimental feature, and at this moment you may need additional configurations to run it correctly. Please read the descriptions of top-level entry points and choose an appropriate entry point for your use case. Here we run report_file on demo.jl. It automatically extracts and loads \"definitions\" of functions, structs and such, and then analyzes their \"usages\" statically:","category":"page"},{"location":"jetanalysis/","page":"Error Analysis","title":"Error Analysis","text":"report_file(normpath(Base.pkgdir(JET), \"demo.jl\"))","category":"page"},{"location":"jetanalysis/#Errors-kinds-and-how-to-fix-them","page":"Error Analysis","title":"Errors kinds and how to fix them","text":"","category":"section"},{"location":"jetanalysis/#no-matching-method-found","page":"Error Analysis","title":"no matching method found","text":"","category":"section"},{"location":"jetanalysis/#Description","page":"Error Analysis","title":"Description","text":"","category":"section"},{"location":"jetanalysis/","page":"Error Analysis","title":"Error Analysis","text":"This error occurs when running the code might throw a MethodError at runtime. Similar to normal MethodErrors, this happens if a function is being called without a method matching the given argument types.","category":"page"},{"location":"jetanalysis/","page":"Error Analysis","title":"Error Analysis","text":"This is the most common error detected in most Julia code.","category":"page"},{"location":"jetanalysis/#Example","page":"Error Analysis","title":"Example","text":"","category":"section"},{"location":"jetanalysis/","page":"Error Analysis","title":"Error Analysis","text":"f(x::Integer) = x + one(x);\ng(x) = f(x);\n\nusing JET # hide\n@report_call g(1.0)","category":"page"},{"location":"jetanalysis/#How-to-fix","page":"Error Analysis","title":"How to fix","text":"","category":"section"},{"location":"jetanalysis/","page":"Error Analysis","title":"Error Analysis","text":"This error indicates some kind of type error in your code. You fix it like you would fix a regular MethodError thrown at runtime.","category":"page"},{"location":"jetanalysis/#no-matching-method-found-(x/y-union-split)","page":"Error Analysis","title":"no matching method found (x/y union split)","text":"","category":"section"},{"location":"jetanalysis/#Description-2","page":"Error Analysis","title":"Description","text":"","category":"section"},{"location":"jetanalysis/","page":"Error Analysis","title":"Error Analysis","text":"This error occurs when a variable x is inferred to be a union type, and x being one or more of the union's members would lead to a MethodError. For example, if the compiler infers x to be of type Union{A, B}, and then a function f(x) is called which would lead to a MethodError if x is a A, this error would occur.","category":"page"},{"location":"jetanalysis/","page":"Error Analysis","title":"Error Analysis","text":"More technically, this happens when one or more branches created by the compiler through union splitting contains a no matching method found error.","category":"page"},{"location":"jetanalysis/#Example-2","page":"Error Analysis","title":"Example","text":"","category":"section"},{"location":"jetanalysis/","page":"Error Analysis","title":"Error Analysis","text":"Minimal example:","category":"page"},{"location":"jetanalysis/","page":"Error Analysis","title":"Error Analysis","text":"struct Foo\n    x::Union{Int, String}\nend\n\n# Errors if x.x isa String.\n# The compiler doesn't know if it's a String or Int\nf(x) = x.x + 1;\n\nusing JET # hide\n@report_call f(Foo(1))","category":"page"},{"location":"jetanalysis/","page":"Error Analysis","title":"Error Analysis","text":"More common example:","category":"page"},{"location":"jetanalysis/","page":"Error Analysis","title":"Error Analysis","text":"function pos_after_tab(v::AbstractArray{UInt8})\n    # findfirst can return `nothing` on no match\n    p = findfirst(isequal(UInt8('\\t')), v)\n    p + 1\nend\n\n@report_call pos_after_tab(codeunits(\"a\\tb\"))","category":"page"},{"location":"jetanalysis/#How-to-fix-2","page":"Error Analysis","title":"How to fix","text":"","category":"section"},{"location":"jetanalysis/","page":"Error Analysis","title":"Error Analysis","text":"This error is unique in that idiomatic Julia code may still lead to this error. For example, in the pos_after_tab function above, if the input vector does not have a '\\t' byte, p will be nothing, and a MethodError will be thrown when nothing + 1 is attempted. However, in many situations, the possibility of such a MethodError is not a mistake, but rather an idiomatic way of erroring.","category":"page"},{"location":"jetanalysis/","page":"Error Analysis","title":"Error Analysis","text":"There are different possibilities to address this kind of error. Let's take the pos_after_tab example:","category":"page"},{"location":"jetanalysis/","page":"Error Analysis","title":"Error Analysis","text":"If you actually could expect p to legitimately be nothing for valid input (i.e. the input could lack a '\\t' byte), then your function should be written to take this edge case into account:","category":"page"},{"location":"jetanalysis/","page":"Error Analysis","title":"Error Analysis","text":"function pos_after_tab(v::AbstractArray{UInt8})\n    p = findfirst(isequal(UInt8('\\t')), v)\n    if p === nothing # handle the nothing case\n        return nothing\n    else\n        return p + 1\n    end\nend;\n\nusing JET # hide\n@report_call pos_after_tab(codeunits(\"a\\tb\"))","category":"page"},{"location":"jetanalysis/","page":"Error Analysis","title":"Error Analysis","text":"By adding the if p === nothing check, the compiler will know that the type of p must be Nothing inside the if block, and Int in the else block. This way, the compiler knows a MethodError is not possible, and the error will disappear.","category":"page"},{"location":"jetanalysis/","page":"Error Analysis","title":"Error Analysis","text":"If you expect a '\\t' byte to always be present, such that findfirst always should return an Int for valid input, you can add a typeassert in the function to assert that the return value of findfirst must be, say, an Integer. Then, the compiler will know that if the typeassert passes, the value returned by findfirst cannot be nothing (and hence in this case must be Int):","category":"page"},{"location":"jetanalysis/","page":"Error Analysis","title":"Error Analysis","text":"function pos_after_tab(v::AbstractArray{UInt8})\n    p = findfirst(isequal(UInt8('\\t')), v)::Integer\n    p + 1\nend;\n\n@report_call pos_after_tab(codeunits(\"a\\tb\"))","category":"page"},{"location":"jetanalysis/","page":"Error Analysis","title":"Error Analysis","text":"The code will still error at runtime due to the typeassert if findfirst returns nothing, but JET will no longer detect it as an error, because the programmer, by adding the typeassert, explicitly acknowledge that the compiler's inference may not be precise enough, and helps the compiler.","category":"page"},{"location":"jetanalysis/","page":"Error Analysis","title":"Error Analysis","text":"Note that adding a typeassert also improves code quality:","category":"page"},{"location":"jetanalysis/","page":"Error Analysis","title":"Error Analysis","text":"The programmer's intent to never observe nothing is communicated clearly\nAfter the typeassert passes, p is inferred to be Int instead of a union, and this more precise type inference generates more efficient code.\nMore precise inference reduces the risk of invalidations from the code, improving latency.","category":"page"},{"location":"jetanalysis/","page":"Error Analysis","title":"Error Analysis","text":"A special case occurs when loading Union-typed fields from structs. Julia does not realize that loading the same field multiple times from a mutable struct necessarily returns the same object. Hence, in the following example:","category":"page"},{"location":"jetanalysis/","page":"Error Analysis","title":"Error Analysis","text":"mutable struct Foo\n    x::Union{Int, Nothing}\nend\n\nfunction f(x)\n    if x.x === nothing\n        nothing\n    else\n        x.x + 1\n    end\nend;\n\nusing JET # hide\n@report_call f(Foo(1))","category":"page"},{"location":"jetanalysis/","page":"Error Analysis","title":"Error Analysis","text":"We might reasonably expect the compiler to know that in the else branch, x.x must be an Int, since it just checked that it is not nothing. However, the compiler does not know that the value obtained from loading the x field in the expression x.x on the like with the if statement in this case is the same value as the value obtained when loading the x field in the x.x + 1 statement. You can solve this issue by assigning x.x to a variable:","category":"page"},{"location":"jetanalysis/","page":"Error Analysis","title":"Error Analysis","text":"function f(x)\n    y = x.x\n    if y === nothing\n        nothing\n    else\n        y + 1\n    end\nend;\n\n@report_call f(Foo(1))","category":"page"},{"location":"jetanalysis/#X-is-not-defined","page":"Error Analysis","title":"X is not defined","text":"","category":"section"},{"location":"jetanalysis/#Description-3","page":"Error Analysis","title":"Description","text":"","category":"section"},{"location":"jetanalysis/","page":"Error Analysis","title":"Error Analysis","text":"This happens when a name X is used in a function, but no object named X can be found.","category":"page"},{"location":"jetanalysis/#Example-3","page":"Error Analysis","title":"Example","text":"","category":"section"},{"location":"jetanalysis/","page":"Error Analysis","title":"Error Analysis","text":"f(x) = foo(x) + 1;\n\nusing JET # hide\n@report_call f(1)","category":"page"},{"location":"jetanalysis/#How-to-fix-3","page":"Error Analysis","title":"How to fix","text":"","category":"section"},{"location":"jetanalysis/","page":"Error Analysis","title":"Error Analysis","text":"This error can have a couple of causes:","category":"page"},{"location":"jetanalysis/","page":"Error Analysis","title":"Error Analysis","text":"X is misspelled. If so, correct the typo\nX exists, but cannot be reached from the scope of the function. If so, pass it in as an argument to the offending function.","category":"page"},{"location":"jetanalysis/#type-T-has-no-field-F","page":"Error Analysis","title":"type T has no field F","text":"","category":"section"},{"location":"jetanalysis/#Description-4","page":"Error Analysis","title":"Description","text":"","category":"section"},{"location":"jetanalysis/","page":"Error Analysis","title":"Error Analysis","text":"This error occurs when Core.getfield is (indirectly) called with a nonexisting and hardcoded field name. For example, if an object have a field called vec and you type it vector.","category":"page"},{"location":"jetanalysis/#Example-4","page":"Error Analysis","title":"Example","text":"","category":"section"},{"location":"jetanalysis/","page":"Error Analysis","title":"Error Analysis","text":"struct Foo\n    my_field\nend\nf(x) = x.my_feild; # NB: Typo!\n\nusing JET # hide\n@report_call f(Foo(1))","category":"page"},{"location":"jetanalysis/#How-to-fix-4","page":"Error Analysis","title":"How to fix","text":"","category":"section"},{"location":"jetanalysis/","page":"Error Analysis","title":"Error Analysis","text":"This error often occurs when the field name is mistyped. Correct the typo.","category":"page"},{"location":"jetanalysis/#BoundsError:-Attempt-to-access-T-at-index-[i]","page":"Error Analysis","title":"BoundsError: Attempt to access T at index [i]","text":"","category":"section"},{"location":"jetanalysis/#Description-5","page":"Error Analysis","title":"Description","text":"","category":"section"},{"location":"jetanalysis/","page":"Error Analysis","title":"Error Analysis","text":"This error occurs when it is known at compile time that the call will throw a BoundsError. Note that most BoundsErrors cannot be predicted at compile time. For the compiler to know a function attempts to access a container out of bounds, both the container length and the index value must be known at compiletime. Hence, the error is detected for a Tuple input in the example below, but not for a Vector input.","category":"page"},{"location":"jetanalysis/#Example-5","page":"Error Analysis","title":"Example","text":"","category":"section"},{"location":"jetanalysis/","page":"Error Analysis","title":"Error Analysis","text":"get_fourth(x) = x[4]\n\nusing JET # hide\n@report_call get_fourth((1,2,3))\n@report_call get_fourth([1,2,3]) # NB: False negative!","category":"page"},{"location":"jetanalysis/#How-to-fix-5","page":"Error Analysis","title":"How to fix","text":"","category":"section"},{"location":"jetanalysis/","page":"Error Analysis","title":"Error Analysis","text":"If this error appears, the offending code uses a bad index. Since the error most often occurs when the index is hardcoded, simply fix the index value.","category":"page"},{"location":"jetanalysis/#may-throw-[...]","page":"Error Analysis","title":"may throw [...]","text":"","category":"section"},{"location":"jetanalysis/#Description-6","page":"Error Analysis","title":"Description","text":"","category":"section"},{"location":"jetanalysis/","page":"Error Analysis","title":"Error Analysis","text":"This error indicates that JET detected the possibility of an exception. By default, JET will not report this error, unless a function is inferred to always throw, AND the exception is not caught in a try statement. In \"sound\" mode, this error is reported if the function may throw.","category":"page"},{"location":"jetanalysis/#Example-6","page":"Error Analysis","title":"Example","text":"","category":"section"},{"location":"jetanalysis/","page":"Error Analysis","title":"Error Analysis","text":"In this example, the function is known at compile time to throw an uncaught exception, and so is reported by default:","category":"page"},{"location":"jetanalysis/","page":"Error Analysis","title":"Error Analysis","text":"f(x) = x isa Integer ? throw(\"Integer\") : nothing;\n\nusing JET # hide\n@report_call f(1)","category":"page"},{"location":"jetanalysis/","page":"Error Analysis","title":"Error Analysis","text":"In this example, it's not known at compile time whether it throws, and therefore, JET reports no errors by default. In sound mode, the error is reported.","category":"page"},{"location":"jetanalysis/","page":"Error Analysis","title":"Error Analysis","text":"f(x) = x == 9873984732 ? nothing : throw(\"Bad value\")\n\nusing JET # hide\n@report_call f(1)\n@report_call mode=:sound f(1)","category":"page"},{"location":"jetanalysis/","page":"Error Analysis","title":"Error Analysis","text":"In this example, the exception is handled, so JET reports no errors by default. In sound mode, the error is reported:","category":"page"},{"location":"jetanalysis/","page":"Error Analysis","title":"Error Analysis","text":"g() = throw();\nf() = try\n    g()\ncatch\n    nothing\nend;\nf()\n\nusing JET # hide\n@report_call f()\n@report_call mode=:sound f()","category":"page"},{"location":"jetanalysis/#jetanalysis-entry","page":"Error Analysis","title":"Entry Points","text":"","category":"section"},{"location":"jetanalysis/#jetanalysis-interactive-entry","page":"Error Analysis","title":"Interactive Entry Points","text":"","category":"section"},{"location":"jetanalysis/","page":"Error Analysis","title":"Error Analysis","text":"JET offers interactive analysis entry points that can be used similarly to code_typed and its family:","category":"page"},{"location":"jetanalysis/#JET.@report_call","page":"Error Analysis","title":"JET.@report_call","text":"@report_call [jetconfigs...] f(args...)\n\nEvaluates the arguments to a function call, determines their types, and then calls report_call on the resulting expression. This macro works in a similar way as the @code_typed macro.\n\nThe general configurations and the error analysis specific configurations can be specified as an optional argument.\n\n\n\n\n\n","category":"macro"},{"location":"jetanalysis/#JET.report_call","page":"Error Analysis","title":"JET.report_call","text":"report_call(f, [types]; jetconfigs...) -> JETCallResult\nreport_call(tt::Type{<:Tuple}; jetconfigs...) -> JETCallResult\nreport_call(mi::Core.MethodInstance; jetconfigs...) -> JETCallResult\n\nAnalyzes a function call with the given type signature to find type-level errors and returns back detected problems.\n\nThe general configurations and the error analysis specific configurations can be specified as a keyword argument.\n\nSee the documentation of the error analysis for more details.\n\n\n\n\n\n","category":"function"},{"location":"jetanalysis/#jetanalysis-toplevel-entry","page":"Error Analysis","title":"Top-level Entry Points","text":"","category":"section"},{"location":"jetanalysis/","page":"Error Analysis","title":"Error Analysis","text":"JET can also analyze your \"top-level\" program: it can just take your Julia script or package and will report possible errors.","category":"page"},{"location":"jetanalysis/","page":"Error Analysis","title":"Error Analysis","text":"Note that JET will analyze your top-level program \"half-statically\": JET will selectively interpret and load \"definitions\" (like a function or struct definition) and try to simulate Julia's top-level code execution process. While it tries to avoid executing any other parts of code like function calls and analyzes them based on abstract interpretation instead (and this is a part where JET statically analyzes your code). If you're interested in how JET selects \"top-level definitions\", please see JET.virtual_process.","category":"page"},{"location":"jetanalysis/","page":"Error Analysis","title":"Error Analysis","text":"warning: Warning\nBecause JET will interpret \"definitions\" in your code, that part of top-level analysis certainly runs your code. So we should note that JET can cause some side effects from your code; for example, JET will try to expand all the macros used in your code, and so the side effects involved with macro expansions will also happen in JET's analysis process.","category":"page"},{"location":"jetanalysis/#JET.report_file","page":"Error Analysis","title":"JET.report_file","text":"report_file(file::AbstractString; jetconfigs...) -> JETToplevelResult\n\nAnalyzes file to find type-level errors and returns back detected problems.\n\nThis function looks for .JET.toml configuration file in the directory of file, and searches upward in the file tree until a .JET.toml is (or isn't) found. When found, the configurations specified in the file are applied. See JET's configuration file specification for more details.\n\nThe general configurations and the error analysis specific configurations can be specified as a keyword argument, and if given, they are preferred over the configurations specified by a .JET.toml configuration file.\n\ntip: Tip\nWhen you want to analyze your package but no files that actually use its functions are available, the analyze_from_definitions option may be useful since it allows JET to analyze methods based on their declared signatures. For example, JET can analyze JET itself in this way:# from the root directory of JET.jl\njulia> report_file(\"src/JET.jl\";\n                   analyze_from_definitions = true)See also report_package.\n\nnote: Note\nThis function enables the toplevel_logger configuration with the default logging level by default. You can still explicitly specify and configure it:report_file(args...;\n            toplevel_logger = nothing, # suppress the toplevel logger\n            jetconfigs...) # other configurationsSee JET's top-level analysis configurations for more details.\n\n\n\n\n\n","category":"function"},{"location":"jetanalysis/#JET.watch_file","page":"Error Analysis","title":"JET.watch_file","text":"watch_file(file::AbstractString; jetconfigs...)\n\nWatches file and keeps re-triggering analysis with report_file on code update. JET will try to analyze all the included files reachable from file, and it will re-trigger analysis if there is code update detected in any of the included files.\n\nThis entry point currently uses Revise.jl to monitor code updates, and can only be used after Revise has been loaded into the session. So note that you'll need to have run e.g., using Revise at some earlier stage to use it. Revise offers possibilities to track changes in files that are not directly analyzed by JET, including changes made to Base files using configurations like revise_modules = [Base]. See watch configurations for more details.\n\nwarning: Warning\nThis interface is very experimental and likely to subject to change or removal without notice.\n\nSee also report_file.\n\n\n\n\n\n","category":"function"},{"location":"jetanalysis/#JET.report_package","page":"Error Analysis","title":"JET.report_package","text":"report_package(package::Module; jetconfigs...) -> JETToplevelResult\nreport_package(package::AbstractString; jetconfigs...) -> JETToplevelResult\n\nAnalyzes package in the same way as report_file and returns back type-level errors with the special default configurations, which are especially tuned for analyzing a package (see below for details). The package argument can be either a Module or a AbstractString. In the latter case it must be the name of a package in your current environment.\n\nThe error analysis performed by this function is configured as follows by default:\n\nanalyze_from_definitions = true: This allows JET to start analysis without top-level call sites. This is useful for analyzing a package since a package itself usually only contains definitions of types and methods but not their usages (i.e. call sites).\nconcretization_patterns = [:(x_)]: Concretizes every top-level code in a given package. The concretizations are generally preferred for successful analysis as far as they can be performed cheaply. In most cases it is indeed cheap to interpret and concretize top-level code written in a package since it usually only defines types and methods.\nignore_missing_comparison = true: JET ignores the possibility of a poorly-inferred comparison operator call (e.g. ==) returning missing. This is useful because report_package often relies on poor input argument type information at the beginning of analysis, leading to noisy error reports from branching on the potential missing return value of such a comparison operator call. If a target package needs to handle missing, this  configuration shuold be turned off since it hides the possibility of errors that may actually at runtime.\n\nSee ToplevelConfig and JETAnalyzer for more details.\n\nStill the general configurations and the error analysis specific configurations can be specified as a keyword argument, and if given, they are preferred over the default configurations described above.\n\n\n\nreport_package(; jetconfigs...) -> JETToplevelResult\n\nLike above but analyzes the package of the current project.\n\nSee also report_file.\n\n\n\n\n\n","category":"function"},{"location":"jetanalysis/#JET.report_text","page":"Error Analysis","title":"JET.report_text","text":"report_text(text::AbstractString; jetconfigs...) -> JETToplevelResult\nreport_text(text::AbstractString, filename::AbstractString; jetconfigs...) -> JETToplevelResult\n\nAnalyzes top-level text and returns back type-level errors.\n\n\n\n\n\n","category":"function"},{"location":"jetanalysis/#jetanalysis-test-integration","page":"Error Analysis","title":"Test Integration","text":"","category":"section"},{"location":"jetanalysis/","page":"Error Analysis","title":"Error Analysis","text":"JET also exports entries that are fully integrated with Test standard library's unit-testing infrastructure. It can be used in your test suite to assert your program is free from errors that JET can detect:","category":"page"},{"location":"jetanalysis/#JET.@test_call","page":"Error Analysis","title":"JET.@test_call","text":"@test_call [jetconfigs...] [broken=false] [skip=false] f(args...)\n\nRuns @report_call jetconfigs... f(args...) and tests that the function call f(args...) is free from problems that @report_call can detect. Returns a Pass result if the test is successful, a Fail result if any problems are detected, or an Error result if the test encounters an unexpected error. When the test Fails, abstract call stack to each problem location will be printed to stdout.\n\njulia> @test_call sincos(10)\nTest Passed\n  Expression: #= none:1 =# JET.@test_call sincos(10)\n\nAs with @report_call, the general configurations and the error analysis specific configurations can be specified as an optional argument:\n\njulia> cond = false\n\njulia> function f(n)\n           # `cond` is untyped, and will be reported by the sound analysis pass,\n           # while JET's default analysis pass will ignore it\n           if cond\n               return sin(n)\n           else\n               return cos(n)\n           end\n       end;\n\njulia> @test_call f(10)\nTest Passed\n  Expression: #= none:1 =# JET.@test_call f(10)\n\njulia> @test_call mode=:sound f(10)\nJET-test failed at none:1\n  Expression: #= none:1 =# JET.@test_call mode = :sound f(10)\n  ═════ 1 possible error found ═════\n  ┌ @ none:2 goto %4 if not cond\n  │ non-boolean (Any) used in boolean context: goto %4 if not cond\n  └──────────\n\nERROR: There was an error during testing\n\n@test_call is fully integrated with Test standard library's unit-testing infrastructure. This means that the result of @test_call will be included in a final @testset summary and it supports skip and broken annotations, just like the @test macro:\n\njulia> using JET, Test\n\n# Julia can't propagate the type constraint `ref[]::Number` to `sin(ref[])`, JET will report `NoMethodError`\njulia> f(ref) = isa(ref[], Number) ? sin(ref[]) : nothing;\n\n# we can make it type-stable if we extract `ref[]` into a local variable `x`\njulia> g(ref) = (x = ref[]; isa(x, Number) ? sin(x) : nothing);\n\njulia> @testset \"check errors\" begin\n           ref = Ref{Union{Nothing,Int}}(0)\n           @test_call f(ref)             # fail\n           @test_call g(ref)             # fail\n           @test_call broken=true f(ref) # annotated as broken, thus still \"pass\"\n       end\ncheck errors: JET-test failed at REPL[21]:3\n  Expression: #= REPL[21]:3 =# JET.@test_call f(ref)\n  ═════ 1 possible error found ═════\n  ┌ f(ref::Base.RefValue{Union{Nothing, Int64}}) @ Main ./REPL[19]:1\n  │ no matching method found `sin(::Nothing)` (1/2 union split): sin((ref::Base.RefValue{Union{Nothing, Int64}})[]::Union{Nothing, Int64})\n  └────────────────────\n\nTest Summary: | Pass  Fail  Broken  Total  Time\ncheck errors  |    1     1       1      3  0.2s\nERROR: Some tests did not pass: 1 passed, 1 failed, 0 errored, 1 broken.\n\n\n\n\n\n","category":"macro"},{"location":"jetanalysis/#JET.test_call","page":"Error Analysis","title":"JET.test_call","text":"test_call(f, [types]; broken::Bool = false, skip::Bool = false, jetconfigs...)\ntest_call(tt::Type{<:Tuple}; broken::Bool = false, skip::Bool = false, jetconfigs...)\n\nRuns report_call on a function call with the given type signature and tests that it is free from problems that report_call can detect. Except that it takes a type signature rather than a call expression, this function works in the same way as @test_call.\n\n\n\n\n\n","category":"function"},{"location":"jetanalysis/#JET.test_file","page":"Error Analysis","title":"JET.test_file","text":"test_file(file::AbstractString; jetconfigs...)\n\nRuns report_file and tests that there are no problems detected.\n\nAs with report_file, the general configurations and the error analysis specific configurations can be specified as an optional argument.\n\nLike @test_call, test_file is fully integrated with the Test standard library. See @test_call for the details.\n\n\n\n\n\n","category":"function"},{"location":"jetanalysis/#JET.test_package","page":"Error Analysis","title":"JET.test_package","text":"test_package(package::Module; jetconfigs...)\ntest_package(package::AbstractString; jetconfigs...)\ntest_package(; jetconfigs...)\n\nRuns report_package and tests that there are no problems detected.\n\nAs with report_package, the general configurations and the error analysis specific configurations can be specified as an optional argument.\n\nLike @test_call, test_package is fully integrated with the Test standard library. See @test_call for the details.\n\njulia> @testset \"test_package\" begin\n           test_package(\"Example\"; toplevel_logger=nothing)\n       end;\nTest Summary: | Pass  Total  Time\ntest_package  |    1      1  0.0s\n\n\n\n\n\n","category":"function"},{"location":"jetanalysis/#JET.test_text","page":"Error Analysis","title":"JET.test_text","text":"test_text(text::AbstractString; jetconfigs...)\ntest_text(text::AbstractString, filename::AbstractString; jetconfigs...)\n\nRuns report_text and tests that there are no problems detected.\n\nAs with report_text, the general configurations and the error analysis specific configurations can be specified as an optional argument.\n\nLike @test_call, test_text is fully integrated with the Test standard library. See @test_call for the details.\n\n\n\n\n\n","category":"function"},{"location":"jetanalysis/#jetanalysis-config","page":"Error Analysis","title":"Configurations","text":"","category":"section"},{"location":"jetanalysis/","page":"Error Analysis","title":"Error Analysis","text":"In addition to the general configurations, the error analysis can take the following specific configurations:","category":"page"},{"location":"jetanalysis/#JET.JETAnalyzer","page":"Error Analysis","title":"JET.JETAnalyzer","text":"Every entry point of error analysis can accept any of the general configurations as well as the following additional configurations that are specific to the error analysis.\n\n\n\nmode::Symbol = :basic:\nSwitches the error analysis pass. Each analysis pass reports errors according to their own \"error\" definition. JET by default offers the following modes:\nmode = :basic: the default error analysis pass. This analysis pass is tuned to be useful for general Julia development by reporting common problems, but also note that it is not enough strict to guarantee that your program never throws runtime errors.\n\nmode = :sound: the sound error analysis pass. If this pass doesn't report any errors, then your program is assured to run without any runtime errors (unless JET's error definition is not accurate and/or there is an implementation flaw).\n\nmode = :typo: a typo detection pass A simple analysis pass to detect \"typo\"s in your program. This analysis pass is essentially a subset of the default basic pass, and it only reports undefined global reference and undefined field access. This might be useful especially for a very complex code base, because even the basic pass tends to be too noisy (spammed with too many errors) for such a case.\nnote: Note\nYou can also set up your own analysis using JET's AbstractAnalyzer-Framework.\n\n\n\nignore_missing_comparison::Bool = false:\nIf true, JET will ignores the possibility of a poorly-inferred comparison operator call (e.g. ==) returning missing in order to hide the error reports from branching on the potential missing return value of such a comparison operator call. This is turned off by default, because a comparison call results in a Union{Bool,Missing} possibility, it likely signifies an inferrability issue or the missing possibility should be handled someway. But this is useful to reduce the noisy error reports in the situations where specific input arguments type is not available at the beginning of the analysis like report_package.\n\n\n\n\n\n\n\n","category":"type"},{"location":"generated-plugin-examples/dispatch_analysis/#Dispatch-Analysis","page":"Dispatch Analysis","title":"Dispatch Analysis","text":"","category":"section"},{"location":"generated-plugin-examples/dispatch_analysis/#Motivation","page":"Dispatch Analysis","title":"Motivation","text":"","category":"section"},{"location":"generated-plugin-examples/dispatch_analysis/","page":"Dispatch Analysis","title":"Dispatch Analysis","text":"When Julia compiles your code and type inference on it was not so successful, the compiler is likely to be unable to determine which method should be called at each generic function callsite, and then it will be looked up at runtime. That is called \"runtime dispatch\", which is known as a common source of performance problem – the compiler can't do various kinds of optimizations including inlining when it can't determine a single matching method, and method lookup itself can also be a bottleneck if the call happens many times.","category":"page"},{"location":"generated-plugin-examples/dispatch_analysis/","page":"Dispatch Analysis","title":"Dispatch Analysis","text":"In order to avoid this problem, we usually use code_typed, inspect its output, and check if there is anywhere type is not well inferred (i.e. where is \"type-instable\") and optimization was not successful. But the problem is that code_typed can only present the \"final\" output of inference or optimization, and we can't inspect an entire call graph and may not be able to find where a problem happened and how the \"type instability\" has been propagated.","category":"page"},{"location":"generated-plugin-examples/dispatch_analysis/","page":"Dispatch Analysis","title":"Dispatch Analysis","text":"There is a nice package called Cthulhu.jl, which allows us to inspect the output of code_typed by descending into a call tree, recursively and interactively. The workflow with Cthulhu is much more powerful, but still, it's tedious.","category":"page"},{"location":"generated-plugin-examples/dispatch_analysis/","page":"Dispatch Analysis","title":"Dispatch Analysis","text":"So, why not automate it ? We can use JET's pluggable analysis framework and create such an analyzer that automatically analyzes your code and alarms you when it detects anywhere Julia can't determine matching method statically and thus runtime dispatch will happen at runtime.","category":"page"},{"location":"generated-plugin-examples/dispatch_analysis/#Implementation","page":"Dispatch Analysis","title":"Implementation","text":"","category":"section"},{"location":"generated-plugin-examples/dispatch_analysis/","page":"Dispatch Analysis","title":"Dispatch Analysis","text":"In this analysis, the analyzer will be designed to detect:","category":"page"},{"location":"generated-plugin-examples/dispatch_analysis/","page":"Dispatch Analysis","title":"Dispatch Analysis","text":"where Julia compiler gives up optimization\nwhere a runtime dispatch will happen","category":"page"},{"location":"generated-plugin-examples/dispatch_analysis/","page":"Dispatch Analysis","title":"Dispatch Analysis","text":"The case 1. will happen when there are (mutually) recursive calls and Julia compiler decided not to do inference in order to make sure the inference's termination. In such a case, optimization won't happen and method dispatches aren't resolved statically, so we will just report it (as OptimizationFailureReport). In order to detect the case 2., we will inspect the optimized IR and look for :call expressions. :call expressions are such calls that were not resolved statically and will be dispatched at runtime (as opposed to :invoke expressions, that represent staticall resolved generic function calls).","category":"page"},{"location":"generated-plugin-examples/dispatch_analysis/","page":"Dispatch Analysis","title":"Dispatch Analysis","text":"We will define DispatchAnalyzer <: AbstractAnalyzer, and overload some of Base.Compiler methods with it:","category":"page"},{"location":"generated-plugin-examples/dispatch_analysis/","page":"Dispatch Analysis","title":"Dispatch Analysis","text":"CC.finish(frame::CC.InferenceState, analyzer::DispatchAnalyzer) to check if optimization will happen or not (the case 1.)\nCC.finish!(analyzer::DispatchAnalyzer, caller::CC.InferenceResult) to inspect an optimized IR (the case 2.)","category":"page"},{"location":"generated-plugin-examples/dispatch_analysis/","page":"Dispatch Analysis","title":"Dispatch Analysis","text":"using JET.JETInterface\nusing JET: JET, CC\n\nstruct DispatchAnalyzer{T} <: AbstractAnalyzer\n    state::AnalyzerState\n    analysis_token::AnalysisToken\n    opts::BitVector\n    frame_filter::T # a predicate, which takes `CC.InfernceState` and returns whether we want to analyze the call or not\nend\n\n# AbstractAnalyzer API requirements\nJETInterface.AnalyzerState(analyzer::DispatchAnalyzer) = analyzer.state\nJETInterface.AbstractAnalyzer(analyzer::DispatchAnalyzer, state::AnalyzerState) = DispatchAnalyzer(state, analyzer.analysis_token, analyzer.opts, analyzer.frame_filter)\nJETInterface.AnalysisToken(analyzer::DispatchAnalyzer) = analyzer.analysis_token\n\nfunction CC.finish!(analyzer::DispatchAnalyzer, frame::CC.InferenceState, validation_world::UInt, time_before::UInt64)\n    caller = frame.result\n\n    # get the source before running `finish!` to keep the reference to `OptimizationState`\n    src = caller.src\n    if src isa CC.OptimizationState\n        # allow the following analysis passes to see the optimized `CodeInfo`\n        caller.src = CC.ir_to_codeinf!(src)\n        frame.edges = collect(Any, caller.src.edges)\n    end\n\n    if analyzer.frame_filter(frame.linfo)\n        if isa(src, Core.Const) # the optimization was very successful, nothing to report\n        elseif isnothing(src) # means, compiler decides not to do optimization\n            report_optimization_failure!(analyzer, caller, src)\n        elseif isa(src, CC.OptimizationState) # the compiler optimized it, analyze it\n            report_runtime_dispatch!(analyzer, caller, src)\n        else # and thus this pass should never happen\n            # as we should already report `OptimizationFailureReport` for this case\n            throw(\"got $src, unexpected source found\")\n        end\n    end\n\n    return @invoke CC.finish!(analyzer::AbstractAnalyzer, frame::CC.InferenceState, validation_world::UInt, time_before::UInt64)\nend\n\n@jetreport struct OptimizationFailureReport <: InferenceErrorReport end\nfunction JETInterface.print_report_message(io::IO, ::OptimizationFailureReport)\n    print(io, \"failed to optimize due to recursion\")\nend\nfunction report_optimization_failure!(analyzer::DispatchAnalyzer, result::CC.InferenceResult, src)\n    add_new_report!(analyzer, result, OptimizationFailureReport(result.linfo))\nend\n\n@jetreport struct RuntimeDispatchReport <: InferenceErrorReport end\nfunction JETInterface.print_report_message(io::IO, ::RuntimeDispatchReport)\n    print(io, \"runtime dispatch detected\")\nend\n\nfunction report_runtime_dispatch!(analyzer::DispatchAnalyzer, caller::CC.InferenceResult, opt::CC.OptimizationState)\n    (; sptypes, slottypes) = opt\n    for (pc, x) in enumerate(opt.src.code)\n        if Base.Meta.isexpr(x, :call)\n            ft = CC.widenconst(CC.argextype(first(x.args), opt.src, sptypes, slottypes))\n            ft <: Core.Builtin && continue # ignore `:call`s of the builtin intrinsics\n            add_new_report!(analyzer, caller, RuntimeDispatchReport((opt, pc)))\n        end\n    end\nend","category":"page"},{"location":"generated-plugin-examples/dispatch_analysis/#Usages","page":"Dispatch Analysis","title":"Usages","text":"","category":"section"},{"location":"generated-plugin-examples/dispatch_analysis/","page":"Dispatch Analysis","title":"Dispatch Analysis","text":"So we defined our analyzer. Let's set up utility analysis entries first:","category":"page"},{"location":"generated-plugin-examples/dispatch_analysis/","page":"Dispatch Analysis","title":"Dispatch Analysis","text":"using InteractiveUtils # to use `gen_call_with_extracted_types_and_kwargs`\n\nconst global_analysis_token = AnalysisToken()\n\n# the constructor for creating a new configured `DispatchAnalyzer` instance\nfunction DispatchAnalyzer(world::UInt = Base.get_world_counter();\n    analysis_token::AnalysisToken = global_analysis_token,\n    frame_filter = x::Core.MethodInstance->true,\n    jetconfigs...)\n    state = AnalyzerState(world; jetconfigs...)\n    # just for the sake of simplicity, create a fresh code cache for each `DispatchAnalyzer` instance (i.e. don't globalize the cache)\n    return DispatchAnalyzer(state, analysis_token, BitVector(), frame_filter)\nend\nfunction report_dispatch(args...; jetconfigs...)\n    @nospecialize args jetconfigs\n    analyzer = DispatchAnalyzer(; jetconfigs...)\n    return analyze_and_report_call!(analyzer, args...; jetconfigs...)\nend\nmacro report_dispatch(ex0...)\n    return InteractiveUtils.gen_call_with_extracted_types_and_kwargs(__module__, :report_dispatch, ex0)\nend","category":"page"},{"location":"generated-plugin-examples/dispatch_analysis/","page":"Dispatch Analysis","title":"Dispatch Analysis","text":"Now we can just call @report_dispatch f(args...) and check if there are any problematic part within the entire call tree of f(args...).","category":"page"},{"location":"generated-plugin-examples/dispatch_analysis/#Simple-cases","page":"Dispatch Analysis","title":"Simple cases","text":"","category":"section"},{"location":"generated-plugin-examples/dispatch_analysis/","page":"Dispatch Analysis","title":"Dispatch Analysis","text":"First, let's play with simple and factitious examples and check if DispatchAnalyzer works as expected.","category":"page"},{"location":"generated-plugin-examples/dispatch_analysis/","page":"Dispatch Analysis","title":"Dispatch Analysis","text":"getsomething(x::Any) = x\ngetsomething(x::Array) = x[]\ngetsomething(::Nothing) = throw(ArgumentError(\"nothing is nothing\"))\ngetsomething(::Missing) = throw(ArgumentError(\"too philosophical\"))","category":"page"},{"location":"generated-plugin-examples/dispatch_analysis/","page":"Dispatch Analysis","title":"Dispatch Analysis","text":"If callsite is type-stable (i.e. dispatched with concretely-typed arguments), any problem shouldn't be reported:","category":"page"},{"location":"generated-plugin-examples/dispatch_analysis/","page":"Dispatch Analysis","title":"Dispatch Analysis","text":"@report_dispatch getsomething(42) # should be ok","category":"page"},{"location":"generated-plugin-examples/dispatch_analysis/","page":"Dispatch Analysis","title":"Dispatch Analysis","text":"But if the argument isn't well-typed, compiler can't determine which method to call, and it will lead to runtime dispatch:","category":"page"},{"location":"generated-plugin-examples/dispatch_analysis/","page":"Dispatch Analysis","title":"Dispatch Analysis","text":"report_dispatch((Any,)) do a\n    getsomething(a) # runtime dispatch !\nend","category":"page"},{"location":"generated-plugin-examples/dispatch_analysis/","page":"Dispatch Analysis","title":"Dispatch Analysis","text":"Note that even if a call is not \"well-typed\" (i.e. it's not a concrete call), runtime dispatch won't happen as far as a single method can be resolved statically:","category":"page"},{"location":"generated-plugin-examples/dispatch_analysis/","page":"Dispatch Analysis","title":"Dispatch Analysis","text":"report_dispatch((AbstractString,)) do a\n    getsomething(a) # this call isn't very concrete, but ok, Julia can optimize it\nend","category":"page"},{"location":"generated-plugin-examples/dispatch_analysis/","page":"Dispatch Analysis","title":"Dispatch Analysis","text":"Ok, working nicely so far. Let's move on to a bit more complicated examples. When working on inherently-untyped code base where we somehow need to deal with arbitrarily-typed objects at runtime (as like Julia's high-level compiler), the @nospecialize annotation can be very useful – it helps us avoids excessive code specialization by suppressing runtime dispatches with runtime object types. For example, let's assume we have a vector of arbitrary untyped objects used within an user-program and need to check if its element is Type-like object with the following logic:","category":"page"},{"location":"generated-plugin-examples/dispatch_analysis/","page":"Dispatch Analysis","title":"Dispatch Analysis","text":"function isTypelike(x)\n    if isa(x, DataType)\n        return isa(x, DataType) && x.name === Type.body.name\n    elseif isa(x, Union)\n        return isTypelike(x.a) && isTypelike(x.b)\n    elseif isa(x, UnionAll)\n        return isTypelike(x.body)\n    else\n        return false\n    end\nend","category":"page"},{"location":"generated-plugin-examples/dispatch_analysis/","page":"Dispatch Analysis","title":"Dispatch Analysis","text":"But without @nospecialize, we gonna see runtime dispatches at the recursive call sites as they will be specialized at runtime. In this setup, we can suppress the runtime dipsatches and achieve a best performance by applying @nospecialize annotation to the argument x:","category":"page"},{"location":"generated-plugin-examples/dispatch_analysis/","page":"Dispatch Analysis","title":"Dispatch Analysis","text":"function isTypelike′(@nospecialize x)\n    if isa(x, DataType)\n        return isa(x, DataType) && x.name === Type.body.name\n    elseif isa(x, Union)\n        return isTypelike′(x.a) && isTypelike′(x.b)\n    elseif isa(x, UnionAll)\n        return isTypelike′(x.body)\n    else\n        return false\n    end\nend","category":"page"},{"location":"generated-plugin-examples/dispatch_analysis/","page":"Dispatch Analysis","title":"Dispatch Analysis","text":"We can confirm the effect of @nospecialize with DispatchAnalyzer:","category":"page"},{"location":"generated-plugin-examples/dispatch_analysis/","page":"Dispatch Analysis","title":"Dispatch Analysis","text":"report_dispatch((Vector{Any},)) do xs\n    x  = xs[1]\n    r  = isTypelike(x)  # this call will be runtime-dispatched\n    r′ = isTypelike′(x) # this call will be statically resolved (not runtime-dispatched)\n    return r, r′\nend","category":"page"},{"location":"generated-plugin-examples/dispatch_analysis/","page":"Dispatch Analysis","title":"Dispatch Analysis","text":"We can assert this report by looking at the output of code_typed, where isTypelike(x) remains as :call expression (meaning it will be dispatched at runtime) while isTypelike′(x) has been statically resolved and even inlined:","category":"page"},{"location":"generated-plugin-examples/dispatch_analysis/","page":"Dispatch Analysis","title":"Dispatch Analysis","text":"code_typed((Vector{Any},)) do xs\n    x  = xs[1]\n    r  = isTypelike(x)  # this call will be runtime-dispatched\n    r′ = isTypelike′(x) # this call will be statically resolved (not runtime-dispatched)\n    return r, r′\nend","category":"page"},{"location":"generated-plugin-examples/dispatch_analysis/#Real-world-targets","page":"Dispatch Analysis","title":"Real-world targets","text":"","category":"section"},{"location":"generated-plugin-examples/dispatch_analysis/","page":"Dispatch Analysis","title":"Dispatch Analysis","text":"Let's run DispatchAnalyzer on real-world code and check how it works. Here we will test with Julia's Base module.","category":"page"},{"location":"generated-plugin-examples/dispatch_analysis/","page":"Dispatch Analysis","title":"Dispatch Analysis","text":"Random number generation might be one of the most important feature for numerical computations, and so Julia's rand function should run fast. Let's see if it is free from runtime-dispatch.","category":"page"},{"location":"generated-plugin-examples/dispatch_analysis/","page":"Dispatch Analysis","title":"Dispatch Analysis","text":"@report_dispatch rand(1:1000)","category":"page"},{"location":"generated-plugin-examples/dispatch_analysis/","page":"Dispatch Analysis","title":"Dispatch Analysis","text":"Oh no, runtime dispatch happens there even in Base. Well, actually, this specific dispatch is expected. Especially, https://github.com/JuliaLang/julia/pull/35982 implements an heuristic to intentionally disable inference (and so succeeding optimizations too) in order to ease the latency problem, a.k.a. \"first-time-to-plot\". The report trace certainly suggests a dispatch was detected where ArgumentError can be thrown. We can turn off the heuristic by turning off the unoptimize_throw_blocks::Bool configuration, and this time any runtime dispatch won't be reported:","category":"page"},{"location":"generated-plugin-examples/dispatch_analysis/","page":"Dispatch Analysis","title":"Dispatch Analysis","text":"@report_dispatch unoptimize_throw_blocks=false rand(1:1000) # nothing should be reported","category":"page"},{"location":"generated-plugin-examples/dispatch_analysis/","page":"Dispatch Analysis","title":"Dispatch Analysis","text":"Finally, let's see an example of very \"type-instable\" code maintained within Base. Typically, anything involving I/O is written in a very dynamic way for good reasons, and certainly, e.g. println(QuoteNode(nothing)) will yield bunch of runtime dispatches:","category":"page"},{"location":"generated-plugin-examples/dispatch_analysis/","page":"Dispatch Analysis","title":"Dispatch Analysis","text":"@report_dispatch println(QuoteNode(nothing))\n═════ 585 possible errors found ═════\n┌ @ coreio.jl:4 Base.println(Core.tuple(Core.typeassert(Base.stdout, Base.IO)), xs...)\n│┌ @ strings/io.jl:73 Base.print(Core.tuple(io), xs, Core.tuple(\"\\n\")...)\n││┌ @ strings/io.jl:43 Base.lock(io)\n│││┌ @ show.jl:334 Base.lock(Base.getproperty(io, :io))\n# so many reports follow ...","category":"page"},{"location":"generated-plugin-examples/dispatch_analysis/","page":"Dispatch Analysis","title":"Dispatch Analysis","text":"But what if your code contains a single println call, which you're absolutely okay with the type instabilities involved with it (e.g. it's only called once or only in debug mode, or such), but still you want to assert that any other part of code is type-stable and dispatch-free ?","category":"page"},{"location":"generated-plugin-examples/dispatch_analysis/","page":"Dispatch Analysis","title":"Dispatch Analysis","text":"# problem: when ∑1/n exceeds 30 ?\nfunction compute(x)\n    r = 1\n    s = 0.0\n    n = 1\n    @time while r < x\n        s += 1/n\n        if s ≥ r\n            println(\"round $r/$x has been finished\") # we're not interested type-instabilities within this call\n            r += 1\n        end\n        n += 1\n    end\n    return n, s\nend","category":"page"},{"location":"generated-plugin-examples/dispatch_analysis/","page":"Dispatch Analysis","title":"Dispatch Analysis","text":"DispatchAnalyzer's frame_filter option can be useful for this, by allowing us to specify where it should and shouldn't run analysis. For example, we can limit the scope of analysis to the current module like this:","category":"page"},{"location":"generated-plugin-examples/dispatch_analysis/","page":"Dispatch Analysis","title":"Dispatch Analysis","text":"function module_filter(m) # filter by module\n    return function (linfo::Core.MethodInstance)\n        def = linfo.def\n        isa(def, Method) ? def.module === m : def === m\n    end\nend\n\n# NOTE:\n# `compute(30)` will take more than hours in actual execution, according to https://twitter.com/genkuroki/status/1401332946707963909,\n# but `@report_dispatch` will just do abstract interpretation of the call, so will finish instantly\n@report_dispatch frame_filter=module_filter(@__MODULE__) compute(30)","category":"page"},{"location":"generated-plugin-examples/dispatch_analysis/","page":"Dispatch Analysis","title":"Dispatch Analysis","text":"","category":"page"},{"location":"generated-plugin-examples/dispatch_analysis/","page":"Dispatch Analysis","title":"Dispatch Analysis","text":"This page was generated using Literate.jl.","category":"page"},{"location":"#JET.jl","page":"README","title":"JET.jl","text":"","category":"section"},{"location":"","page":"README","title":"README","text":"(Image: ) (Image: ) (Image: ) (Image: )","category":"page"},{"location":"","page":"README","title":"README","text":"JET employs Julia's type inference system to detect potential bugs and type instabilities.","category":"page"},{"location":"","page":"README","title":"README","text":"[!INFO]\n**The current latest version, v0.10 series, is only compatible with [Julia v1.12](https://julialang.org/downloads/#current_stable_release) only**\n\nThe JET version that works with v1.11 is the [v0.9 series](https://github.com/aviatesk/JET.jl/tree/release-0.9),\nbut please note that bug fixes and new features added in the v0.10 series may not necessarily be available.","category":"page"},{"location":"","page":"README","title":"README","text":"warning: Warning\nPlease note that due to JET's tight integration with the Julia compiler, the results presented by JET can vary significantly depending on the version of Julia you are using. Additionally, the implementation of the Base module and standard libraries bundled with Julia can also affect the results.Moreover, the Julia compiler's plugin system is still unstable and its interface changes frequently, so each version of JET is compatible with only limited versions of Julia. The Julia package manager will automatically select and install the latest version of JET that is compatible with your Julia version. However, if you are using the nightly version of Julia, please note that a compatible version of JET may not have been released yet, and JET installed via the Julia package manager may not function properly.","category":"page"},{"location":"#Quickstart","page":"README","title":"Quickstart","text":"","category":"section"},{"location":"","page":"README","title":"README","text":"See more commands, options and explanations in the documentation.","category":"page"},{"location":"#Installation","page":"README","title":"Installation","text":"","category":"section"},{"location":"","page":"README","title":"README","text":"JET is a standard Julia package. So you can just install it via Julia's built-in package manager and use it just like any other package:","category":"page"},{"location":"","page":"README","title":"README","text":"julia> using Pkg; Pkg.add(\"JET\")\n[ some output elided ]\n\njulia> using JET","category":"page"},{"location":"","page":"README","title":"README","text":"warning: Warning\nThe package manager will install the latest version of JET available for your Julia version. However, depending on the versions of dependency packages already installed in your environment, a working version of JET may not be installed. This can particularly occur when the version of JuliaInterpreter.jl is incompatible with JET, since JuliaInterpreter is also a dependency of the very commonly used package Revise.jl In such cases, the most reliable way to install and use a working JET is to set up a temporary environment (e.g., Pkg.temp()) and use JET there.","category":"page"},{"location":"#Detect-type-instability-with-[@report_opt](@ref)","page":"README","title":"Detect type instability with @report_opt","text":"","category":"section"},{"location":"","page":"README","title":"README","text":"Type instabilities can be detected in function calls using the @report_opt macro, which works similar to the @code_warntype macro. Note that, because JET relies on Julia's type inference, if a chain of inference is broken due to dynamic dispatch, then all downstream function calls will be unknown to the compiler, and so JET cannot analyze them.","category":"page"},{"location":"","page":"README","title":"README","text":"@report_opt foldl(+, Any[]; init=0)","category":"page"},{"location":"#Detect-type-errors-with-[@report_call](@ref)","page":"README","title":"Detect type errors with @report_call","text":"","category":"section"},{"location":"","page":"README","title":"README","text":"This works best on type stable code, so use @report_opt liberally before using @report_call.","category":"page"},{"location":"","page":"README","title":"README","text":"@report_call foldl(+, Char[])","category":"page"},{"location":"#Analyze-packages-with-[report_package](@ref)","page":"README","title":"Analyze packages with report_package","text":"","category":"section"},{"location":"","page":"README","title":"README","text":"This looks for all method definitions and analyses function calls based on their signatures. Note that this is less accurate than @report_call, because the actual input types cannot be known for generic methods.","category":"page"},{"location":"","page":"README","title":"README","text":"using Pkg; Pkg.activate(; temp=true, io=devnull); Pkg.add(\"AbstractTrees\"; io=devnull);\nPkg.status()\nreport_package(\"AbstractTrees\"; toplevel_logger=nothing)","category":"page"},{"location":"#Limitations","page":"README","title":"Limitations","text":"","category":"section"},{"location":"","page":"README","title":"README","text":"JET explores the functions you call directly as well as their inferable callees. However, if the argument types for a call cannot be inferred, JET does not analyze the callee. Consequently, a report of No errors detected does not imply that your entire codebase is free of errors. To increase the confidence in JET's results use @report_opt to make sure your code is inferrible.","category":"page"},{"location":"","page":"README","title":"README","text":"JET integrates with SnoopCompile, and you can sometimes use SnoopCompile to collect the data to perform more comprehensive analyses. SnoopCompile's limitation is that it only collects data for calls that have not been previously inferred, so you must perform this type of analysis in a fresh session.","category":"page"},{"location":"","page":"README","title":"README","text":"See SnoopCompile's JET-integration documentation for further details.","category":"page"},{"location":"#Acknowledgement","page":"README","title":"Acknowledgement","text":"","category":"section"},{"location":"","page":"README","title":"README","text":"This project started as my undergrad thesis project at Kyoto University, supervised by Prof. Takashi Sakuragawa. We were heavily inspired by ruby/typeprof, an experimental type understanding/checking tool for Ruby. The grad thesis about this project is published at https://github.com/aviatesk/grad-thesis, but currently, it's only available in Japanese.","category":"page"},{"location":"internals/#Internals-of-JET.jl","page":"Internals","title":"Internals of JET.jl","text":"","category":"section"},{"location":"internals/#abstractinterpret","page":"Internals","title":"Abstract Interpretation","text":"","category":"section"},{"location":"internals/","page":"Internals","title":"Internals","text":"In order to perform type-level program analysis, JET.jl uses Base.Compiler.AbstractInterpreter interface, and customizes its abstract interpretation by overloading a subset of Base.Compiler functions, that are originally developed for Julia compiler's type inference and optimizations that aim at generating efficient native code for CPU execution.","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"JET.AbstractAnalyzer overloads a set of Base.Compiler functions to implement the \"core\" functionalities of JET's analysis, including inter-procedural error report propagation and caching of the analysis result. And each plugin analyzer (e.g. JET.JETAnalyzer) will overload more Base.Compiler functions so that it can perform its own program analysis on top of the core AbstractAnalyzer infrastructure.","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"Most overloads use the invoke reflection, which allows AbstractAnalyzer to dispatch to the original AbstractInterpreter's abstract interpretation methods while still passing AbstractAnalyzer to the subsequent (maybe overloaded) callees.","category":"page"},{"location":"internals/#How-AbstractAnalyzer-manages-caches","page":"Internals","title":"How AbstractAnalyzer manages caches","text":"","category":"section"},{"location":"internals/#JET.AnalysisResult","page":"Internals","title":"JET.AnalysisResult","text":"AnalysisResult\n\nContainer for error reports collected during analysis of a specific InferenceResult.\n\nAbstractAnalyzer manages InferenceErrorReport instances by associating them with their corresponding InferenceResult. Reports found during the analysis of result::InferenceResult can be accessed via get_reports(analyzer, result).\n\n\n\n\n\n","category":"type"},{"location":"internals/#JET.CachedAnalysisResult","page":"Internals","title":"JET.CachedAnalysisResult","text":"CachedAnalysisResult\n\nCached version of AnalysisResult stored in the global analyzer cache.\n\nWhen an AnalysisResult is cached into the global cache maintained by AbstractAnalyzer, it's transformed into this type. That is, when codeinf::CodeInstance = Compiler.code_cache(analyzer::AbstractAnalyzer)[mi::MethodInstance], the codeinf.inferred field will contain a CachedAnalysisResult instance.\n\n\n\n\n\n","category":"type"},{"location":"internals/#JET.AnalysisToken","page":"Internals","title":"JET.AnalysisToken","text":"mutable struct AnalysisToken\n    AnalysisToken() = new()\nend\n\nA unique token object used to identify and separate caches of analysis results.\n\nEach AbstractAnalyzer implementation should use a consistent token to enable proper caching behavior. The identity of the token determines whether cached analysis results can be reused between analyzer instances.\n\n\n\n\n\n","category":"type"},{"location":"internals/#toplevel","page":"Internals","title":"Top-level Analysis","text":"","category":"section"},{"location":"internals/#JET.virtual_process","page":"Internals","title":"JET.virtual_process","text":"virtual_process(interp::ConcreteInterpreter,\n                x::Union{AbstractString,JS.SyntaxNode},\n                filename::AbstractString,\n                config::ToplevelConfig;\n                overrideex::Union{Nothing,Expr}=nothing) -> res::VirtualProcessResult\n\nSimulates Julia's toplevel execution and collects error points, and finally returns VirtualProcessResult.\n\nThis function first parses s::AbstractString into toplevelnode::JS.SyntaxNode and then iterate the following steps on each code block (blk) of toplevelnode:\n\nif blk is a :module expression, recursively enters analysis into an newly defined virtual module\nlowers blk into :thunk expression lwr (macros are also expanded in this step)\nif the context module is virtualized, replaces self-references of the original context module with virtualized one: see fix_self_references\nConcreteInterpreter partially interprets some statements in lwr that should not be abstracted away (e.g. a :method definition); see also partially_interpret!\nfinally, ToplevelAbstractAnalyzer analyzes the remaining statements by abstract interpretation\n\nwarning: Warning\nIn order to process the toplevel code sequentially as Julia runtime does, virtual_process splits the entire code, and then iterate a simulation process on each code block. With this approach, we can't track the inter-code-block level dependencies, and so a partial interpretation of toplevle definitions will fail if it needs an access to global variables defined in other code blocks that are not interpreted but just abstracted. We can circumvent this issue using JET's concretization_patterns configuration, which allows us to customize JET's concretization strategy. See ToplevelConfig for more details.\n\n\n\n\n\n","category":"function"},{"location":"internals/#JET.VirtualProcessResult","page":"Internals","title":"JET.VirtualProcessResult","text":"res::VirtualProcessResult\n\nres.analyzed_files::Dict{String,AnalyzedFileInfo}: files that have been analyzed with   their corresponding module analyzed_files attached.\nres.toplevel_error_reports::Vector{ToplevelErrorReport}: toplevel errors found during the   text parsing or partial (actual) interpretation; these reports are \"critical\" and should   have precedence over inference_error_reports\nres.inference_error_reports::Vector{InferenceErrorReport}: possible error reports found   by ToplevelAbstractAnalyzer\nres.toplevel_signatures: signatures of methods defined within the analyzed files\nres.actual2virtual::Pair{Module, Module}: keeps actual and virtual module\n\n\n\n\n\n","category":"type"},{"location":"internals/#JET.virtualize_module_context","page":"Internals","title":"JET.virtualize_module_context","text":"virtualize_module_context(actual::Module)\n\nHACK to return a module where the context of actual is virtualized.\n\nThe virtualization will be done by 2 steps below:\n\nloads the module context of actual into a sandbox module, and export the whole context from there\nthen uses names exported from the sandbox\n\nThis way, JET's runtime simulation in the virtual module context will be able to define a name that is already defined in actual without causing \"cannot assign a value to variable ... from module ...\" error, etc. It allows JET to virtualize the context of already-existing module other than Main.\n\nwarning: TODO\nCurrently this function relies on Base.names, and thus it can't restore the usinged names.\n\n\n\n\n\n","category":"function"},{"location":"internals/#JET.ConcreteInterpreter","page":"Internals","title":"JET.ConcreteInterpreter","text":"abstract type ConcreteInterpreter <: JuliaInterpreter.Interpreter end\n\nAn interface to inject code into JET's virtual process via JuliaInterpreter's interpretation.\n\nSubtypes are expected to implement:\n\nInterpretationState(interp::T) -> InterpretationState - return the interpreter state\nConcreteInterpreter(interp::T, state::InterpretationState) -> T - create new interpreter with state\nToplevelAbstractAnalyzer(interp::T) -> analyzer::ToplevelAbstractAnalyzer - return the analyzer for this interpreter\n\n\n\n\n\n","category":"type"},{"location":"internals/#JET.partially_interpret!","page":"Internals","title":"JET.partially_interpret!","text":"partially_interpret!(interp::ConcreteInterpreter, concretize::BitVector, mod::Module, src::CodeInfo)\n\nPartially interprets statements in src using JuliaInterpreter.jl:\n\nconcretizes \"toplevel definitions\", i.e. :method, :struct_type, :abstract_type and :primitive_type expressions and their dependencies\nconcretizes user-specified toplevel code (see ToplevelConfig)\ndirectly evaluates module usage expressions and report error of invalid module usages (TODO: enter into the loaded module and keep JET analysis)\nspecial-cases include calls so that top-level analysis recursively enters the included file\n\n\n\n\n\n","category":"function"},{"location":"internals/#analysis-result","page":"Internals","title":"Analysis Result","text":"","category":"section"},{"location":"internals/#JET.JETToplevelResult","page":"Internals","title":"JET.JETToplevelResult","text":"res::JETToplevelResult\n\nRepresents the result of JET's analysis on a top-level script.\n\nres.analyzer::AbstractAnalyzer: AbstractAnalyzer used for this analysis\nres.res::VirtualProcessResult: VirtualProcessResult collected from this analysis\nres.source::AbstractString: the identity key of this analysis\nres.jetconfigs: configurations used for this analysis\n\nJETToplevelResult implements show methods for each different frontend. An appropriate show method will be automatically chosen and render the analysis result.\n\n\n\n\n\n","category":"type"},{"location":"internals/#JET.JETCallResult","page":"Internals","title":"JET.JETCallResult","text":"res::JETCallResult\n\nRepresents the result of JET's analysis on a function call.\n\nres.result::InferenceResult: the result of this analysis\nres.analyzer::AbstractAnalyzer: AbstractAnalyzer used for this analysis\nres.source::AbstractString: the identity key of this analysis\nres.jetconfigs: configurations used for this analysis\n\nJETCallResult implements show methods for each different frontend. An appropriate show method will be automatically chosen and render the analysis result.\n\n\n\n\n\n","category":"type"},{"location":"internals/#optanalysis-splitting","page":"Internals","title":"Splitting and filtering reports","text":"","category":"section"},{"location":"internals/","page":"Internals","title":"Internals","text":"Both JETToplevelResult and JETCallResult can be split into individual failures for integration with tools like Cthulhu:","category":"page"},{"location":"internals/#JET.get_reports","page":"Internals","title":"JET.get_reports","text":"rpts = JET.get_reports(result::JETCallResult)\n\nSplit result into a vector of reports, one per issue.\n\n\n\n\n\n","category":"function"},{"location":"internals/#JET.reportkey","page":"Internals","title":"JET.reportkey","text":"reportkey(report::InferenceErrorReport)\n\nReturns an identifier for the runtime-dispatched call site of report.\n\nIf you have a long list of reports to analyze, urpts = unique(reportkey, rpts) may remove \"duplicates\" that arrive at the same runtime dispatch from different entry points.\n\n\n\n\n\n","category":"function"},{"location":"internals/#Error-Report-Interface","page":"Internals","title":"Error Report Interface","text":"","category":"section"},{"location":"internals/#JET.VirtualFrame","page":"Internals","title":"JET.VirtualFrame","text":"VirtualFrame\n\nStack information representing virtual execution context:\n\nfile::Symbol: the path to the file containing the virtual execution context\nline::Int: the line number in the file containing the virtual execution context\nsig::Signature: a signature of this frame\nlinfo::MethodInstance: The MethodInstance containing the execution context\n\nThis type is very similar to Base.StackTraces.StackFrame, but its execution context is collected during abstract interpration, not collected from actual execution.\n\n\n\n\n\n","category":"type"},{"location":"internals/#JET.VirtualStackTrace","page":"Internals","title":"JET.VirtualStackTrace","text":"VirtualStackTrace\n\nRepresents a virtual stack trace in the form of a vector of VirtualFrame. The vector holds VirtualFrames in order of \"from entry call site to error point\", i.e. the first element is the VirtualFrame of the entry call site, and the last element is that contains the error.\n\n\n\n\n\n","category":"type"},{"location":"internals/#JET.Signature","page":"Internals","title":"JET.Signature","text":"Signature\n\nRepresents an expression signature. print_signature implements a frontend functionality to show this type.\n\n\n\n\n\n","category":"type"},{"location":"internals/#JET.InferenceErrorReport","page":"Internals","title":"JET.InferenceErrorReport","text":"abstract type InferenceErrorReport end\n\nAn interface type of error reports collected by JET's abstract interpretation based analysis. All InferenceErrorReports have the following fields, which explains where and how this error is reported:\n\nvst::VirtualStackTrace: a virtual stack trace of the error\nsig::Signature: a signature of the error point\n\nNote that some InferenceErrorReport may have additional fields other than vst and sig to explain why they are reported.\n\n\n\n\n\n","category":"type"},{"location":"internals/#JET.ToplevelErrorReport","page":"Internals","title":"JET.ToplevelErrorReport","text":"ToplevelErrorReport\n\nAn interface type of error reports that JET collects while top-level concrete interpration. All ToplevelErrorReport should have the following fields:\n\nfile::String: the path to the file containing the interpretation context\nline::Int: the line number in the file containing the interpretation context\n\nSee also: virtual_process, ConcreteInterpreter\n\n\n\n\n\n","category":"type"},{"location":"config/#general-configurations","page":"Configurations","title":"General Configurations","text":"","category":"section"},{"location":"config/","page":"Configurations","title":"Configurations","text":"JET can be fine-tuned very flexibly. Any entry point explained in JET's default error analysis and the optimization analysis can accept any of the configuration parameters described below as keyword arguments (or optional parameters for the interactive macros). For example, you can analyze the call of sum(\"julia\") with the fullpath configuration enabled as like:","category":"page"},{"location":"config/","page":"Configurations","title":"Configurations","text":"@report_call fullpath=true sum(\"julia\")","category":"page"},{"location":"config/","page":"Configurations","title":"Configurations","text":"or equivalently:","category":"page"},{"location":"config/","page":"Configurations","title":"Configurations","text":"report_call(sum, (String,); fullpath=true)","category":"page"},{"location":"config/","page":"Configurations","title":"Configurations","text":"Similarly you can analyze a top-level script path/to/file.jl with specifying target_defined_modules configuration as follows:","category":"page"},{"location":"config/","page":"Configurations","title":"Configurations","text":"report_file(\"path/to/file.jl\";\n            target_defined_modules = true)","category":"page"},{"location":"config/","page":"Configurations","title":"Configurations","text":"note: Note\nPlease ignore the names of documented objects appearing below, like \"JET.configured_reports\". They are just remnants of documentation internals, and you will never directly interact with them.","category":"page"},{"location":"config/#result-config","page":"Configurations","title":"Configurations for Analysis Result","text":"","category":"section"},{"location":"config/#JET.configured_reports","page":"Configurations","title":"JET.configured_reports","text":"Configurations for JET's analysis results. These configurations are always active.\n\n\n\ntarget_modules = nothing \nA configuration to filter out reports by specifying module contexts where problems should be reported.\nBy default (target_modules = nothing), JET reports all detected problems. If specified, a problem is reported if its module context matches any of target_modules settings and hidden otherwise. target_modules should be an iterator of whose element is either of the data types below that match report::InferenceErrorReport's context module as follows:\nm::Module or JET.LastFrameModule(m::Module): matches if the module context of  report's innermost stack frame is m\nJET.AnyFrameModule(m::Module): matches if module context of any of report's stack frame is m\nuser-type T: matches according to user-definition overload match_module(::T, report::InferenceErrorReport)\n\n\n\nignored_modules = nothing \nA configuration to filter out reports by specifying module contexts where problems should be ignored.\nBy default (ignored_modules = nothing), JET reports all detected problems. If specified, a problem is hidden if its module context matches any of ignored_modules settings and reported otherwise. ignored_modules should be an iterator of whose element is either of the data types below that match report::InferenceErrorReport's context module as follows:\nm::Module or JET.LastFrameModule(m::Module): matches if the module context of  report's innermost stack frame is m\nJET.AnyFrameModule(m::Module): matches if module context of any of report's stack frame is m\nuser-type T: matches according to user-definition overload match_module(::T, report::InferenceErrorReport)\n\n\n\nreport_config = nothing \nAdditional configuration layer to filter out reports with user-specified strategies. By default (report_config = nothing), JET will use the module context based configurations elaborated above and below. If user-type T is given, then JET will report problems based on the logic according to an user-overload configured_reports(::T, reports::Vector{InferenceErrorReport}), and the target_modules and ignored_modules configurations are not really active.\n\n\n\nExamples\n\njulia> function foo(a)\n           r1 = sum(a)       # => Base: MethodError(+(::Char, ::Char)), MethodError(zero(::Type{Char}))\n           r2 = undefsum(a)  # => @__MODULE__: UndefVarError(:undefsum)\n           return r1, r2\n       end;\n\n# by default, JET will print all the collected reports:\njulia> @report_call foo(\"julia\")\n═════ 3 possible errors found ═════\n┌ foo(a::String) @ Main ./REPL[14]:2\n│┌ sum(a::String) @ Base ./reduce.jl:564\n││┌ sum(a::String; kw::@Kwargs{}) @ Base ./reduce.jl:564\n│││┌ sum(f::typeof(identity), a::String) @ Base ./reduce.jl:535\n││││┌ sum(f::typeof(identity), a::String; kw::@Kwargs{}) @ Base ./reduce.jl:535\n│││││┌ mapreduce(f::typeof(identity), op::typeof(Base.add_sum), itr::String) @ Base ./reduce.jl:307\n││││││┌ mapreduce(f::typeof(identity), op::typeof(Base.add_sum), itr::String; kw::@Kwargs{}) @ Base ./reduce.jl:307\n│││││││┌ mapfoldl(f::typeof(identity), op::typeof(Base.add_sum), itr::String) @ Base ./reduce.jl:175\n││││││││┌ mapfoldl(f::typeof(identity), op::typeof(Base.add_sum), itr::String; init::Base._InitialValue) @ Base ./reduce.jl:175\n│││││││││┌ mapfoldl_impl(f::typeof(identity), op::typeof(Base.add_sum), nt::Base._InitialValue, itr::String) @ Base ./reduce.jl:44\n││││││││││┌ foldl_impl(op::Base.BottomRF{typeof(Base.add_sum)}, nt::Base._InitialValue, itr::String) @ Base ./reduce.jl:48\n│││││││││││┌ _foldl_impl(op::Base.BottomRF{typeof(Base.add_sum)}, init::Base._InitialValue, itr::String) @ Base ./reduce.jl:62\n││││││││││││┌ (::Base.BottomRF{typeof(Base.add_sum)})(acc::Char, x::Char) @ Base ./reduce.jl:86\n│││││││││││││┌ add_sum(x::Char, y::Char) @ Base ./reduce.jl:24\n││││││││││││││ no matching method found `+(::Char, ::Char)`: (x::Char + y::Char)\n│││││││││││││└────────────────────\n││││││││││┌ foldl_impl(op::Base.BottomRF{typeof(Base.add_sum)}, nt::Base._InitialValue, itr::String) @ Base ./reduce.jl:49\n│││││││││││┌ reduce_empty_iter(op::Base.BottomRF{typeof(Base.add_sum)}, itr::String) @ Base ./reduce.jl:383\n││││││││││││┌ reduce_empty_iter(op::Base.BottomRF{typeof(Base.add_sum)}, itr::String, ::Base.HasEltype) @ Base ./reduce.jl:384\n│││││││││││││┌ reduce_empty(op::Base.BottomRF{typeof(Base.add_sum)}, ::Type{Char}) @ Base ./reduce.jl:360\n││││││││││││││┌ reduce_empty(::typeof(Base.add_sum), ::Type{Char}) @ Base ./reduce.jl:352\n│││││││││││││││┌ reduce_empty(::typeof(+), ::Type{Char}) @ Base ./reduce.jl:343\n││││││││││││││││ no matching method found `zero(::Type{Char})`: zero(T::Type{Char})\n│││││││││││││││└────────────────────\n┌ foo(a::String) @ Main ./REPL[14]:3\n│ `Main.undefsum` is not defined: r2 = undefsum(a::String)\n└────────────────────\n\n# with `target_modules=(@__MODULE__,)`, JET will only report the problems detected within the `@__MODULE__` module:\njulia> @report_call target_modules=(@__MODULE__,) foo(\"julia\")\n═════ 1 possible error found ═════\n┌ foo(a::String) @ Main ./REPL[14]:3\n│ `Main.undefsum` is not defined: r2 = undefsum(a::String)\n└────────────────────\n\n# with `ignored_modules=(Base,)`, JET will ignore the errors detected within the `Base` module:\njulia> @report_call ignored_modules=(Base,) foo(\"julia\")\n═════ 1 possible error found ═════\n┌ foo(a::String) @ Main ./REPL[14]:3\n│ `Main.undefsum` is not defined: r2 = undefsum(a::String)\n└────────────────────\n\n\n\n\n\n\n\n","category":"function"},{"location":"config/#toplevel-config","page":"Configurations","title":"Configurations for Top-level Analysis","text":"","category":"section"},{"location":"config/#JET.ToplevelConfig","page":"Configurations","title":"JET.ToplevelConfig","text":"Configurations for top-level analysis. These configurations will be active for all the top-level entries explained in the top-level analysis entry points section.\n\n\n\ncontext::Module = Main \nThe module context in which the top-level execution will be simulated.\nThis configuration can be useful when you just want to analyze a submodule, without starting entire analysis from the root module. For example, we can analyze Base.Math like below:\njulia> report_file(JET.fullbasepath(\"math.jl\");\n                   context = Base,                  # `Base.Math`'s root module\n                   analyze_from_definitions = true, # there're only definitions in `Base`\n                   )\nNote that this module context will be virtualized by default so that JET can repeat analysis in the same session without having \"invalid redefinition of constant ...\" error etc. In other word, JET virtualizes the module context of context and make sure the original module context isn't polluted by JET.\n\n\n\ntarget_defined_modules::Bool = false \nIf true, automatically set the target_modules configuration so that JET filters out errors that are reported within modules that JET doesn't analyze directly.\n\n\n\nanalyze_from_definitions::Union{Bool,Symbol} = false \nIf true, JET will start analysis using signatures of top-level definitions (e.g. method signatures), after the top-level interpretation has been done (unless no serious top-level error has happened, like errors involved within a macro expansion). This can be handy when you want to analyze a package, which usually contains only definitions but not their usages (i.e. top-level callsites). With this option, JET can enter analysis just with method or type definitions, and we don't need to pass a file that uses the target package.\nWhen analyze_from_definitions is specified as name::Symbol, JET starts its analysis using the interpreted method signature whose name is equal to name as the analysis entry point. For example, when analyzing a script that uses @main to specify the entry point, it would be convenient to specify analyze_from_definitions = :main.\nwarning: Warning\nThis feature is very experimental at this point, and you may face lots of false positive errors, especially when trying to analyze a big package with lots of dependencies. If a file that contains top-level callsites (e.g. test/runtests.jl) is available, JET analysis using the file is generally preferred, since analysis entered from concrete call sites will produce more accurate results than analysis entered from (maybe not concrete-typed) method signatures.\nAlso see: report_file, watch_file, report_package\n\n\n\nconcretization_patterns::Vector{Any} = Any[] \nSpecifies a customized top-level code concretization strategy.\nWhen analyzing a top-level code, JET first splits the entire code into appropriate units of code (i.e. \"code blocks\"), and then iterate a virtual top-level code execution process on each code block in order to simulate Julia's top-level code execution. In the virtual code execution, JET will selectively interpret \"top-level definitions\" (like a function definition), while it tries to avoid executing any other parts of code including function calls that typically do a main computational task, leaving them to be analyzed by the succeeding abstract interpretation based analysis.\nHowever, currently, JET doesn't track \"inter-block\" level code dependencies, and therefore the selective interpretation of top-level definitions may fail when it needs to use global bindings defined in the other code blocks that have not been selected and actually interpreted (i.e. \"concretized\") but left for abstract interpretation (i.e. \"abstracted\").\nFor example, the issue would happen if the expansion of a macro uses a global variable, e.g.:\ntest/fixtures/concretization_patterns.jl\n# JET doesn't conretize this by default, but just analyzes its type\nconst GLOBAL_CODE_STORE = Dict()\n\nmacro with_code_record(a)\n    GLOBAL_CODE_STORE[__source__] = a # record the code location in the global store\n    esc(a)\nend\n\n# here JET will try to actually expand `@with_code_record`,\n# but since `GLOBAL_CODE_STORE` didn't get concretized (i.e. instantiated), JET analysis will fail at this point\n@with_code_record foo(a) = identity(a)\n\nfoo(10) # top-level callsite, abstracted away\n\nTo circumvent this issue, JET offers this concretization_patterns::Vector{<:Any} configuration, which allows us to customize JET's top-level code concretization strategy. concretization_patterns specifies the patterns of code that should be concretized. To put in other word, when JET sees a code that matches any of code patterns specified by this configuration, JET will try to interpret and concretize the code, regardless of whether or not JET's default code selection logic decides to concretize it.\nJET uses MacroTools.jl's expression pattern match, and we can specify whatever code pattern expected by MacroTools.@capture macro. For example, in order to solve the issue explained above, we can have:\nconcretization_patterns = [:(const GLOBAL_CODE_STORE = Dict())]\nThen GLOBAL_CODE_STORE will just be concretized and so any top-level error won't happen at the macro expansion.\nSince configuring concretization_patterns properly can be tricky, JET offers a logging system that allows us to debug 's top-level code concretization plan. With the toplevel_logger configuration with specifying the logging level to be above than 1 (\"debug\") level, we can see:\nwhich code is matched with concretization_patterns and forcibly concretized\nwhich code is selected to be concretized by JET's default code selection logic: where t-annotated statements are concretized while f-annotated statements are abstracted\njulia> report_file(\"test/fixtures/concretization_patterns.jl\";\n                   concretization_patterns = [:(const GLOBAL_CODE_STORE = Dict())],\n                   toplevel_logger = IOContext(stdout, :JET_LOGGER_LEVEL => 1))\n[toplevel-debug] virtualized the context of Main (took 0.003 sec)\n[toplevel-debug] entered into test/fixtures/concretization_patterns.jl\n[toplevel-debug] concretization pattern `const GLOBAL_CODE_STORE = Dict()` matched `const GLOBAL_CODE_STORE = Dict()` at test/fixtures/concretization_patterns.jl:2\n[toplevel-debug] concretization plan at test/fixtures/concretization_patterns.jl:4:\n1 f 1 ─      $(Expr(:thunk, CodeInfo(\n    @ none within `top-level scope`\n1 ─     return $(Expr(:method, Symbol(\"@with_code_record\")))\n)))\n2 t │        $(Expr(:method, Symbol(\"@with_code_record\")))\n3 t │   %3 = Core.Typeof(var\"@with_code_record\")\n4 t │   %4 = Core.svec(%3, Core.LineNumberNode, Core.Module, Core.Any)\n5 t │   %5 = Core.svec()\n6 t │   %6 = Core.svec(%4, %5, $(QuoteNode(:(#= test/fixtures/concretization_patterns.jl:4 =#))))\n7 t │        $(Expr(:method, Symbol(\"@with_code_record\"), :(%6), CodeInfo(\n    @ test/fixtures/concretization_patterns.jl:5 within `none`\n1 ─      $(Expr(:meta, :nospecialize, :(a)))\n│        Base.setindex!(GLOBAL_CODE_STORE, a, __source__)\n│   @ test/fixtures/concretization_patterns.jl:6 within `none`\n│   %3 = esc(a)\n└──      return %3\n)))\n8 f └──      return var\"@with_code_record\"\n[toplevel-debug] concretization plan at test/fixtures/concretization_patterns.jl:11:\n1 f 1 ─      $(Expr(:thunk, CodeInfo(\n    @ none within `top-level scope`\n1 ─     return $(Expr(:method, :foo))\n)))\n2 t │        $(Expr(:method, :foo))\n3 t │   %3 = Core.Typeof(foo)\n4 t │   %4 = Core.svec(%3, Core.Any)\n5 t │   %5 = Core.svec()\n6 t │   %6 = Core.svec(%4, %5, $(QuoteNode(:(#= test/fixtures/concretization_patterns.jl:11 =#))))\n7 t │        $(Expr(:method, :foo, :(%6), CodeInfo(\n    @ test/fixtures/concretization_patterns.jl:11 within `none`\n1 ─ %1 = identity(a)\n└──      return %1\n)))\n8 f └──      return foo\n[toplevel-debug] concretization plan at test/fixtures/concretization_patterns.jl:13:\n1 f 1 ─ %1 = foo(10)\n2 f └──      return %1\n[toplevel-debug]  exited from test/fixtures/concretization_patterns.jl (took 0.032 sec)\nAlso see: the toplevel_logger section below, virtual_process.\nnote: Note\nreport_package automatically sets this configuration asconcretization_patterns = [:(x_)]meaning that it will concretize all top-level code included in a package being analyzed.\n\n\n\ntoplevel_logger::Union{Nothing,IO} = nothing \nIf IO object is given, it will track JET's toplevel analysis. Logging level can be specified with :JET_LOGGER_LEVEL IO property. Currently supported logging levels are either of 0 (\"info\" level, default), 1 (\"debug\" level).\nExamples:\nlogs into stdout\njulia> report_file(filename; toplevel_logger = stdout)\nlogs into io::IOBuffer with \"debug\" logger level\njulia> report_file(filename; toplevel_logger = IOContext(io, :JET_LOGGER_LEVEL => 1));\n\n\n\nvirtualize::Bool = true \nWhen true, JET will virtualize the given root module context.\nThis configuration is supposed to be used only for testing or debugging. See virtualize_module_context for the internal.\n\n\n\n\n\n\n\n","category":"type"},{"location":"config/#abstractinterpret-config","page":"Configurations","title":"Configurations for Abstract Interpretation","text":"","category":"section"},{"location":"config/#JET.JETInferenceParams","page":"Configurations","title":"JET.JETInferenceParams","text":"Configurations for abstract interpretation performed by JET. These configurations will be active for all the entries.\n\nYou can configure any of the keyword parameters that Compiler.InferenceParams or Compiler.OptimizationParams can take, e.g. max_methods:\n\njulia> methods(==, (Any,Nothing))\n# 3 methods for generic function \"==\" from Base:\n [1] ==(::Missing, ::Any)\n     @ missing.jl:75\n [2] ==(w::WeakRef, v)\n     @ gcutils.jl:4\n [3] ==(x, y)\n     @ Base.jl:127\n\njulia> report_call((Any,)) do x\n           # when we account for all the possible matching method candidates,\n           # `(::Missing == ::Nothing)::Missing` leads to an `NonBooleanCondErrorReport`\n           x == nothing ? :nothing : :some\n       end\n═════ 1 possible error found ═════\n┌ @ none:4 goto %4 if not x == nothing\n│ non-boolean `Missing` found in boolean context (1/2 union split): goto %4 if not (x::Any == nothing)::Union{Missing, Bool}\n└──────────\n\njulia> report_call((Any,); max_methods=1) do x\n           # since we limit `max_methods=1`, JET gives up analysis on `(x::Any == nothing)`\n           # and thus we won't get any error report\n           x == nothing ? :nothing : :some\n       end\nNo errors detected\n\nSee also Compiler.InferenceParams and Compiler.OptimizationParams.\n\nListed below are selections of those parameters that can have a potent influence on JET analysis.\n\n\n\nipo_constant_propagation::Bool = true \nEnables constant propagation in abstract interpretation. It is highly recommended that you keep this configuration true to get reasonable analysis result, because constant propagation can cut off lots of false positive errorenous code paths and thus produce more accurate and useful analysis results.\n\n\n\naggressive_constant_propagation::Bool = true \nIf true, JET will try to do constant propagation more \"aggressively\". It can lead to more accurate analysis as explained above, but also it may incur a performance cost. JET by default enables this configuration to get more accurate analysis result.\n\n\n\n\n\n\n\n","category":"function"},{"location":"config/#Compiler.InferenceParams","page":"Configurations","title":"Compiler.InferenceParams","text":"inf_params::InferenceParams\n\nParameters that control abstract interpretation-based type inference operation.\n\n\n\ninf_params.max_methods::Int = 3\nType inference gives up analysis on a call when there are more than max_methods matching methods. This trades off between compiler latency and generated code performance. Typically, considering many methods means spending lots of time obtaining poor type information, so this option should be kept low. Base.Experimental.@max_methods can have a more fine-grained control on this configuration with per-module or per-method annotation basis.\n\n\n\ninf_params.max_union_splitting::Int = 4\nSpecifies the maximum number of union-tuples to swap or expand before computing the set of matching methods or conditional types.\n\n\n\ninf_params.max_apply_union_enum::Int = 8\nSpecifies the maximum number of union-tuples to swap or expand when inferring a call to Core._apply_iterate.\n\n\n\ninf_params.max_tuple_splat::Int = 32\nWhen attempting to infer a call to Core._apply_iterate, abort the analysis if the tuple contains more than this many elements.\n\n\n\ninf_params.tuple_complexity_limit_depth::Int = 3\nSpecifies the maximum depth of large tuple type that can appear as specialized method signature when inferring a recursive call graph.\n\n\n\ninf_params.ipo_constant_propagation::Bool = true\nIf false, disables analysis with extended lattice information, i.e. disables any of the concrete evaluation, semi-concrete interpretation and constant propagation entirely. Base.@constprop :none can have a more fine-grained control on this configuration with per-method annotation basis.\n\n\n\ninf_params.aggressive_constant_propagation::Bool = false\nIf true, forces constant propagation on any methods when any extended lattice information available. Base.@constprop :aggressive can have a more fine-grained control on this configuration with per-method annotation basis.\n\n\n\ninf_params.assume_bindings_static::Bool = false\nIf true, assumes that no new bindings will be added, i.e. a non-existing binding at inference time can be assumed to always not exist at runtime (and thus e.g. any access to it will throw). Defaults to false since this assumption does not hold in Julia's semantics for native code execution.\n\n\n\ninf_params.force_enable_inference::Bool = false\nIf true, inference will be performed on functions regardless of whether it was disabled at the module level via Base.Experimental.@compiler_options.\n\n\n\n\n\n\n\n","category":"type"},{"location":"config/#Compiler.OptimizationParams","page":"Configurations","title":"Compiler.OptimizationParams","text":"opt_params::OptimizationParams\n\nParameters that control optimizer operation.\n\n\n\nopt_params.inlining::Bool = inlining_enabled()\nControls whether or not inlining is enabled.\n\n\n\nopt_params.inline_cost_threshold::Int = 100\nSpecifies the number of CPU cycles beyond which it's not worth inlining.\n\n\n\nopt_params.inline_nonleaf_penalty::Int = 1000\nSpecifies the penalty cost for a dynamic dispatch.\n\n\n\nopt_params.inline_tupleret_bonus::Int = 250\nSpecifies the extra inlining willingness for a method specialization with non-concrete tuple return types (in hopes of splitting it up). opt_params.inline_tupleret_bonus will be added to opt_params.inline_cost_threshold when making inlining decision.\n\n\n\nopt_params.max_tuple_splat::Int = 32\nWhen attempting to inline Core._apply_iterate, abort the optimization if the tuple contains more than this many elements.\n\n\n\nopt_params.compilesig_invokes::Bool = true\nIf true, gives the inliner license to change which MethodInstance to invoke when generating :invoke expression based on the @nospecialize annotation, in order to avoid over-specialization.\n\n\n\nopt_params.assume_fatal_throw::Bool = false\nIf true, gives the optimizer license to assume that any throw is fatal and thus the state after a throw is not externally observable. In particular, this gives the optimizer license to move side effects (that are proven not observed within a particular code path) across a throwing call. Defaults to false.\n\n\n\nopt_params.preserve_local_sources::Bool = false\nIf true, the inliner is restricted from modifying locally-cached sources that are retained in CallInfo objects and always makes their copies before inlining them into caller context. Defaults to false.\n\n\n\n\n\n\n\n","category":"type"},{"location":"config/#print-config","page":"Configurations","title":"Print Configurations","text":"","category":"section"},{"location":"config/#JET.PrintConfig","page":"Configurations","title":"JET.PrintConfig","text":"Configurations for report printing. The configurations below will be active whenever showing JET's analysis result within REPL.\n\n\n\nsourceinfo::Symbol = :default \nControls how file paths are displayed in stack traces and error reports.\n:full - Expand all file paths to absolute paths\n:default - Show paths as-is, prefixing ./ only for relative paths\n:compact - Show basename only for absolute paths, relative paths unchanged\n:minimal - Show only module information, omit file paths (no path:line)\n:none - Omit location information entirely (no @ Module path:line).  For toplevel errors, treated as :compact since location is essential.\n\n\n\nfullpath::Bool = false \nDeprecated: Use sourceinfo instead. fullpath=true is equivalent to sourceinfo=:full.\n\n\n\nprint_toplevel_success::Bool = false \nIf true, prints a message when there is no toplevel errors found.\n\n\n\nprint_inference_success::Bool = true \nIf true, print a message when there is no errors found in abstract interpretation based analysis pass.\n\n\n\nstacktrace_types_limit::Union{Nothing, Int} = nothing \nIf nothing, limit type-depth printing of argument types in stack traces based on the display size. If a positive Int, limit type-depth printing to given depth. If a non-positive Int, do not limit type-depth printing.\n\n\n\n\n\n\n\n","category":"type"},{"location":"config/#vscode-config","page":"Configurations","title":"Configurations for VSCode Integration","text":"","category":"section"},{"location":"config/#JET.VSCode.VSCodeConfig","page":"Configurations","title":"JET.VSCode.VSCodeConfig","text":"Configurations for the VSCode integration. These configurations are active only when used in the integrated Julia REPL.\n\n\n\nvscode_console_output::Union{Nothing,IO} = stdout \nJET will show analysis result in VSCode's \"PROBLEMS\" pane and inline annotations. If vscode_console_output::IO is specified, JET will also print the result into the specified output stream in addition to showing the result in the integrated views. When nothing, the result will be only shown in the integrated views.\n\n\n\n\n\n\n\n","category":"type"},{"location":"config/#watch-config","page":"Configurations","title":"Watch Configurations","text":"","category":"section"},{"location":"config/#JET.WatchConfig","page":"Configurations","title":"JET.WatchConfig","text":"Configurations for \"watch\" mode. The configurations will only be active when used with watch_file.\n\n\n\nrevise_all::Bool = true \nRedirected to Revise.entr's all keyword argument. When set to true, JET will retrigger analysis as soon as code updates are detected in any module tracked by Revise. Currently when encountering import/using statements, JET won't perform analysis, but rather will just load the modules as usual execution (this also means Revise will track those modules). So if you're editing both files analyzed by JET and modules that are used within the files, this configuration should be enabled.\n\n\n\nrevise_modules = nothing \nRedirected to Revise.entr's modules positional argument. If a iterator of Module is given, JET will retrigger analysis whenever code in modules updates.\ntip: Tip\nThis configuration is useful when your're also editing files that are not tracked by Revise, e.g. editing functions defined in Base:# re-perform analysis when you make a change to `Base`\njulia> watch_file(yourfile; revise_modules = [Base])\n\n\n\n\n\n\n\n","category":"type"},{"location":"config/#config-file","page":"Configurations","title":"Configuration File","text":"","category":"section"},{"location":"config/#JET.parse_config_file","page":"Configurations","title":"JET.parse_config_file","text":"JET.jl offers .prettierrc style configuration file support. This means you can use .JET.toml configuration file to specify any of configurations explained above and share that with others.\n\nWhen report_file or watch_file is called, it will look for .JET.toml in the directory of the given file, and search up the file tree until a JET configuration file is (or isn't) found. When found, the configurations specified in the file will be applied.\n\nA configuration file can specify configurations like:\n\naggressive_constant_propagation = false # turn off aggressive constant propagation\n... # other configurations\n\nNote that the following configurations should be string(s) of valid Julia code:\n\ncontext: string of Julia code, which can be parsed and evaluated into Module\nconcretization_patterns: vector of string of Julia code, which can be parsed into a Julia expression pattern expected by MacroTools.@capture macro.\ntoplevel_logger: string of Julia code, which can be parsed and evaluated into Union{IO,Nothing}\n\nE.g. the configurations below are equivalent:\n\nconfigurations via keyword arguments\nreport_file(somefile;\n            concretization_patterns = [:(const GLOBAL_CODE_STORE = x_)],\n            toplevel_logger = IOContext(open(\"toplevel.txt\", \"w\"), :JET_LOGGER_LEVEL => 1))\nconfigurations via a configuration file\n# supposed to concretize `const GLOBAL_CODE_STORE = Dict()` in test/fixtures/concretization_patterns.jl\nconcretization_patterns = [\"const GLOBAL_CODE_STORE = Dict()\"]\n\n# logs toplevel analysis into toplevel.txt with debug logging level\ntoplevel_logger = \"\"\"IOContext(open(\"toplevel.txt\", \"w\"), :JET_LOGGER_LEVEL => 1)\"\"\"\n\n\nnote: Note\nConfigurations specified as keyword arguments have precedence over those specified via a configuration file.\n\n\n\n\n\n","category":"function"}]
}
