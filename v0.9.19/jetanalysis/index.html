<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Error Analysis · JET.jl</title><meta name="title" content="Error Analysis · JET.jl"/><meta property="og:title" content="Error Analysis · JET.jl"/><meta property="twitter:title" content="Error Analysis · JET.jl"/><meta name="description" content="Documentation for JET.jl."/><meta property="og:description" content="Documentation for JET.jl."/><meta property="twitter:description" content="Documentation for JET.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">JET.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">README</a></li><li><a class="tocitem" href="../tutorial/">Tutorial</a></li><li><span class="tocitem">Analyses</span><ul><li class="is-active"><a class="tocitem" href>Error Analysis</a><ul class="internal"><li><a class="tocitem" href="#jetanalysis-quick-start"><span>Quick Start</span></a></li><li><a class="tocitem" href="#Errors-kinds-and-how-to-fix-them"><span>Errors kinds and how to fix them</span></a></li><li><a class="tocitem" href="#jetanalysis-entry"><span>Entry Points</span></a></li><li><a class="tocitem" href="#jetanalysis-config"><span>Configurations</span></a></li></ul></li><li><a class="tocitem" href="../optanalysis/">Optimization Analysis</a></li></ul></li><li><a class="tocitem" href="../config/">Configurations</a></li><li><a class="tocitem" href="../internals/">Internals</a></li><li><span class="tocitem"><code>AbstractAnalyzer</code> Framework</span><ul><li><a class="tocitem" href="../generated-plugin-api/">API</a></li><li><input class="collapse-toggle" id="menuitem-6-2" type="checkbox"/><label class="tocitem" for="menuitem-6-2"><span class="docs-label">Examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../generated-plugin-examples/dispatch_analysis/">Dispatch Analysis</a></li><li><a class="tocitem" href="../generated-plugin-examples/find_unstable_api/">&quot;Unstable API&quot; Analysis</a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Analyses</a></li><li class="is-active"><a href>Error Analysis</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Error Analysis</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/aviatesk/JET.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/aviatesk/JET.jl/blob/master/docs/src/jetanalysis.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="jetanalysis"><a class="docs-heading-anchor" href="#jetanalysis">Error Analysis</a><a id="jetanalysis-1"></a><a class="docs-heading-anchor-permalink" href="#jetanalysis" title="Permalink"></a></h1><p>Julia&#39;s type system is quite expressive and its type inference is strong enough to generate fairly optimized code from a highly generic program written in a concise syntax. But as opposed to other statically-compiled languages, Julia by design does <em>not</em> error nor warn anything even if it detects possible errors during its compilation process no matter how serious they are. In essence, Julia achieves highly generic and composable programming by delaying all the errors and warnings to the runtime.</p><p>This is a core design choice of the language. On the one hand, Julia&#39;s dynamism allows it to work in places where data types can not be fully decided ahead of runtime (e.g. when the program is duck-typed with generic pieces of code, or when the program consumes some data that is only known at runtime). On the other hand, with Julia, it&#39;s not straightforward to have such modern development experiences that a static language can typically offer, as like static type checking and rich IDE features.</p><p>JET is a trial to get the best of both worlds: can we have a sufficiently useful static checking without losing all the beauty of Julia&#39;s dynamism and composability? JET&#39;s approach is very different from <a href="https://en.wikipedia.org/wiki/Gradual_typing">&quot;gradual typing&quot;</a>, that is a common technique to bring static analysis into a dynamic language, as used for e.g. <a href="https://github.com/python/mypy">mypy</a> for Python and <a href="https://www.typescriptlang.org/">TypeScript</a> for JavaScript. Rather, JET&#39;s static analysis is powered by Julia&#39;s builtin type inference system, that is based on a technique called <a href="https://en.wikipedia.org/wiki/Abstract_interpretation">&quot;abstract interpretation&quot;</a>. This way JET can analyze just a normal Julia program and smartly detect possible errors statically, without requiring any additional setups like scattering type annotations just for the sake of analysis but preserving original polymorphism and composability of the program, as effectively as the Julia compiler can optimize your Julia program.</p><h2 id="jetanalysis-quick-start"><a class="docs-heading-anchor" href="#jetanalysis-quick-start">Quick Start</a><a id="jetanalysis-quick-start-1"></a><a class="docs-heading-anchor-permalink" href="#jetanalysis-quick-start" title="Permalink"></a></h2><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using JET</code><code class="nohighlight hljs ansi" style="display:block;"></code></pre><p>Let&#39;s start with the simplest example: how JET can find anything wrong with <code>sum(&quot;julia&quot;)</code>? <a href="#JET.@report_call"><code>@report_call</code></a> and <a href="#JET.report_call"><code>report_call</code></a> analyzes a given function call and report back possible problems. They can be used in a similar way as <a href="https://docs.julialang.org/en/v1/stdlib/InteractiveUtils/#InteractiveUtils.@code_typed"><code>@code_typed</code></a> and <a href="https://docs.julialang.org/en/v1/base/base/#Base.code_typed"><code>code_typed</code></a>. Those <a href="#jetanalysis-interactive-entry">interactive entry points</a> are the easiest way to use JET:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; @report_call sum(&quot;julia&quot;)</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr7">═════ 2 possible errors found ═════</span>
<span class="sgr35">┌ </span><span class="sgr1">sum(</span><span class="sgr90">a</span>::String<span class="sgr1">)</span> <span class="sgr35">@ Base ./reduce.jl:561</span>
<span class="sgr35">│</span><span class="sgr34">┌ </span><span class="sgr1">sum(</span><span class="sgr90">a</span>::String; <span class="sgr90">kw</span>::@Kwargs<span class="sgr90">{}</span><span class="sgr1">)</span> <span class="sgr34">@ Base ./reduce.jl:561</span>
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">┌ </span><span class="sgr1">sum(</span><span class="sgr90">f</span>::typeof(identity), <span class="sgr90">a</span>::String<span class="sgr1">)</span> <span class="sgr33">@ Base ./reduce.jl:532</span>
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">┌ </span><span class="sgr1">sum(</span><span class="sgr90">f</span>::typeof(identity), <span class="sgr90">a</span>::String; <span class="sgr90">kw</span>::@Kwargs<span class="sgr90">{}</span><span class="sgr1">)</span> <span class="sgr32">@ Base ./reduce.jl:532</span>
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">┌ </span><span class="sgr1">mapreduce(</span><span class="sgr90">f</span>::typeof(identity), <span class="sgr90">op</span>::typeof(Base.add_sum), <span class="sgr90">itr</span>::String<span class="sgr1">)</span> <span class="sgr35">@ Base ./reduce.jl:307</span>
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">┌ </span><span class="sgr1">mapreduce(</span><span class="sgr90">f</span>::typeof(identity), <span class="sgr90">op</span>::typeof(Base.add_sum), <span class="sgr90">itr</span>::String; <span class="sgr90">kw</span>::@Kwargs<span class="sgr90">{}</span><span class="sgr1">)</span> <span class="sgr34">@ Base ./reduce.jl:307</span>
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">┌ </span><span class="sgr1">mapfoldl(</span><span class="sgr90">f</span>::typeof(identity), <span class="sgr90">op</span>::typeof(Base.add_sum), <span class="sgr90">itr</span>::String<span class="sgr1">)</span> <span class="sgr33">@ Base ./reduce.jl:175</span>
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">┌ </span><span class="sgr1">mapfoldl(</span><span class="sgr90">f</span>::typeof(identity), <span class="sgr90">op</span>::typeof(Base.add_sum), <span class="sgr90">itr</span>::String; <span class="sgr90">init</span>::Base._InitialValue<span class="sgr1">)</span> <span class="sgr32">@ Base ./reduce.jl:175</span>
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">┌ </span><span class="sgr1">mapfoldl_impl(</span><span class="sgr90">f</span>::typeof(identity), <span class="sgr90">op</span>::typeof(Base.add_sum), <span class="sgr90">nt</span>::Base._InitialValue, <span class="sgr90">itr</span>::String<span class="sgr1">)</span> <span class="sgr35">@ Base ./reduce.jl:44</span>
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">┌ </span><span class="sgr1">foldl_impl(</span><span class="sgr90">op</span>::Base.BottomRF<span class="sgr90">{typeof(Base.add_sum)}</span>, <span class="sgr90">nt</span>::Base._InitialValue, <span class="sgr90">itr</span>::String<span class="sgr1">)</span> <span class="sgr34">@ Base ./reduce.jl:48</span>
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">┌ </span><span class="sgr1">_foldl_impl(</span><span class="sgr90">op</span>::Base.BottomRF<span class="sgr90">{typeof(Base.add_sum)}</span>, <span class="sgr90">init</span>::Base._InitialValue, <span class="sgr90">itr</span>::String<span class="sgr1">)</span> <span class="sgr33">@ Base ./reduce.jl:62</span>
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">┌ </span><span class="sgr1">(::Base.BottomRF{typeof(Base.add_sum)})(</span><span class="sgr90">acc</span>::Char, <span class="sgr90">x</span>::Char<span class="sgr1">)</span> <span class="sgr32">@ Base ./reduce.jl:86</span>
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr91">┌ </span><span class="sgr1">add_sum(</span><span class="sgr90">x</span>::Char, <span class="sgr90">y</span>::Char<span class="sgr1">)</span> <span class="sgr91">@ Base ./reduce.jl:24</span>
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr91">│ no matching method found `+(::Char, ::Char)`: </span><span class="sgr1">(x<span class="sgr96">::Char</span> + y<span class="sgr96">::Char</span>)</span>
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr91">└────────────────────</span>
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">┌ </span><span class="sgr1">foldl_impl(</span><span class="sgr90">op</span>::Base.BottomRF<span class="sgr90">{typeof(Base.add_sum)}</span>, <span class="sgr90">nt</span>::Base._InitialValue, <span class="sgr90">itr</span>::String<span class="sgr1">)</span> <span class="sgr34">@ Base ./reduce.jl:49</span>
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">┌ </span><span class="sgr1">reduce_empty_iter(</span><span class="sgr90">op</span>::Base.BottomRF<span class="sgr90">{typeof(Base.add_sum)}</span>, <span class="sgr90">itr</span>::String<span class="sgr1">)</span> <span class="sgr33">@ Base ./reduce.jl:380</span>
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">┌ </span><span class="sgr1">reduce_empty_iter(</span><span class="sgr90">op</span>::Base.BottomRF<span class="sgr90">{typeof(Base.add_sum)}</span>, <span class="sgr90">itr</span>::String, ::Base.HasEltype<span class="sgr1">)</span> <span class="sgr32">@ Base ./reduce.jl:381</span>
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">┌ </span><span class="sgr1">reduce_empty(</span><span class="sgr90">op</span>::Base.BottomRF<span class="sgr90">{typeof(Base.add_sum)}</span>, ::Type<span class="sgr90">{Char}</span><span class="sgr1">)</span> <span class="sgr35">@ Base ./reduce.jl:357</span>
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">┌ </span><span class="sgr1">reduce_empty(</span>::typeof(Base.add_sum), ::Type<span class="sgr90">{Char}</span><span class="sgr1">)</span> <span class="sgr34">@ Base ./reduce.jl:350</span>
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr91">┌ </span><span class="sgr1">reduce_empty(</span>::typeof(+), ::Type<span class="sgr90">{Char}</span><span class="sgr1">)</span> <span class="sgr91">@ Base ./reduce.jl:343</span>
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr91">│ no matching method found `zero(::Type{Char})`: </span><span class="sgr1">zero(T<span class="sgr96">::Type{Char}</span>)</span>
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr91">└────────────────────</span></code></pre><p>So JET found two possible problems. Now let&#39;s see how they can occur in <em>actual execution</em>:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; sum(&quot;julia&quot;) # will lead to `MethodError: +(::Char, ::Char)`</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: MethodError: no method matching +(::Char, ::Char)
The function `+` exists, but no method is defined for this combination of argument types.

Closest candidates are:
  +(::Any, ::Any, <span class="sgr91">::Any</span>, <span class="sgr91">::Any...</span>)
<span class="sgr90">   @</span> <span class="sgr90">Base</span> <span class="sgr90"><span class="sgr4">operators.jl:596</span></span>
  +(<span class="sgr91">::Integer</span>, ::AbstractChar)
<span class="sgr90">   @</span> <span class="sgr90">Base</span> <span class="sgr90"><span class="sgr4">char.jl:247</span></span>
  +(::T, <span class="sgr91">::Integer</span>) where T&lt;:AbstractChar
<span class="sgr90">   @</span> <span class="sgr90">Base</span> <span class="sgr90"><span class="sgr4">char.jl:237</span></span>
  ...</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; sum(&quot;&quot;) # will lead to `MethodError: zero(Type{Char})`</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: MethodError: no method matching zero(::Type{Char})
The function `zero` exists, but no method is defined for this combination of argument types.

Closest candidates are:
  zero(<span class="sgr91">::Type{Union{}}</span>, Any...)
<span class="sgr90">   @</span> <span class="sgr90">Base</span> <span class="sgr90"><span class="sgr4">number.jl:310</span></span>
  zero(<span class="sgr91">::Type{LibGit2.GitHash}</span>)
<span class="sgr90">   @</span> <span class="sgr33">LibGit2</span> <span class="sgr90">/opt/hostedtoolcache/julia/1.11.4/x64/share/julia/stdlib/v1.11/LibGit2/src/<span class="sgr4">oid.jl:221</span></span>
  zero(<span class="sgr91">::Type{Pkg.Resolve.VersionWeight}</span>)
<span class="sgr90">   @</span> <span class="sgr32">Pkg</span> <span class="sgr90">/opt/hostedtoolcache/julia/1.11.4/x64/share/julia/stdlib/v1.11/Pkg/src/Resolve/<span class="sgr4">versionweights.jl:15</span></span>
  ...</code></pre><p>We should note that <code>@report_call sum(&quot;julia&quot;)</code> could detect both of those two different errors that can happen at runtime. This is because <code>@report_call</code> does a static analysis — it analyzes the function call in a way that does not rely on one instance of runtime execution, but rather it reasons about all the possible executions! This is one of the biggest advantages of static analysis because other alternatives to check software qualities like &quot;testing&quot; usually rely on <em>some</em> runtime execution and they can only cover a subset of all the possible executions.</p><p>As mentioned above, JET is designed to work with <em>just a normal</em> Julia program. Let&#39;s define new arbitrary functions and run JET on it:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; function foo(s0)
           a = []
           for s in split(s0)
               push!(a, bar(s))
           end
           return sum(a)
       end</code><code class="nohighlight hljs ansi" style="display:block;">foo (generic function with 1 method)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; bar(s::String) = parse(Int, s)</code><code class="nohighlight hljs ansi" style="display:block;">bar (generic function with 1 method)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @report_call foo(&quot;1 2 3&quot;)</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr7">═════ 2 possible errors found ═════</span>
<span class="sgr91">┌ </span><span class="sgr1">foo(</span><span class="sgr90">s0</span>::String<span class="sgr1">)</span> <span class="sgr91">@ Main ./REPL[1]:4</span>
<span class="sgr91">│ no matching method found `bar(::SubString{String})`: </span><span class="sgr1">Main.bar(s)</span>
<span class="sgr91">└────────────────────</span>
<span class="sgr35">┌ </span><span class="sgr1">foo(</span><span class="sgr90">s0</span>::String<span class="sgr1">)</span> <span class="sgr35">@ Main ./REPL[1]:6</span>
<span class="sgr35">│</span><span class="sgr34">┌ </span><span class="sgr1">sum(</span><span class="sgr90">a</span>::Vector<span class="sgr90">{Any}</span><span class="sgr1">)</span> <span class="sgr34">@ Base ./reducedim.jl:982</span>
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">┌ </span><span class="sgr1">sum(</span><span class="sgr90">a</span>::Vector<span class="sgr90">{Any}</span>; <span class="sgr90">dims</span>::Colon, <span class="sgr90">kw</span>::@Kwargs<span class="sgr90">{}</span><span class="sgr1">)</span> <span class="sgr33">@ Base ./reducedim.jl:982</span>
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">┌ </span><span class="sgr1">_sum(</span><span class="sgr90">a</span>::Vector<span class="sgr90">{Any}</span>, ::Colon<span class="sgr1">)</span> <span class="sgr32">@ Base ./reducedim.jl:986</span>
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">┌ </span><span class="sgr1">_sum(</span><span class="sgr90">a</span>::Vector<span class="sgr90">{Any}</span>, ::Colon; <span class="sgr90">kw</span>::@Kwargs<span class="sgr90">{}</span><span class="sgr1">)</span> <span class="sgr35">@ Base ./reducedim.jl:986</span>
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">┌ </span><span class="sgr1">_sum(</span><span class="sgr90">f</span>::typeof(identity), <span class="sgr90">a</span>::Vector<span class="sgr90">{Any}</span>, ::Colon<span class="sgr1">)</span> <span class="sgr34">@ Base ./reducedim.jl:987</span>
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">┌ </span><span class="sgr1">_sum(</span><span class="sgr90">f</span>::typeof(identity), <span class="sgr90">a</span>::Vector<span class="sgr90">{Any}</span>, ::Colon; <span class="sgr90">kw</span>::@Kwargs<span class="sgr90">{}</span><span class="sgr1">)</span> <span class="sgr33">@ Base ./reducedim.jl:987</span>
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">┌ </span><span class="sgr1">mapreduce(</span><span class="sgr90">f</span>::typeof(identity), <span class="sgr90">op</span>::typeof(Base.add_sum), <span class="sgr90">A</span>::Vector<span class="sgr90">{Any}</span><span class="sgr1">)</span> <span class="sgr32">@ Base ./reducedim.jl:329</span>
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">┌ </span><span class="sgr1">mapreduce(</span><span class="sgr90">f</span>::typeof(identity), <span class="sgr90">op</span>::typeof(Base.add_sum), <span class="sgr90">A</span>::Vector<span class="sgr90">{Any}</span>; <span class="sgr90">dims</span>::Colon, <span class="sgr90">init</span>::Base._InitialValue<span class="sgr1">)</span> <span class="sgr35">@ Base ./reducedim.jl:329</span>
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">┌ </span><span class="sgr1">_mapreduce_dim(</span><span class="sgr90">f</span>::typeof(identity), <span class="sgr90">op</span>::typeof(Base.add_sum), ::Base._InitialValue, <span class="sgr90">A</span>::Vector<span class="sgr90">{Any}</span>, ::Colon<span class="sgr1">)</span> <span class="sgr34">@ Base ./reducedim.jl:337</span>
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">┌ </span><span class="sgr1">_mapreduce(</span><span class="sgr90">f</span>::typeof(identity), <span class="sgr90">op</span>::typeof(Base.add_sum), ::IndexLinear, <span class="sgr90">A</span>::Vector<span class="sgr90">{Any}</span><span class="sgr1">)</span> <span class="sgr33">@ Base ./reduce.jl:429</span>
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">┌ </span><span class="sgr1">mapreduce_empty_iter(</span><span class="sgr90">f</span>::typeof(identity), <span class="sgr90">op</span>::typeof(Base.add_sum), <span class="sgr90">itr</span>::Vector<span class="sgr90">{Any}</span>, <span class="sgr90">ItrEltype</span>::Base.HasEltype<span class="sgr1">)</span> <span class="sgr32">@ Base ./reduce.jl:377</span>
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">┌ </span><span class="sgr1">reduce_empty_iter(</span><span class="sgr90">op</span>::Base.MappingRF<span class="sgr90">{typeof(identity), typeof(Base.add_sum)}</span>, <span class="sgr90">itr</span>::Vector<span class="sgr90">{Any}</span>, ::Base.HasEltype<span class="sgr1">)</span> <span class="sgr35">@ Base ./reduce.jl:381</span>
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">┌ </span><span class="sgr1">reduce_empty(</span><span class="sgr90">op</span>::Base.MappingRF<span class="sgr90">{typeof(identity), typeof(Base.add_sum)}</span>, ::Type<span class="sgr90">{Any}</span><span class="sgr1">)</span> <span class="sgr34">@ Base ./reduce.jl:358</span>
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">┌ </span><span class="sgr1">mapreduce_empty(</span>::typeof(identity), <span class="sgr90">op</span>::typeof(Base.add_sum), <span class="sgr90">T</span>::Type<span class="sgr90">{Any}</span><span class="sgr1">)</span> <span class="sgr33">@ Base ./reduce.jl:369</span>
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">┌ </span><span class="sgr1">reduce_empty(</span>::typeof(Base.add_sum), ::Type<span class="sgr90">{Any}</span><span class="sgr1">)</span> <span class="sgr32">@ Base ./reduce.jl:350</span>
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">┌ </span><span class="sgr1">reduce_empty(</span>::typeof(+), ::Type<span class="sgr90">{Any}</span><span class="sgr1">)</span> <span class="sgr35">@ Base ./reduce.jl:343</span>
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr91">┌ </span><span class="sgr1">zero(</span>::Type<span class="sgr90">{Any}</span><span class="sgr1">)</span> <span class="sgr91">@ Base ./missing.jl:106</span>
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr91">│ MethodError: no method matching zero(::Type{Any}): </span><span class="sgr1">Base.throw(Base.MethodError(zero, tuple(Base.Any)<span class="sgr96">::Tuple{DataType}</span>)<span class="sgr96">::MethodError</span>)</span>
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr91">└────────────────────</span></code></pre><p>Now let&#39;s fix this problematic code. First, we can fix the definition of <code>bar</code> so that it accepts generic <code>AbstractString</code> input. JET&#39;s analysis result can be dynamically updated when we refine a function definition, and so we just need to add a new <code>bar(::AbstractString)</code> definition. As for the second error, let&#39;s assume, for some reason, we&#39;re not interested in fixing it and we want to ignore errors that may happen within <code>Base</code>. Then we can use the <a href="../config/#result-config"><code>target_modules</code></a> configuration to limit the analysis scope to the current module context to ignore the possible error that may happen within <code>sum(a)</code><sup class="footnote-reference"><a id="citeref-1" href="#footnote-1">[1]</a></sup>.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; # hot fix the definition of `bar`
       bar(s::AbstractString) = parse(Int, s)
       
       # now no errors should be reported !</code><code class="nohighlight hljs ansi" style="display:block;">bar (generic function with 2 methods)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @report_call target_modules=(@__MODULE__,) foo(&quot;1 2 3&quot;)</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr92">No errors detected</span></code></pre><p>So far, we have used the default error analysis pass, which collects problems according to one specific (somewhat opinionated) definition of &quot;errors&quot; (see the <a href="#JET.BasicPass"><code>JET.BasicPass</code></a> for more details). JET offers other error reporting passes, including the &quot;sound&quot; error detection (<a href="#JET.SoundPass"><code>JET.SoundPass</code></a>) as well as the simpler &quot;typo&quot; detection pass (<a href="#JET.TypoPass"><code>JET.TypoPass</code></a>)<sup class="footnote-reference"><a id="citeref-2" href="#footnote-2">[2]</a></sup>. They can be switched using the <code>mode</code> configuration:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; function myifelse(cond, a, b)
           if cond
               return a
           else
               return b
           end
       end
       
       # the default analysis pass doesn&#39;t report &quot;non-boolean (T) used in boolean context&quot; error
       # as far as there is a possibility when the condition &quot;can&quot; be bool (NOTE: Bool &lt;: Integer)</code><code class="nohighlight hljs ansi" style="display:block;">myifelse (generic function with 1 method)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; report_call(myifelse, (Integer, Int, Int))
       
       # the sound analyzer doesn&#39;t permit such a case: it requires the type of a conditional value to be `Bool` strictly</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr92">No errors detected</span></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; report_call(myifelse, (Integer, Int, Int); mode=:sound)</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr7">═════ 1 possible error found ═════</span>
<span class="sgr91">┌ </span><span class="sgr1">myifelse(</span><span class="sgr90">cond</span>::Integer, <span class="sgr90">a</span>::Int64, <span class="sgr90">b</span>::Int64<span class="sgr1">)</span> <span class="sgr91">@ Main ./REPL[1]:2</span>
<span class="sgr91">│ non-boolean `Integer` may be used in boolean context: </span><span class="sgr1">goto %4 if not cond<span class="sgr96">::Integer</span></span>
<span class="sgr91">└────────────────────</span></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; function strange_sum(a)
           if rand(Bool)
               undefsum(a)
           else
               sum(a)
           end
       end
       
       # the default analysis pass will report both problems:
       # - `undefsum` is not defined
       # - `sum(a::Vector{Any})` can throw when `a` is empty</code><code class="nohighlight hljs ansi" style="display:block;">strange_sum (generic function with 1 method)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @report_call strange_sum([])
       
       # the typo detection pass will only report the &quot;typo&quot;</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr7">═════ 2 possible errors found ═════</span>
<span class="sgr91">┌ </span><span class="sgr1">strange_sum(</span><span class="sgr90">a</span>::Vector<span class="sgr90">{Any}</span><span class="sgr1">)</span> <span class="sgr91">@ Main ./REPL[4]:3</span>
<span class="sgr91">│ `Main.undefsum` is not defined: </span><span class="sgr1">Main.undefsum</span>
<span class="sgr91">└────────────────────</span>
<span class="sgr35">┌ </span><span class="sgr1">strange_sum(</span><span class="sgr90">a</span>::Vector<span class="sgr90">{Any}</span><span class="sgr1">)</span> <span class="sgr35">@ Main ./REPL[4]:5</span>
<span class="sgr35">│</span><span class="sgr34">┌ </span><span class="sgr1">sum(</span><span class="sgr90">a</span>::Vector<span class="sgr90">{Any}</span><span class="sgr1">)</span> <span class="sgr34">@ Base ./reducedim.jl:982</span>
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">┌ </span><span class="sgr1">sum(</span><span class="sgr90">a</span>::Vector<span class="sgr90">{Any}</span>; <span class="sgr90">dims</span>::Colon, <span class="sgr90">kw</span>::@Kwargs<span class="sgr90">{}</span><span class="sgr1">)</span> <span class="sgr33">@ Base ./reducedim.jl:982</span>
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">┌ </span><span class="sgr1">_sum(</span><span class="sgr90">a</span>::Vector<span class="sgr90">{Any}</span>, ::Colon<span class="sgr1">)</span> <span class="sgr32">@ Base ./reducedim.jl:986</span>
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">┌ </span><span class="sgr1">_sum(</span><span class="sgr90">a</span>::Vector<span class="sgr90">{Any}</span>, ::Colon; <span class="sgr90">kw</span>::@Kwargs<span class="sgr90">{}</span><span class="sgr1">)</span> <span class="sgr35">@ Base ./reducedim.jl:986</span>
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">┌ </span><span class="sgr1">_sum(</span><span class="sgr90">f</span>::typeof(identity), <span class="sgr90">a</span>::Vector<span class="sgr90">{Any}</span>, ::Colon<span class="sgr1">)</span> <span class="sgr34">@ Base ./reducedim.jl:987</span>
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">┌ </span><span class="sgr1">_sum(</span><span class="sgr90">f</span>::typeof(identity), <span class="sgr90">a</span>::Vector<span class="sgr90">{Any}</span>, ::Colon; <span class="sgr90">kw</span>::@Kwargs<span class="sgr90">{}</span><span class="sgr1">)</span> <span class="sgr33">@ Base ./reducedim.jl:987</span>
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">┌ </span><span class="sgr1">mapreduce(</span><span class="sgr90">f</span>::typeof(identity), <span class="sgr90">op</span>::typeof(Base.add_sum), <span class="sgr90">A</span>::Vector<span class="sgr90">{Any}</span><span class="sgr1">)</span> <span class="sgr32">@ Base ./reducedim.jl:329</span>
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">┌ </span><span class="sgr1">mapreduce(</span><span class="sgr90">f</span>::typeof(identity), <span class="sgr90">op</span>::typeof(Base.add_sum), <span class="sgr90">A</span>::Vector<span class="sgr90">{Any}</span>; <span class="sgr90">dims</span>::Colon, <span class="sgr90">init</span>::Base._InitialValue<span class="sgr1">)</span> <span class="sgr35">@ Base ./reducedim.jl:329</span>
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">┌ </span><span class="sgr1">_mapreduce_dim(</span><span class="sgr90">f</span>::typeof(identity), <span class="sgr90">op</span>::typeof(Base.add_sum), ::Base._InitialValue, <span class="sgr90">A</span>::Vector<span class="sgr90">{Any}</span>, ::Colon<span class="sgr1">)</span> <span class="sgr34">@ Base ./reducedim.jl:337</span>
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">┌ </span><span class="sgr1">_mapreduce(</span><span class="sgr90">f</span>::typeof(identity), <span class="sgr90">op</span>::typeof(Base.add_sum), ::IndexLinear, <span class="sgr90">A</span>::Vector<span class="sgr90">{Any}</span><span class="sgr1">)</span> <span class="sgr33">@ Base ./reduce.jl:429</span>
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">┌ </span><span class="sgr1">mapreduce_empty_iter(</span><span class="sgr90">f</span>::typeof(identity), <span class="sgr90">op</span>::typeof(Base.add_sum), <span class="sgr90">itr</span>::Vector<span class="sgr90">{Any}</span>, <span class="sgr90">ItrEltype</span>::Base.HasEltype<span class="sgr1">)</span> <span class="sgr32">@ Base ./reduce.jl:377</span>
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">┌ </span><span class="sgr1">reduce_empty_iter(</span><span class="sgr90">op</span>::Base.MappingRF<span class="sgr90">{typeof(identity), typeof(Base.add_sum)}</span>, <span class="sgr90">itr</span>::Vector<span class="sgr90">{Any}</span>, ::Base.HasEltype<span class="sgr1">)</span> <span class="sgr35">@ Base ./reduce.jl:381</span>
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">┌ </span><span class="sgr1">reduce_empty(</span><span class="sgr90">op</span>::Base.MappingRF<span class="sgr90">{typeof(identity), typeof(Base.add_sum)}</span>, ::Type<span class="sgr90">{Any}</span><span class="sgr1">)</span> <span class="sgr34">@ Base ./reduce.jl:358</span>
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">┌ </span><span class="sgr1">mapreduce_empty(</span>::typeof(identity), <span class="sgr90">op</span>::typeof(Base.add_sum), <span class="sgr90">T</span>::Type<span class="sgr90">{Any}</span><span class="sgr1">)</span> <span class="sgr33">@ Base ./reduce.jl:369</span>
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">┌ </span><span class="sgr1">reduce_empty(</span>::typeof(Base.add_sum), ::Type<span class="sgr90">{Any}</span><span class="sgr1">)</span> <span class="sgr32">@ Base ./reduce.jl:350</span>
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">┌ </span><span class="sgr1">reduce_empty(</span>::typeof(+), ::Type<span class="sgr90">{Any}</span><span class="sgr1">)</span> <span class="sgr35">@ Base ./reduce.jl:343</span>
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr91">┌ </span><span class="sgr1">zero(</span>::Type<span class="sgr90">{Any}</span><span class="sgr1">)</span> <span class="sgr91">@ Base ./missing.jl:106</span>
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr91">│ MethodError: no method matching zero(::Type{Any}): </span><span class="sgr1">Base.throw(Base.MethodError(zero, tuple(Base.Any)<span class="sgr96">::Tuple{DataType}</span>)<span class="sgr96">::MethodError</span>)</span>
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr91">└────────────────────</span></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @report_call mode=:typo strange_sum([])</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr7">═════ 1 possible error found ═════</span>
<span class="sgr91">┌ </span><span class="sgr1">strange_sum(</span><span class="sgr90">a</span>::Vector<span class="sgr90">{Any}</span><span class="sgr1">)</span> <span class="sgr91">@ Main ./REPL[4]:3</span>
<span class="sgr91">│ `Main.undefsum` is not defined: </span><span class="sgr1">Main.undefsum</span>
<span class="sgr91">└────────────────────</span></code></pre><p>We can use <a href="#JET.@test_call"><code>@test_call</code></a> and <a href="#JET.test_call"><code>test_call</code></a> to assert that your program is free from problems that <code>@report_call</code> can detect. They work nicely with <a href="https://docs.julialang.org/en/v1/stdlib/Test/"><code>Test</code> standard library</a>&#39;s unit-testing infrastructure:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; @test_call target_modules=(@__MODULE__,) foo(&quot;1 2 3&quot;)</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr32"><span class="sgr1">Test Passed</span></span></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; using Test
       
       # we can get the nice summery using `@testset` !</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @testset &quot;JET testset&quot; begin
           @test_call target_modules=(@__MODULE__,) foo(&quot;1 2 3&quot;) # should pass
       
           test_call(myifelse, (Integer, Int, Int); mode=:sound)
       
           @test_call broken=true foo(&quot;1 2 3&quot;) # `broken` and `skip` options are supported
       
           @test foo(&quot;1 2 3&quot;) == 6 # of course other `Test` macros can be used in the same place
       end</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr37">JET testset: </span><span class="sgr91"><span class="sgr1">JET-test failed</span></span> at <span class="sgr1">/home/runner/work/JET.jl/JET.jl/src/JETBase.jl:1046</span>
  Expression: (JET.report_call)(Main.myifelse, (Integer, Int64, Int64); mode = sound)
  <span class="sgr7">═════ 1 possible error found ═════</span>
  <span class="sgr91">┌ </span><span class="sgr1">myifelse(</span><span class="sgr90">cond</span>::Integer, <span class="sgr90">a</span>::Int64, <span class="sgr90">b</span>::Int64<span class="sgr1">)</span> <span class="sgr91">@ Main ./REPL[1]:2</span>
  <span class="sgr91">│ non-boolean `Integer` may be used in boolean context: </span><span class="sgr1">goto %4 if not cond<span class="sgr96">::Integer</span></span>
  <span class="sgr91">└────────────────────</span>
  
<span class="sgr1">Test Summary: | <span class="sgr32">Pass  </span><span class="sgr91">Fail  </span><span class="sgr33">Broken  </span><span class="sgr36">Total  </span>Time</span>
JET testset   | <span class="sgr32">   2  </span><span class="sgr91">   1  </span><span class="sgr33">     1  </span><span class="sgr36">    4  </span>2.5s
ERROR: <span class="sgr91">Some tests did not pass: 2 passed, 1 failed, 0 errored, 1 broken.</span></code></pre><p>JET uses JET itself in its test pipeline: JET&#39;s static analysis has been proven to be very useful and helped its development a lot. If interested, take a peek at <a href="https://github.com/aviatesk/JET.jl/blob/master/test/self_check.jl">JET&#39;s <code>&quot;self check&quot;</code> testset</a>.</p><p>Lastly, let&#39;s see the example that demonstrates JET can analyze a &quot;top-level&quot; program. The top-level analysis should be considered as a somewhat experimental feature, and at this moment you may need additional configurations to run it correctly. Please read the descriptions of <a href="#jetanalysis-toplevel-entry">top-level entry points</a> and choose an appropriate entry point for your use case. Here we run <a href="#JET.report_file"><code>report_file</code></a> on <a href="https://github.com/aviatesk/JET.jl/blob/master/demo.jl">demo.jl</a>. It automatically extracts and loads &quot;definitions&quot; of functions, structs and such, and then analyzes their &quot;usages&quot; statically:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; report_file(normpath(Base.pkgdir(JET), &quot;demo.jl&quot;))</code><code class="nohighlight hljs ansi" style="display:block;">[toplevel-info] virtualized the context of Main (took 0.014 sec)
[toplevel-info] entered into /home/runner/work/JET.jl/JET.jl/demo.jl
[toplevel-info]  exited from /home/runner/work/JET.jl/JET.jl/demo.jl (took 0.125 sec)
<span class="sgr7">═════ 5 possible errors found ═════</span>
<span class="sgr91">┌ </span>Toplevel MethodInstance thunk <span class="sgr91">@ Main /home/runner/work/JET.jl/JET.jl/demo.jl:9</span>
<span class="sgr91">│ `m` is not defined: </span><span class="sgr1">m</span>
<span class="sgr91">└────────────────────</span>
<span class="sgr35">┌ </span>Toplevel MethodInstance thunk <span class="sgr35">@ Main /home/runner/work/JET.jl/JET.jl/demo.jl:10</span>
<span class="sgr35">│</span><span class="sgr34">┌ </span><span class="sgr1">fib(</span><span class="sgr90">n</span>::String<span class="sgr1">)</span> <span class="sgr34">@ Main /home/runner/work/JET.jl/JET.jl/demo.jl:6</span>
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">┌ </span><span class="sgr1">&lt;=(</span><span class="sgr90">x</span>::String, <span class="sgr90">y</span>::Int64<span class="sgr1">)</span> <span class="sgr33">@ Base ./operators.jl:402</span>
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr91">┌ </span><span class="sgr1">&lt;(</span><span class="sgr90">x</span>::String, <span class="sgr90">y</span>::Int64<span class="sgr1">)</span> <span class="sgr91">@ Base ./operators.jl:353</span>
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr91">│ no matching method found `isless(::String, ::Int64)`: </span><span class="sgr1">isless(x<span class="sgr96">::String</span>, y<span class="sgr96">::Int64</span>)</span>
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr91">└────────────────────</span>
<span class="sgr35">┌ </span>Toplevel MethodInstance thunk <span class="sgr35">@ Main /home/runner/work/JET.jl/JET.jl/demo.jl:28</span>
<span class="sgr35">│</span><span class="sgr34">┌ </span><span class="sgr1">foo(</span><span class="sgr90">a</span>::Float64<span class="sgr1">)</span> <span class="sgr34">@ Main /home/runner/work/JET.jl/JET.jl/demo.jl:20</span>
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">┌ </span><span class="sgr1">bar(</span><span class="sgr90">v</span>::Ty<span class="sgr90">{Float64}</span><span class="sgr1">)</span> <span class="sgr33">@ Main /home/runner/work/JET.jl/JET.jl/demo.jl:25</span>
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr91">┌ </span><span class="sgr1">getproperty(</span><span class="sgr90">x</span>::Ty<span class="sgr90">{Float64}</span>, <span class="sgr90">f</span>::Symbol<span class="sgr1">)</span> <span class="sgr91">@ Base ./Base.jl:49</span>
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr91">│ type Ty has no field fdl: </span><span class="sgr1">Base.getfield(x<span class="sgr96">::Ty{Float64}</span>, f<span class="sgr96">::Symbol</span>)</span>
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr91">└────────────────────</span>
<span class="sgr35">┌ </span>Toplevel MethodInstance thunk <span class="sgr35">@ Main /home/runner/work/JET.jl/JET.jl/demo.jl:29</span>
<span class="sgr35">│</span><span class="sgr34">┌ </span><span class="sgr1">foo(</span><span class="sgr90">a</span>::String<span class="sgr1">)</span> <span class="sgr34">@ Main /home/runner/work/JET.jl/JET.jl/demo.jl:20</span>
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr91">┌ </span><span class="sgr1">bar(</span><span class="sgr90">v</span>::Ty<span class="sgr90">{String}</span><span class="sgr1">)</span> <span class="sgr91">@ Main /home/runner/work/JET.jl/JET.jl/demo.jl:26</span>
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr91">│ no matching method found `convert(::Type{Number}, ::String)`: </span><span class="sgr1">convert(Number, (v<span class="sgr96">::Ty{String}</span>).fld<span class="sgr96">::String</span>)</span>
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr91">└────────────────────</span>
<span class="sgr35">┌ </span>Toplevel MethodInstance thunk <span class="sgr35">@ Main /home/runner/work/JET.jl/JET.jl/demo.jl:40</span>
<span class="sgr35">│</span><span class="sgr91">┌ </span><span class="sgr1">badmerge(</span><span class="sgr90">a</span>::@NamedTuple<span class="sgr90">{x::Int64, y::Int64}</span>, <span class="sgr90">b</span>::@NamedTuple<span class="sgr90">{y::Int64, z::Int64}</span><span class="sgr1">)</span> <span class="sgr91">@ Main /home/runner/work/JET.jl/JET.jl/demo.jl:33</span>
<span class="sgr35">│</span><span class="sgr91">│ `x` is not defined: </span><span class="sgr1">x</span>
<span class="sgr35">│</span><span class="sgr91">└────────────────────</span></code></pre><h2 id="Errors-kinds-and-how-to-fix-them"><a class="docs-heading-anchor" href="#Errors-kinds-and-how-to-fix-them">Errors kinds and how to fix them</a><a id="Errors-kinds-and-how-to-fix-them-1"></a><a class="docs-heading-anchor-permalink" href="#Errors-kinds-and-how-to-fix-them" title="Permalink"></a></h2><h3 id="no-matching-method-found"><a class="docs-heading-anchor" href="#no-matching-method-found"><code>no matching method found</code></a><a id="no-matching-method-found-1"></a><a class="docs-heading-anchor-permalink" href="#no-matching-method-found" title="Permalink"></a></h3><h4 id="Description"><a class="docs-heading-anchor" href="#Description">Description</a><a id="Description-1"></a><a class="docs-heading-anchor-permalink" href="#Description" title="Permalink"></a></h4><p>This error occurs when running the code might throw a <code>MethodError</code> at runtime. Similar to normal <code>MethodErrors</code>, this happens if a function is being called without a method matching the given argument types.</p><p>This is the most common error detected in most Julia code.</p><h4 id="Example"><a class="docs-heading-anchor" href="#Example">Example</a><a id="Example-1"></a><a class="docs-heading-anchor-permalink" href="#Example" title="Permalink"></a></h4><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; f(x::Integer) = x + one(x);</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; g(x) = f(x);</code><code class="nohighlight hljs ansi" style="display:block;"></code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @report_call g(1.0)</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr7">═════ 1 possible error found ═════</span>
<span class="sgr91">┌ </span><span class="sgr1">g(</span><span class="sgr90">x</span>::Float64<span class="sgr1">)</span> <span class="sgr91">@ Main ./REPL[2]:2</span>
<span class="sgr91">│ no matching method found `f(::Float64)`: </span><span class="sgr1">Main.f(x<span class="sgr96">::Float64</span>)</span>
<span class="sgr91">└────────────────────</span></code></pre><h4 id="How-to-fix"><a class="docs-heading-anchor" href="#How-to-fix">How to fix</a><a id="How-to-fix-1"></a><a class="docs-heading-anchor-permalink" href="#How-to-fix" title="Permalink"></a></h4><p>This error indicates some kind of type error in your code. You fix it like you would fix a regular <code>MethodError</code> thrown at runtime.</p><h3 id="no-matching-method-found-(x/y-union-split)"><a class="docs-heading-anchor" href="#no-matching-method-found-(x/y-union-split)"><code>no matching method found (x/y union split)</code></a><a id="no-matching-method-found-(x/y-union-split)-1"></a><a class="docs-heading-anchor-permalink" href="#no-matching-method-found-(x/y-union-split)" title="Permalink"></a></h3><h4 id="Description-2"><a class="docs-heading-anchor" href="#Description-2">Description</a><a class="docs-heading-anchor-permalink" href="#Description-2" title="Permalink"></a></h4><p>This error occurs when a variable <code>x</code> is inferred to be a union type, and <code>x</code> being one or more of the union&#39;s members would lead to a <code>MethodError</code>. For example, if the compiler infers <code>x</code> to be of type <code>Union{A, B}</code>, and then a function <code>f(x)</code> is called which would lead to a <code>MethodError</code> if <code>x</code> is a <code>A</code>, this error would occur.</p><p>More technically, this happens when one or more branches created by the compiler through union splitting contains a <code>no matching method found</code> error.</p><h4 id="Example-2"><a class="docs-heading-anchor" href="#Example-2">Example</a><a class="docs-heading-anchor-permalink" href="#Example-2" title="Permalink"></a></h4><p>Minimal example:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; struct Foo
           x::Union{Int, String}
       end
       
       # Errors if x.x isa String.
       # The compiler doesn&#39;t know if it&#39;s a String or Int</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; f(x) = x.x + 1;</code><code class="nohighlight hljs ansi" style="display:block;"></code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @report_call f(Foo(1))</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr7">═════ 1 possible error found ═════</span>
<span class="sgr91">┌ </span><span class="sgr1">f(</span><span class="sgr90">x</span>::Main.Foo<span class="sgr1">)</span> <span class="sgr91">@ Main ./REPL[2]:5</span>
<span class="sgr91">│ no matching method found `+(::String, ::Int64)` (1/2 union split): </span><span class="sgr1">Main.:+((x<span class="sgr96">::Main.Foo</span>).x<span class="sgr96">::Union{Int64, String}</span>, 1)</span>
<span class="sgr91">└────────────────────</span></code></pre><p>More common example:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; function pos_after_tab(v::AbstractArray{UInt8})
           # findfirst can return `nothing` on no match
           p = findfirst(isequal(UInt8(&#39;\t&#39;)), v)
           p + 1
       end</code><code class="nohighlight hljs ansi" style="display:block;">pos_after_tab (generic function with 1 method)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @report_call pos_after_tab(codeunits(&quot;a\tb&quot;))</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr7">═════ 1 possible error found ═════</span>
<span class="sgr91">┌ </span><span class="sgr1">pos_after_tab(</span><span class="sgr90">v</span>::Base.CodeUnits<span class="sgr90">{UInt8, String}</span><span class="sgr1">)</span> <span class="sgr91">@ Main ./REPL[1]:4</span>
<span class="sgr91">│ no matching method found `+(::Nothing, ::Int64)` (1/2 union split): </span><span class="sgr1">(p Main.:+ 1)</span>
<span class="sgr91">└────────────────────</span></code></pre><h4 id="How-to-fix-2"><a class="docs-heading-anchor" href="#How-to-fix-2">How to fix</a><a class="docs-heading-anchor-permalink" href="#How-to-fix-2" title="Permalink"></a></h4><p>This error is unique in that idiomatic Julia code may still lead to this error. For example, in the <code>pos_after_tab</code> function above, if the input vector does not have a <code>&#39;\t&#39;</code> byte, <code>p</code> will be <code>nothing</code>, and a <code>MethodError</code> will be thrown when <code>nothing + 1</code> is attempted. However, in many situations, the possibility of such a <code>MethodError</code> is not a mistake, but rather an idiomatic way of erroring.</p><p>There are different possibilities to address this kind of error. Let&#39;s take the <code>pos_after_tab</code> example:</p><p>If you actually <em>could</em> expect <code>p</code> to legitimately be <code>nothing</code> for valid input (i.e. the input could lack a <code>&#39;\t&#39;</code> byte), then your function should be written to take this edge case into account:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; function pos_after_tab(v::AbstractArray{UInt8})
           p = findfirst(isequal(UInt8(&#39;\t&#39;)), v)
           if p === nothing # handle the nothing case
               return nothing
           else
               return p + 1
           end
       end;</code><code class="nohighlight hljs ansi" style="display:block;"></code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @report_call pos_after_tab(codeunits(&quot;a\tb&quot;))</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr92">No errors detected</span></code></pre><p>By adding the <code>if p === nothing</code> check, the compiler will know that the type of <code>p</code> must be <code>Nothing</code> inside the <code>if</code> block, and <code>Int</code> in the <code>else</code> block. This way, the compiler knows a <code>MethodError</code> is not possible, and the error will disappear.</p><p>If you expect a <code>&#39;\t&#39;</code> byte to always be present, such that <code>findfirst</code> always should return an <code>Int</code> for valid input, you can add a typeassert in the function to assert that the return value of <code>findfirst</code> must be, say, an <code>Integer</code>. Then, the compiler will know that if the typeassert passes, the value returned by <code>findfirst</code> cannot be <code>nothing</code> (and hence in this case must be <code>Int</code>):</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; function pos_after_tab(v::AbstractArray{UInt8})
           p = findfirst(isequal(UInt8(&#39;\t&#39;)), v)::Integer
           p + 1
       end;</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @report_call pos_after_tab(codeunits(&quot;a\tb&quot;))</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr92">No errors detected</span></code></pre><p>The code will still error at runtime due to the typeassert if <code>findfirst</code> returns <code>nothing</code>, but JET will no longer detect it as an error, because the programmer, by adding the typeassert, explicitly acknowledge that the compiler&#39;s inference may not be precise enough, and helps the compiler.</p><p>Note that adding a typeassert also improves code quality:</p><ul><li>The programmer&#39;s intent to never observe <code>nothing</code> is communicated clearly</li><li>After the typeassert passes, <code>p</code> is inferred to be <code>Int</code> instead of a union, and this more precise type inference generates more efficient code.</li><li>More precise inference reduces the risk of invalidations from the code, improving latency.</li></ul><p>A special case occurs when loading <code>Union</code>-typed fields from structs. Julia does not realize that loading the same field multiple times from a mutable struct necessarily returns the same object. Hence, in the following example:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; mutable struct Foo
           x::Union{Int, Nothing}
       end</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; function f(x)
           if x.x === nothing
               nothing
           else
               x.x + 1
           end
       end;</code><code class="nohighlight hljs ansi" style="display:block;"></code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @report_call f(Foo(1))</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr7">═════ 1 possible error found ═════</span>
<span class="sgr91">┌ </span><span class="sgr1">f(</span><span class="sgr90">x</span>::Main.Foo<span class="sgr1">)</span> <span class="sgr91">@ Main ./REPL[2]:7</span>
<span class="sgr91">│ no matching method found `+(::Nothing, ::Int64)` (1/2 union split): </span><span class="sgr1">Main.:+((x<span class="sgr96">::Main.Foo</span>).x<span class="sgr96">::Union{Nothing, Int64}</span>, 1)</span>
<span class="sgr91">└────────────────────</span></code></pre><p>We might reasonably expect the compiler to know that in the <code>else</code> branch, <code>x.x</code> must be an <code>Int</code>, since it just checked that it is not <code>nothing</code>. However, the compiler does not know that the value obtained from loading the <code>x</code> field in the expression <code>x.x</code> on the like with the if statement in this case is the same value as the value obtained when loading the <code>x</code> field in the <code>x.x + 1</code> statement. You can solve this issue by assigning <code>x.x</code> to a variable:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; function f(x)
           y = x.x
           if y === nothing
               nothing
           else
               y + 1
           end
       end;</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @report_call f(Foo(1))</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr92">No errors detected</span></code></pre><h3 id="X-is-not-defined"><a class="docs-heading-anchor" href="#X-is-not-defined"><code>X is not defined</code></a><a id="X-is-not-defined-1"></a><a class="docs-heading-anchor-permalink" href="#X-is-not-defined" title="Permalink"></a></h3><h4 id="Description-3"><a class="docs-heading-anchor" href="#Description-3">Description</a><a class="docs-heading-anchor-permalink" href="#Description-3" title="Permalink"></a></h4><p>This happens when a name <code>X</code> is used in a function, but no object named <code>X</code> can be found.</p><h4 id="Example-3"><a class="docs-heading-anchor" href="#Example-3">Example</a><a class="docs-heading-anchor-permalink" href="#Example-3" title="Permalink"></a></h4><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; f(x) = foo(x) + 1;</code><code class="nohighlight hljs ansi" style="display:block;"></code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @report_call f(1)</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr7">═════ 1 possible error found ═════</span>
<span class="sgr91">┌ </span><span class="sgr1">f(</span><span class="sgr90">x</span>::Int64<span class="sgr1">)</span> <span class="sgr91">@ Main ./REPL[1]:1</span>
<span class="sgr91">│ `Main.foo` is not defined: </span><span class="sgr1">Main.foo</span>
<span class="sgr91">└────────────────────</span></code></pre><h4 id="How-to-fix-3"><a class="docs-heading-anchor" href="#How-to-fix-3">How to fix</a><a class="docs-heading-anchor-permalink" href="#How-to-fix-3" title="Permalink"></a></h4><p>This error can have a couple of causes:</p><ul><li><code>X</code> is misspelled. If so, correct the typo</li><li><code>X</code> exists, but cannot be reached from the scope of the function. If so, pass it in as an argument to the offending function.</li></ul><h3 id="type-T-has-no-field-F"><a class="docs-heading-anchor" href="#type-T-has-no-field-F"><code>type T has no field F</code></a><a id="type-T-has-no-field-F-1"></a><a class="docs-heading-anchor-permalink" href="#type-T-has-no-field-F" title="Permalink"></a></h3><h4 id="Description-4"><a class="docs-heading-anchor" href="#Description-4">Description</a><a class="docs-heading-anchor-permalink" href="#Description-4" title="Permalink"></a></h4><p>This error occurs when <code>Core.getfield</code> is (indirectly) called with a nonexisting and hardcoded field name. For example, if an object have a field called <code>vec</code> and you type it <code>vector</code>.</p><h4 id="Example-4"><a class="docs-heading-anchor" href="#Example-4">Example</a><a class="docs-heading-anchor-permalink" href="#Example-4" title="Permalink"></a></h4><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; struct Foo
           my_field
       end</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; f(x) = x.my_feild; # NB: Typo!</code><code class="nohighlight hljs ansi" style="display:block;"></code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @report_call f(Foo(1))</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr7">═════ 1 possible error found ═════</span>
<span class="sgr35">┌ </span><span class="sgr1">f(</span><span class="sgr90">x</span>::Main.Foo<span class="sgr1">)</span> <span class="sgr35">@ Main ./REPL[2]:2</span>
<span class="sgr35">│</span><span class="sgr91">┌ </span><span class="sgr1">getproperty(</span><span class="sgr90">x</span>::Main.Foo, <span class="sgr90">f</span>::Symbol<span class="sgr1">)</span> <span class="sgr91">@ Base ./Base.jl:49</span>
<span class="sgr35">│</span><span class="sgr91">│ type Foo has no field my_feild: </span><span class="sgr1">Base.getfield(x<span class="sgr96">::Main.Foo</span>, f<span class="sgr96">::Symbol</span>)</span>
<span class="sgr35">│</span><span class="sgr91">└────────────────────</span></code></pre><h4 id="How-to-fix-4"><a class="docs-heading-anchor" href="#How-to-fix-4">How to fix</a><a class="docs-heading-anchor-permalink" href="#How-to-fix-4" title="Permalink"></a></h4><p>This error often occurs when the field name is mistyped. Correct the typo.</p><h3 id="BoundsError:-Attempt-to-access-T-at-index-[i]"><a class="docs-heading-anchor" href="#BoundsError:-Attempt-to-access-T-at-index-[i]"><code>BoundsError: Attempt to access T at index [i]</code></a><a id="BoundsError:-Attempt-to-access-T-at-index-[i]-1"></a><a class="docs-heading-anchor-permalink" href="#BoundsError:-Attempt-to-access-T-at-index-[i]" title="Permalink"></a></h3><h4 id="Description-5"><a class="docs-heading-anchor" href="#Description-5">Description</a><a class="docs-heading-anchor-permalink" href="#Description-5" title="Permalink"></a></h4><p>This error occurs when it is known at compile time that the call will throw a <code>BoundsError</code>. Note that most <code>BoundsErrors</code> cannot be predicted at compile time. For the compiler to know a function attempts to access a container out of bounds, both the container length and the index value must be known at compiletime. Hence, the error is detected for a <code>Tuple</code> input in the example below, but not for a <code>Vector</code> input.</p><h4 id="Example-5"><a class="docs-heading-anchor" href="#Example-5">Example</a><a class="docs-heading-anchor-permalink" href="#Example-5" title="Permalink"></a></h4><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; get_fourth(x) = x[4]</code><code class="nohighlight hljs ansi" style="display:block;">get_fourth (generic function with 1 method)</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @report_call get_fourth((1,2,3))</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr7">═════ 1 possible error found ═════</span>
<span class="sgr35">┌ </span><span class="sgr1">get_fourth(</span><span class="sgr90">x</span>::Tuple<span class="sgr90">{Int64, Int64, Int64}</span><span class="sgr1">)</span> <span class="sgr35">@ Main ./REPL[1]:1</span>
<span class="sgr35">│</span><span class="sgr91">┌ </span><span class="sgr1">getindex(</span><span class="sgr90">t</span>::Tuple<span class="sgr90">{Int64, Int64, Int64}</span>, <span class="sgr90">i</span>::Int64<span class="sgr1">)</span> <span class="sgr91">@ Base ./tuple.jl:31</span>
<span class="sgr35">│</span><span class="sgr91">│ BoundsError: attempt to access Tuple{Int64, Int64, Int64} at index [4]: </span><span class="sgr1">Base.getfield(t<span class="sgr96">::Tuple{Int64, Int64, Int64}</span>, i<span class="sgr96">::Int64</span>, $(Expr(:boundscheck)))</span>
<span class="sgr35">│</span><span class="sgr91">└────────────────────</span></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @report_call get_fourth([1,2,3]) # NB: False negative!</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr92">No errors detected</span></code></pre><h4 id="How-to-fix-5"><a class="docs-heading-anchor" href="#How-to-fix-5">How to fix</a><a class="docs-heading-anchor-permalink" href="#How-to-fix-5" title="Permalink"></a></h4><p>If this error appears, the offending code uses a bad index. Since the error most often occurs when the index is hardcoded, simply fix the index value.</p><h3 id="may-throw-[...]"><a class="docs-heading-anchor" href="#may-throw-[...]"><code>may throw [...]</code></a><a id="may-throw-[...]-1"></a><a class="docs-heading-anchor-permalink" href="#may-throw-[...]" title="Permalink"></a></h3><h4 id="Description-6"><a class="docs-heading-anchor" href="#Description-6">Description</a><a class="docs-heading-anchor-permalink" href="#Description-6" title="Permalink"></a></h4><p>This error indicates that JET detected the possibility of an exception. By default, JET will not report this error, unless a function is inferred to <em>always</em> throw, AND the exception is not caught in a try statement. In &quot;sound&quot; mode, this error is reported if the function <em>may</em> throw.</p><h4 id="Example-6"><a class="docs-heading-anchor" href="#Example-6">Example</a><a class="docs-heading-anchor-permalink" href="#Example-6" title="Permalink"></a></h4><p>In this example, the function is known at compile time to throw an uncaught exception, and so is reported by default:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; f(x) = x isa Integer ? throw(&quot;Integer&quot;) : nothing;</code><code class="nohighlight hljs ansi" style="display:block;"></code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @report_call f(1)</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr7">═════ 1 possible error found ═════</span>
<span class="sgr91">┌ </span><span class="sgr1">f(</span><span class="sgr90">x</span>::Int64<span class="sgr1">)</span> <span class="sgr91">@ Main ./REPL[1]:1</span>
<span class="sgr91">│ may throw: </span><span class="sgr1">Main.throw(&quot;Integer&quot;)</span>
<span class="sgr91">└────────────────────</span></code></pre><p>In this example, it&#39;s not known at compile time whether it throws, and therefore, JET reports no errors by default. In sound mode, the error is reported.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; f(x) = x == 9873984732 ? nothing : throw(&quot;Bad value&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">f (generic function with 1 method)</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @report_call f(1)</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr92">No errors detected</span></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @report_call mode=:sound f(1)</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr7">═════ 1 possible error found ═════</span>
<span class="sgr91">┌ </span><span class="sgr1">f(</span><span class="sgr90">x</span>::Int64<span class="sgr1">)</span> <span class="sgr91">@ Main ./REPL[1]:1</span>
<span class="sgr91">│ may throw: </span><span class="sgr1">Main.throw(&quot;Bad value&quot;)</span>
<span class="sgr91">└────────────────────</span></code></pre><p>In this example, the exception is handled, so JET reports no errors by default. In sound mode, the error is reported:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; g() = throw();</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; f() = try
           g()
       catch
           nothing
       end;</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; f()</code><code class="nohighlight hljs ansi" style="display:block;"></code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @report_call f()</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr92">No errors detected</span></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @report_call mode=:sound f()</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr7">═════ 1 possible error found ═════</span>
<span class="sgr35">┌ </span><span class="sgr1">f()</span> <span class="sgr35">@ Main ./REPL[2]:3</span>
<span class="sgr35">│</span><span class="sgr91">┌ </span><span class="sgr1">g()</span> <span class="sgr91">@ Main ./REPL[1]:1</span>
<span class="sgr35">│</span><span class="sgr91">│ may throw: </span><span class="sgr1">Main.throw()</span>
<span class="sgr35">│</span><span class="sgr91">└────────────────────</span></code></pre><h2 id="jetanalysis-entry"><a class="docs-heading-anchor" href="#jetanalysis-entry">Entry Points</a><a id="jetanalysis-entry-1"></a><a class="docs-heading-anchor-permalink" href="#jetanalysis-entry" title="Permalink"></a></h2><h3 id="jetanalysis-interactive-entry"><a class="docs-heading-anchor" href="#jetanalysis-interactive-entry">Interactive Entry Points</a><a id="jetanalysis-interactive-entry-1"></a><a class="docs-heading-anchor-permalink" href="#jetanalysis-interactive-entry" title="Permalink"></a></h3><p>JET offers interactive analysis entry points that can be used similarly to <a href="https://docs.julialang.org/en/v1/base/base/#Base.code_typed"><code>code_typed</code></a> and its family:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JET.@report_call" href="#JET.@report_call"><code>JET.@report_call</code></a> — <span class="docstring-category">Macro</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">@report_call [jetconfigs...] f(args...)</code></pre><p>Evaluates the arguments to a function call, determines their types, and then calls <a href="#JET.report_call"><code>report_call</code></a> on the resulting expression. This macro works in a similar way as the <code>@code_typed</code> macro.</p><p>The <a href="../config/#general-configurations">general configurations</a> and <a href="#jetanalysis-config">the error analysis specific configurations</a> can be specified as an optional argument.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aviatesk/JET.jl/blob/feec5fa13586a7921a45b30d6bddd91f8ec964f1/src/analyzers/jetanalyzer.jl#L1404-L1413">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JET.report_call" href="#JET.report_call"><code>JET.report_call</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">report_call(f, [types]; jetconfigs...) -&gt; JETCallResult
report_call(tt::Type{&lt;:Tuple}; jetconfigs...) -&gt; JETCallResult
report_call(mi::Core.MethodInstance; jetconfigs...) -&gt; JETCallResult</code></pre><p>Analyzes a function call with the given type signature to find type-level errors and returns back detected problems.</p><p>The <a href="../config/#general-configurations">general configurations</a> and <a href="#jetanalysis-config">the error analysis specific configurations</a> can be specified as a keyword argument.</p><p>See <a href="#jetanalysis">the documentation of the error analysis</a> for more details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aviatesk/JET.jl/blob/feec5fa13586a7921a45b30d6bddd91f8ec964f1/src/analyzers/jetanalyzer.jl#L1386-L1398">source</a></section></article><h3 id="jetanalysis-toplevel-entry"><a class="docs-heading-anchor" href="#jetanalysis-toplevel-entry">Top-level Entry Points</a><a id="jetanalysis-toplevel-entry-1"></a><a class="docs-heading-anchor-permalink" href="#jetanalysis-toplevel-entry" title="Permalink"></a></h3><p>JET can also analyze your &quot;top-level&quot; program: it can just take your Julia script or package and will report possible errors.</p><p>Note that JET will analyze your top-level program &quot;half-statically&quot;: JET will selectively interpret and load &quot;definitions&quot; (like a function or struct definition) and try to simulate Julia&#39;s top-level code execution process. While it tries to avoid executing any other parts of code like function calls and analyzes them based on abstract interpretation instead (and this is a part where JET statically analyzes your code). If you&#39;re interested in how JET selects &quot;top-level definitions&quot;, please see <a href="../internals/#JET.virtual_process"><code>JET.virtual_process</code></a>.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>Because JET will interpret &quot;definitions&quot; in your code, that part of top-level analysis certainly <em>runs</em> your code. So we should note that JET can cause some side effects from your code; for example, JET will try to expand all the macros used in your code, and so the side effects involved with macro expansions will also happen in JET&#39;s analysis process.</p></div></div><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JET.report_file" href="#JET.report_file"><code>JET.report_file</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">report_file(file::AbstractString; jetconfigs...) -&gt; JETToplevelResult</code></pre><p>Analyzes <code>file</code> to find type-level errors and returns back detected problems.</p><p>This function looks for <code>.JET.toml</code> configuration file in the directory of <code>file</code>, and searches <em>upward</em> in the file tree until a <code>.JET.toml</code> is (or isn&#39;t) found. When found, the configurations specified in the file are applied. See <a href="../config/#config-file">JET&#39;s configuration file specification</a> for more details.</p><p>The <a href="../config/#general-configurations">general configurations</a> and <a href="#jetanalysis-config">the error analysis specific configurations</a> can be specified as a keyword argument, and if given, they are preferred over the configurations specified by a <code>.JET.toml</code> configuration file.</p><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>When you want to analyze your package but no files that actually use its functions are available, <a href="../config/#toplevel-config">the <code>analyze_from_definitions</code> option</a> may be useful since it allows JET to analyze methods based on their declared signatures. For example, JET can analyze JET itself in this way:</p><pre><code class="language-julia-repl hljs"># from the root directory of JET.jl
julia&gt; report_file(&quot;src/JET.jl&quot;;
                   analyze_from_definitions = true)</code></pre><p>See also <a href="#JET.report_package"><code>report_package</code></a>.</p></div></div><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>This function enables the <code>toplevel_logger</code> configuration with the default logging level by default. You can still explicitly specify and configure it:</p><pre><code class="language-julia hljs">report_file(args...;
            toplevel_logger = nothing, # suppress the toplevel logger
            jetconfigs...) # other configurations</code></pre><p>See <a href="../config/#toplevel-config">JET&#39;s top-level analysis configurations</a> for more details.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aviatesk/JET.jl/blob/feec5fa13586a7921a45b30d6bddd91f8ec964f1/src/analyzers/jetanalyzer.jl#L1516-L1551">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JET.watch_file" href="#JET.watch_file"><code>JET.watch_file</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">watch_file(file::AbstractString; jetconfigs...)</code></pre><p>Watches <code>file</code> and keeps re-triggering analysis with <a href="#JET.report_file"><code>report_file</code></a> on code update. JET will try to analyze all the <code>include</code>d files reachable from <code>file</code>, and it will re-trigger analysis if there is code update detected in any of the <code>include</code>d files.</p><p>This entry point currently uses <a href="https://timholy.github.io/Revise.jl/stable/">Revise.jl</a> to monitor code updates, and <em>can only be used after Revise has been loaded into the session</em>. So note that you&#39;ll need to have run e.g., <code>using Revise</code> at some earlier stage to use it. Revise offers possibilities to track changes in files that are not directly analyzed by JET, including changes made to <code>Base</code> files using configurations like <code>revise_modules = [Base]</code>. See <a href="../config/#watch-config">watch configurations</a> for more details.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>This interface is very experimental and likely to subject to change or removal without notice.</p></div></div><p>See also <a href="#JET.report_file"><code>report_file</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aviatesk/JET.jl/blob/feec5fa13586a7921a45b30d6bddd91f8ec964f1/src/analyzers/jetanalyzer.jl#L1677-L1695">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JET.report_package" href="#JET.report_package"><code>JET.report_package</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">report_package(package::Module; jetconfigs...) -&gt; JETToplevelResult
report_package(package::AbstractString; jetconfigs...) -&gt; JETToplevelResult</code></pre><p>Analyzes <code>package</code> in the same way as <a href="#JET.report_file"><code>report_file</code></a> and returns back type-level errors with the special default configurations, which are especially tuned for analyzing a package (see below for details). The <code>package</code> argument can be either a <code>Module</code> or a <code>AbstractString</code>. In the latter case it must be the name of a package in your current environment.</p><p>The error analysis performed by this function is configured as follows by default:</p><ul><li><code>analyze_from_definitions = true</code>: This allows JET to start analysis without top-level call sites. This is useful for analyzing a package since a package itself usually only contains definitions of types and methods but not their usages (i.e. call sites).</li><li><code>concretization_patterns = [:(x_)]</code>: Concretizes every top-level code in a given <code>package</code>. The concretizations are generally preferred for successful analysis as far as they can be performed cheaply. In most cases it is indeed cheap to interpret and concretize top-level code written in a package since it usually only defines types and methods.</li><li><code>ignore_missing_comparison = true</code>: JET ignores the possibility of a poorly-inferred comparison operator call (e.g. <code>==</code>) returning <code>missing</code>. This is useful because <code>report_package</code> often relies on poor input argument type information at the beginning of analysis, leading to noisy error reports from branching on the potential <code>missing</code> return value of such a comparison operator call. If a target package needs to handle <code>missing</code>, this  configuration shuold be turned off since it hides the possibility of errors that may actually at runtime.</li></ul><p>See <a href="../config/#JET.ToplevelConfig"><code>ToplevelConfig</code></a> and <a href="#JET.JETAnalyzer"><code>JETAnalyzer</code></a> for more details.</p><p>Still the <a href="../config/#general-configurations">general configurations</a> and <a href="#jetanalysis-config">the error analysis specific configurations</a> can be specified as a keyword argument, and if given, they are preferred over the default configurations described above.</p><hr/><pre><code class="nohighlight hljs">report_package(; jetconfigs...) -&gt; JETToplevelResult</code></pre><p>Like above but analyzes the package of the current project.</p><p>See also <a href="#JET.report_file"><code>report_file</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aviatesk/JET.jl/blob/feec5fa13586a7921a45b30d6bddd91f8ec964f1/src/analyzers/jetanalyzer.jl#L1575-L1614">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JET.report_text" href="#JET.report_text"><code>JET.report_text</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">report_text(text::AbstractString; jetconfigs...) -&gt; JETToplevelResult
report_text(text::AbstractString, filename::AbstractString; jetconfigs...) -&gt; JETToplevelResult</code></pre><p>Analyzes top-level <code>text</code> and returns back type-level errors.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aviatesk/JET.jl/blob/feec5fa13586a7921a45b30d6bddd91f8ec964f1/src/analyzers/jetanalyzer.jl#L1648-L1653">source</a></section></article><h3 id="jetanalysis-test-integration"><a class="docs-heading-anchor" href="#jetanalysis-test-integration"><code>Test</code> Integration</a><a id="jetanalysis-test-integration-1"></a><a class="docs-heading-anchor-permalink" href="#jetanalysis-test-integration" title="Permalink"></a></h3><p>JET also exports entries that are fully integrated with <a href="https://docs.julialang.org/en/v1/stdlib/Test/"><code>Test</code> standard library</a>&#39;s unit-testing infrastructure. It can be used in your test suite to assert your program is free from errors that JET can detect:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JET.@test_call" href="#JET.@test_call"><code>JET.@test_call</code></a> — <span class="docstring-category">Macro</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">@test_call [jetconfigs...] [broken=false] [skip=false] f(args...)</code></pre><p>Runs <a href="#JET.@report_call"><code>@report_call jetconfigs... f(args...)</code></a> and tests that the function call <code>f(args...)</code> is free from problems that <code>@report_call</code> can detect. Returns a <code>Pass</code> result if the test is successful, a <code>Fail</code> result if any problems are detected, or an <code>Error</code> result if the test encounters an unexpected error. When the test <code>Fail</code>s, abstract call stack to each problem location will be printed to <code>stdout</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; @test_call sincos(10)
Test Passed
  Expression: #= none:1 =# JET.@test_call sincos(10)</code></pre><p>As with <a href="#JET.@report_call"><code>@report_call</code></a>, the <a href="../config/#general-configurations">general configurations</a> and <a href="#jetanalysis-config">the error analysis specific configurations</a> can be specified as an optional argument:</p><pre><code class="language-julia-repl hljs">julia&gt; cond = false

julia&gt; function f(n)
           # `cond` is untyped, and will be reported by the sound analysis pass,
           # while JET&#39;s default analysis pass will ignore it
           if cond
               return sin(n)
           else
               return cos(n)
           end
       end;

julia&gt; @test_call f(10)
Test Passed
  Expression: #= none:1 =# JET.@test_call f(10)

julia&gt; @test_call mode=:sound f(10)
JET-test failed at none:1
  Expression: #= none:1 =# JET.@test_call mode = :sound f(10)
  ═════ 1 possible error found ═════
  ┌ @ none:2 goto %4 if not cond
  │ non-boolean (Any) used in boolean context: goto %4 if not cond
  └──────────

ERROR: There was an error during testing</code></pre><p><code>@test_call</code> is fully integrated with <a href="https://docs.julialang.org/en/v1/stdlib/Test/"><code>Test</code> standard library</a>&#39;s unit-testing infrastructure. This means that the result of <code>@test_call</code> will be included in a final <code>@testset</code> summary and it supports <code>skip</code> and <code>broken</code> annotations, just like the <code>@test</code> macro:</p><pre><code class="language-julia-repl hljs">julia&gt; using JET, Test

# Julia can&#39;t propagate the type constraint `ref[]::Number` to `sin(ref[])`, JET will report `NoMethodError`
julia&gt; f(ref) = isa(ref[], Number) ? sin(ref[]) : nothing;

# we can make it type-stable if we extract `ref[]` into a local variable `x`
julia&gt; g(ref) = (x = ref[]; isa(x, Number) ? sin(x) : nothing);

julia&gt; @testset &quot;check errors&quot; begin
           ref = Ref{Union{Nothing,Int}}(0)
           @test_call f(ref)             # fail
           @test_call g(ref)             # fail
           @test_call broken=true f(ref) # annotated as broken, thus still &quot;pass&quot;
       end
check errors: JET-test failed at REPL[21]:3
  Expression: #= REPL[21]:3 =# JET.@test_call f(ref)
  ═════ 1 possible error found ═════
  ┌ f(ref::Base.RefValue{Union{Nothing, Int64}}) @ Main ./REPL[19]:1
  │ no matching method found `sin(::Nothing)` (1/2 union split): sin((ref::Base.RefValue{Union{Nothing, Int64}})[]::Union{Nothing, Int64})
  └────────────────────

Test Summary: | Pass  Fail  Broken  Total  Time
check errors  |    1     1       1      3  0.2s
ERROR: Some tests did not pass: 1 passed, 1 failed, 0 errored, 1 broken.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aviatesk/JET.jl/blob/feec5fa13586a7921a45b30d6bddd91f8ec964f1/src/analyzers/jetanalyzer.jl#L1421-L1495">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JET.test_call" href="#JET.test_call"><code>JET.test_call</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">test_call(f, [types]; broken::Bool = false, skip::Bool = false, jetconfigs...)
test_call(tt::Type{&lt;:Tuple}; broken::Bool = false, skip::Bool = false, jetconfigs...)</code></pre><p>Runs <a href="#JET.report_call"><code>report_call</code></a> on a function call with the given type signature and tests that it is free from problems that <code>report_call</code> can detect. Except that it takes a type signature rather than a call expression, this function works in the same way as <a href="#JET.@test_call"><code>@test_call</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aviatesk/JET.jl/blob/feec5fa13586a7921a45b30d6bddd91f8ec964f1/src/analyzers/jetanalyzer.jl#L1500-L1508">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JET.test_file" href="#JET.test_file"><code>JET.test_file</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">test_file(file::AbstractString; jetconfigs...)</code></pre><p>Runs <a href="#JET.report_file"><code>report_file</code></a> and tests that there are no problems detected.</p><p>As with <a href="#JET.report_file"><code>report_file</code></a>, the <a href="../config/#general-configurations">general configurations</a> and <a href="#jetanalysis-config">the error analysis specific configurations</a> can be specified as an optional argument.</p><p>Like <a href="#JET.@test_call"><code>@test_call</code></a>, <code>test_file</code> is fully integrated with the <a href="https://docs.julialang.org/en/v1/stdlib/Test/"><code>Test</code> standard library</a>. See <a href="#JET.@test_call"><code>@test_call</code></a> for the details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aviatesk/JET.jl/blob/feec5fa13586a7921a45b30d6bddd91f8ec964f1/src/analyzers/jetanalyzer.jl#L1558-L1570">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JET.test_package" href="#JET.test_package"><code>JET.test_package</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">test_package(package::Module; jetconfigs...)
test_package(package::AbstractString; jetconfigs...)
test_package(; jetconfigs...)</code></pre><p>Runs <a href="#JET.report_package"><code>report_package</code></a> and tests that there are no problems detected.</p><p>As with <a href="#JET.report_package"><code>report_package</code></a>, the <a href="../config/#general-configurations">general configurations</a> and <a href="#jetanalysis-config">the error analysis specific configurations</a> can be specified as an optional argument.</p><p>Like <a href="#JET.@test_call"><code>@test_call</code></a>, <code>test_package</code> is fully integrated with the <a href="https://docs.julialang.org/en/v1/stdlib/Test/"><code>Test</code> standard library</a>. See <a href="#JET.@test_call"><code>@test_call</code></a> for the details.</p><pre><code class="language-julia hljs">julia&gt; @testset &quot;test_package&quot; begin
           test_package(&quot;Example&quot;; toplevel_logger=nothing)
       end;
Test Summary: | Pass  Total  Time
test_package  |    1      1  0.0s</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aviatesk/JET.jl/blob/feec5fa13586a7921a45b30d6bddd91f8ec964f1/src/analyzers/jetanalyzer.jl#L1621-L1643">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JET.test_text" href="#JET.test_text"><code>JET.test_text</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">test_text(text::AbstractString; jetconfigs...)
test_text(text::AbstractString, filename::AbstractString; jetconfigs...)</code></pre><p>Runs <a href="#JET.report_text"><code>report_text</code></a> and tests that there are no problems detected.</p><p>As with <a href="#JET.report_text"><code>report_text</code></a>, the <a href="../config/#general-configurations">general configurations</a> and <a href="#jetanalysis-config">the error analysis specific configurations</a> can be specified as an optional argument.</p><p>Like <a href="#JET.@test_call"><code>@test_call</code></a>, <code>test_text</code> is fully integrated with the <a href="https://docs.julialang.org/en/v1/stdlib/Test/"><code>Test</code> standard library</a>. See <a href="#JET.@test_call"><code>@test_call</code></a> for the details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aviatesk/JET.jl/blob/feec5fa13586a7921a45b30d6bddd91f8ec964f1/src/analyzers/jetanalyzer.jl#L1659-L1672">source</a></section></article><h2 id="jetanalysis-config"><a class="docs-heading-anchor" href="#jetanalysis-config">Configurations</a><a id="jetanalysis-config-1"></a><a class="docs-heading-anchor-permalink" href="#jetanalysis-config" title="Permalink"></a></h2><p>In addition to the <a href="../config/#general-configurations">general configurations</a>, the error analysis can take the following specific configurations:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JET.JETAnalyzer" href="#JET.JETAnalyzer"><code>JET.JETAnalyzer</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Every <a href="#jetanalysis-entry">entry point of error analysis</a> can accept any of the <a href="../config/#general-configurations">general configurations</a> as well as the following additional configurations that are specific to the error analysis.</p><hr/><ul><li><p><code>mode::Symbol = :basic</code>:<br/>Switches the error analysis pass. Each analysis pass reports errors according to their own &quot;error&quot; definition. JET by default offers the following modes:</p><ul><li><code>mode = :basic</code>: the default error analysis pass. This analysis pass is tuned to be useful for general Julia development by reporting common problems, but also note that it is not enough strict to guarantee that your program never throws runtime errors.<br/>See <a href="#JET.BasicPass"><code>BasicPass</code></a> for more details.</li><li><code>mode = :sound</code>: the sound error analysis pass. If this pass doesn&#39;t report any errors, then your program is assured to run without any runtime errors (unless JET&#39;s error definition is not accurate and/or there is an implementation flaw).<br/>See <a href="#JET.SoundPass"><code>SoundPass</code></a> for more details.</li><li><code>mode = :typo</code>: a typo detection pass A simple analysis pass to detect &quot;typo&quot;s in your program. This analysis pass is essentially a subset of the default basic pass (<a href="#JET.BasicPass"><code>BasicPass</code></a>), and it only reports undefined global reference and undefined field access. This might be useful especially for a very complex code base, because even the basic pass tends to be too noisy (spammed with too many errors) for such a case.<br/>See <a href="#JET.TypoPass"><code>TypoPass</code></a> for more details.</li></ul><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>You can also set up your own analysis using JET&#39;s <a href="../generated-plugin-api/#AbstractAnalyzer-Framework"><code>AbstractAnalyzer</code>-Framework</a>.</p></div></div></li></ul><hr/><ul><li><code>ignore_missing_comparison::Bool = false</code>:<br/>If <code>true</code>, JET will ignores the possibility of a poorly-inferred comparison operator call (e.g. <code>==</code>) returning <code>missing</code> in order to hide the error reports from branching on the potential <code>missing</code> return value of such a comparison operator call. This is turned off by default, because a comparison call results in a <code>Union{Bool,Missing}</code> possibility, it likely signifies an inferrability issue or the <code>missing</code> possibility should be handled someway. But this is useful to reduce the noisy error reports in the situations where specific input arguments type is not available at the beginning of the analysis like <a href="#JET.report_package"><code>report_package</code></a>.</li></ul><hr/></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aviatesk/JET.jl/blob/feec5fa13586a7921a45b30d6bddd91f8ec964f1/src/analyzers/jetanalyzer.jl#L11-L52">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JET.BasicPass" href="#JET.BasicPass"><code>JET.BasicPass</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>The basic error analysis pass. This is used by default.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aviatesk/JET.jl/blob/feec5fa13586a7921a45b30d6bddd91f8ec964f1/src/analyzers/jetanalyzer.jl#L120-L122">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JET.SoundPass" href="#JET.SoundPass"><code>JET.SoundPass</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>The sound error analysis pass.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aviatesk/JET.jl/blob/feec5fa13586a7921a45b30d6bddd91f8ec964f1/src/analyzers/jetanalyzer.jl#L131-L133">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JET.TypoPass" href="#JET.TypoPass"><code>JET.TypoPass</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>A typo detection pass.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aviatesk/JET.jl/blob/feec5fa13586a7921a45b30d6bddd91f8ec964f1/src/analyzers/jetanalyzer.jl#L139-L141">source</a></section></article><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-1"><a class="tag is-link" href="#citeref-1">1</a>We used <code>target_modules</code> just for the sake of demonstration. To make it more   idiomatic, we should initialize <code>a</code> as typed vector <code>a = Int[]</code>, and then we won&#39;t   get any problem from <code>sum(a)</code> even without the <code>target_modules</code> configuration.</li><li class="footnote" id="footnote-2"><a class="tag is-link" href="#citeref-2">2</a>JET offers the framework to define your own abstract interpretation-based analysis.   See <a href="../generated-plugin-api/#AbstractAnalyzer-Framework"><code>AbstractAnalyzer</code>-Framework</a> if interested.</li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../tutorial/">« Tutorial</a><a class="docs-footer-nextpage" href="../optanalysis/">Optimization Analysis »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.1 on <span class="colophon-date" title="Tuesday 1 April 2025 15:58">Tuesday 1 April 2025</span>. Using Julia version 1.11.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
