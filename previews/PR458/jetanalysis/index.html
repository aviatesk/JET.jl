<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Error Analysis · JET.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">JET.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">README</a></li><li><a class="tocitem" href="../tutorial/">Tutorial</a></li><li><span class="tocitem">Analyses</span><ul><li class="is-active"><a class="tocitem" href>Error Analysis</a><ul class="internal"><li><a class="tocitem" href="#jetanalysis-quick-start"><span>Quick Start</span></a></li><li><a class="tocitem" href="#Errors-kinds-and-how-to-fix-them"><span>Errors kinds and how to fix them</span></a></li><li><a class="tocitem" href="#jetanalysis-entry"><span>Entry Points</span></a></li><li><a class="tocitem" href="#jetanalysis-config"><span>Configurations</span></a></li></ul></li><li><a class="tocitem" href="../optanalysis/">Optimization Analysis</a></li></ul></li><li><a class="tocitem" href="../config/">Configurations</a></li><li><a class="tocitem" href="../internals/">Internals</a></li><li><span class="tocitem"><code>AbstractAnalyzer</code> Framework</span><ul><li><a class="tocitem" href="../generated-plugin-api/">API</a></li><li><input class="collapse-toggle" id="menuitem-6-2" type="checkbox"/><label class="tocitem" for="menuitem-6-2"><span class="docs-label">Examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../generated-plugin-examples/dispatch_analysis/">Dispatch Analysis</a></li><li><a class="tocitem" href="../generated-plugin-examples/find_unstable_api/">&quot;Unstable API&quot; Analysis</a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Analyses</a></li><li class="is-active"><a href>Error Analysis</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Error Analysis</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/aviatesk/JET.jl/blob/master/docs/src/jetanalysis.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="jetanalysis"><a class="docs-heading-anchor" href="#jetanalysis">Error Analysis</a><a id="jetanalysis-1"></a><a class="docs-heading-anchor-permalink" href="#jetanalysis" title="Permalink"></a></h1><p>Julia&#39;s type system is quite expressive and its type inference is strong enough to generate fairly optimized code from a highly generic program written in a concise syntax. But as opposed to other statically-compiled languages, Julia by design does <em>not</em> error nor warn anything even if it detects possible errors during its compilation process no matter how serious they are. In essence, Julia achieves highly generic and composable programming by delaying all the errors and warnings to the runtime.</p><p>This is a core design choice of the language. On the one hand, Julia&#39;s dynamism allows it to work in places where data types can not be fully decided ahead of runtime (e.g. when the program is duck-typed with generic pieces of code, or when the program consumes some data that is only known at runtime). On the other hand, with Julia, it&#39;s not straightforward to have such modern development experiences that a static language can typically offer, as like static type checking and rich IDE features.</p><p>JET is a trial to get the best of both worlds: can we have a sufficiently useful static checking without losing all the beauty of Julia&#39;s dynamism and composability? JET&#39;s approach is very different from <a href="https://en.wikipedia.org/wiki/Gradual_typing">&quot;gradual typing&quot;</a>, that is a common technique to bring static analysis into a dynamic language, as used for e.g. <a href="https://github.com/python/mypy">mypy</a> for Python and <a href="https://www.typescriptlang.org/">TypeScript</a> for JavaScript. Rather, JET&#39;s static analysis is powered by Julia&#39;s builtin type inference system, that is based on a technique called <a href="https://en.wikipedia.org/wiki/Abstract_interpretation">&quot;abstract interpretation&quot;</a>. This way JET can analyze just a normal Julia program and smartly detect possible errors statically, without requiring any additional setups like scattering type annotations just for the sake of analysis but preserving original polymorphism and composability of the program, as effectively as the Julia compiler can optimize your Julia program.</p><h2 id="jetanalysis-quick-start"><a class="docs-heading-anchor" href="#jetanalysis-quick-start">Quick Start</a><a id="jetanalysis-quick-start-1"></a><a class="docs-heading-anchor-permalink" href="#jetanalysis-quick-start" title="Permalink"></a></h2><p>First of all, you need to install JET: JET is an ordinary Julia package, so you can install it via Julia&#39;s built-in package manager and use it as like other packages.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; ; # ] add JET # install JET via the built-in package manager</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; using JET</code><code class="nohighlight hljs ansi" style="display:block;"></code></pre><p>Let&#39;s start with the simplest example: how JET can find anything wrong with <code>sum(&quot;julia&quot;)</code>? <a href="#JET.@report_call"><code>@report_call</code></a> and <a href="#JET.report_call"><code>report_call</code></a> analyzes a given function call and report back possible problems. They can be used in a similar way as <a href="https://docs.julialang.org/en/v1/stdlib/InteractiveUtils/#InteractiveUtils.@code_typed"><code>@code_typed</code></a> and <a href="https://docs.julialang.org/en/v1/base/base/#Base.code_typed"><code>code_typed</code></a>. Those <a href="#jetanalysis-interactive-entry">interactive entry points</a> are the easiest way to use JET:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; @report_call sum(&quot;julia&quot;)</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr7">═════ 2 possible errors found ═════</span>
<span class="sgr35">┌ @ reduce.jl:564 </span>Base.:(var&quot;#sum#295&quot;)(pairs(NamedTuple()), #self#, a)
<span class="sgr35">│</span><span class="sgr34">┌ @ reduce.jl:564 </span>sum(identity, a)
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">┌ @ reduce.jl:535 </span>Base.:(var&quot;#sum#294&quot;)(pairs(NamedTuple()), #self#, f, a)
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">┌ @ reduce.jl:535 </span>mapreduce(f, Base.add_sum, a)
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">┌ @ reduce.jl:307 </span>Base.:(var&quot;#mapreduce#291&quot;)(pairs(NamedTuple()), #self#, f, op, itr)
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">┌ @ reduce.jl:307 </span>mapfoldl(f, op, itr)
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">┌ @ reduce.jl:175 </span>Base.:(var&quot;#mapfoldl#287&quot;)(Base._InitialValue(), #self#, f, op, itr)
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">┌ @ reduce.jl:175 </span>Base.mapfoldl_impl(f, op, init, itr)
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">┌ @ reduce.jl:44 </span>Base.foldl_impl(op′, nt, itr′)
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">┌ @ reduce.jl:48 </span>v = Base._foldl_impl(op, nt, itr)
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">┌ @ reduce.jl:62 </span>v = op(v, y[1])
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">┌ @ reduce.jl:86 </span>op.rf(acc, x)
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr91">┌ @ reduce.jl:24 </span>x + y
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr91">│ no matching method found `+(::Char, ::Char)`: </span><span class="sgr1">(x<span class="sgr96">::Char</span> + y<span class="sgr96">::Char</span>)</span>
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr91">└────────────────</span>
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">┌ @ reduce.jl:49 </span>Base.reduce_empty_iter(op, itr)
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">┌ @ reduce.jl:383 </span>Base.reduce_empty_iter(op, itr, Base.IteratorEltype(itr))
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">┌ @ reduce.jl:384 </span>Base.reduce_empty(op, eltype(itr))
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">┌ @ reduce.jl:360 </span>Base.reduce_empty(op.rf, T)
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">┌ @ reduce.jl:352 </span>Base.reduce_empty(+, T)
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr91">┌ @ reduce.jl:343 </span>zero(T)
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr91">│ no matching method found `zero(::Type{Char})`: </span><span class="sgr1">zero(T<span class="sgr96">::Type{Char}</span>)</span>
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr91">└─────────────────</span></code></pre><p>So JET found two possible problems. Now let&#39;s see how they can occur in <em>actual execution</em>:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; sum(&quot;julia&quot;) # will lead to `MethodError: +(::Char, ::Char)`</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: MethodError: no method matching +(::Char, ::Char)

Closest candidates are:
  +(::Any, ::Any, <span class="sgr91">::Any</span>, <span class="sgr91">::Any...</span>)
<span class="sgr90">   @</span> <span class="sgr90">Base</span> <span class="sgr90"><span class="sgr4">operators.jl:578</span></span>
  +(::T, <span class="sgr91">::Integer</span>) where T&lt;:AbstractChar
<span class="sgr90">   @</span> <span class="sgr90">Base</span> <span class="sgr90"><span class="sgr4">char.jl:237</span></span>
  +(<span class="sgr91">::Integer</span>, ::AbstractChar)
<span class="sgr90">   @</span> <span class="sgr90">Base</span> <span class="sgr90"><span class="sgr4">char.jl:247</span></span></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; sum(&quot;&quot;) # will lead to `MethodError: zero(Type{Char})`</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: MethodError: no method matching zero(::Type{Char})

Closest candidates are:
  zero(<span class="sgr91">::Union{Type{P}, P}</span>) where P&lt;:Dates.Period
<span class="sgr90">   @</span> <span class="sgr35">Dates</span> <span class="sgr90">/opt/hostedtoolcache/julia/nightly/x64/share/julia/stdlib/v1.10/Dates/src/<span class="sgr4">periods.jl:51</span></span>
  zero(<span class="sgr91">::T</span>) where T&lt;:Dates.TimeType
<span class="sgr90">   @</span> <span class="sgr35">Dates</span> <span class="sgr90">/opt/hostedtoolcache/julia/nightly/x64/share/julia/stdlib/v1.10/Dates/src/<span class="sgr4">types.jl:441</span></span>
  zero(<span class="sgr91">::LinearAlgebra.UniformScaling{T}</span>) where T
<span class="sgr90">   @</span> <span class="sgr36">LinearAlgebra</span> <span class="sgr90">/opt/hostedtoolcache/julia/nightly/x64/share/julia/stdlib/v1.10/LinearAlgebra/src/<span class="sgr4">uniformscaling.jl:135</span></span>
  ...</code></pre><p>We should note that <code>@report_call sum(&quot;julia&quot;)</code> could detect both of those two different errors that can happen at runtime. This is because <code>@report_call</code> does a static analysis — it analyzes the function call in a way that does not rely on one instance of runtime execution, but rather it reasons about all the possible executions! This is one of the biggest advantages of static analysis because other alternatives to check software qualities like &quot;testing&quot; usually rely on <em>some</em> runtime execution and they can only cover a subset of all the possible executions.</p><p>As mentioned above, JET is designed to work with <em>just a normal</em> Julia program. Let&#39;s define new arbitrary functions and run JET on it:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; function foo(s0)
           a = []
           for s in split(s0)
               push!(a, bar(s))
           end
           return sum(a)
       end</code><code class="nohighlight hljs ansi" style="display:block;">foo (generic function with 1 method)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; bar(s::String) = parse(Int, s)</code><code class="nohighlight hljs ansi" style="display:block;">bar (generic function with 1 method)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @report_call foo(&quot;1 2 3&quot;)</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr7">═════ 2 possible errors found ═════</span>
<span class="sgr91">┌ @ REPL[1]:4 </span>Main.bar(s)
<span class="sgr91">│ no matching method found `bar(::SubString{String})`: </span><span class="sgr1">Main.bar(s)</span>
<span class="sgr91">└─────────────</span>
<span class="sgr35">┌ @ REPL[1]:6 </span>Main.sum(a)
<span class="sgr35">│</span><span class="sgr34">┌ @ reducedim.jl:994 </span>Base.:(var&quot;#sum#806&quot;)(:, pairs(NamedTuple()), #self#, a)
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">┌ @ reducedim.jl:994 </span>Base._sum(a, dims)
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">┌ @ reducedim.jl:998 </span>Base.:(var&quot;#_sum#808&quot;)(pairs(NamedTuple()), #self#, a, _3)
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">┌ @ reducedim.jl:998 </span>Base._sum(identity, a, :)
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">┌ @ reducedim.jl:999 </span>Base.:(var&quot;#_sum#809&quot;)(pairs(NamedTuple()), #self#, f, a, _4)
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">┌ @ reducedim.jl:999 </span>mapreduce(f, Base.add_sum, a)
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">┌ @ reducedim.jl:357 </span>Base.:(var&quot;#mapreduce#799&quot;)(:, Base._InitialValue(), #self#, f, op, A)
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">┌ @ reducedim.jl:357 </span>Base._mapreduce_dim(f, op, init, A, dims)
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">┌ @ reducedim.jl:365 </span>Base._mapreduce(f, op, IndexStyle(A), A)
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">┌ @ reduce.jl:432 </span>Base.mapreduce_empty_iter(f, op, A, Base.IteratorEltype(A))
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">┌ @ reduce.jl:380 </span>Base.reduce_empty_iter(Base.MappingRF(f, op), itr, ItrEltype)
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">┌ @ reduce.jl:384 </span>Base.reduce_empty(op, eltype(itr))
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">┌ @ reduce.jl:361 </span>Base.mapreduce_empty(op.f, op.rf, T)
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">┌ @ reduce.jl:372 </span>Base.reduce_empty(op, T)
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">┌ @ reduce.jl:352 </span>Base.reduce_empty(+, T)
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">┌ @ reduce.jl:343 </span>zero(T)
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr91">┌ @ missing.jl:106 </span>Base.throw(Base.MethodError(zero, tuple(Base.Any)))
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr91">│ MethodError: no method matching zero(::Type{Any}): </span><span class="sgr1">Base.throw(Base.MethodError(zero, tuple(Base.Any)<span class="sgr96">::Tuple{DataType}</span>)<span class="sgr96">::MethodError</span>)</span>
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr91">└──────────────────</span></code></pre><p>Now let&#39;s fix this problematic code. First, we can fix the definition of <code>bar</code> so that it accepts generic <code>AbstractString</code> input. JET&#39;s analysis result can be dynamically updated when we refine a function definition, and so we just need to add a new <code>bar(::AbstractString)</code> definition. As for the second error, let&#39;s assume, for some reason, we&#39;re not interested in fixing it and we want to ignore errors that may happen within <code>Base</code>. Then we can use the <a href="../config/#result-config"><code>target_modules</code></a> configuration to limit the analysis scope to the current module context to ignore the possible error that may happen within <code>sum(a)</code><sup class="footnote-reference"><a id="citeref-1" href="#footnote-1">[1]</a></sup>.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; # hot fix the definition of `bar`
       bar(s::AbstractString) = parse(Int, s)</code><code class="nohighlight hljs ansi" style="display:block;">bar (generic function with 2 methods)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; # now no errors should be reported !
       @report_call target_modules=(@__MODULE__,) foo(&quot;1 2 3&quot;)</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr92">No errors detected</span></code></pre><p>So far, we have used the default error analysis pass, which collects problems according to one specific (somewhat opinionated) definition of &quot;errors&quot; (see the <a href="#JET.BasicPass"><code>JET.BasicPass</code></a> for more details). JET offers other error reporting passes, including the &quot;sound&quot; error detection (<a href="#JET.SoundPass"><code>JET.SoundPass</code></a>) as well as the simpler &quot;typo&quot; detection pass (<a href="#JET.TypoPass"><code>JET.TypoPass</code></a>)<sup class="footnote-reference"><a id="citeref-2" href="#footnote-2">[2]</a></sup>. They can be switched using the <code>mode</code> configuration:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; function myifelse(cond, a, b)
           if cond
               return a
           else
               return b
           end
       end</code><code class="nohighlight hljs ansi" style="display:block;">myifelse (generic function with 1 method)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; # the default analysis pass doesn&#39;t report &quot;non-boolean (T) used in boolean context&quot; error
       # as far as there is a possibility when the condition &quot;can&quot; be bool (NOTE: Bool &lt;: Integer)
       report_call(myifelse, (Integer, Int, Int))</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr92">No errors detected</span></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; # the sound analyzer doesn&#39;t permit such a case: it requires the type of a conditional value to be `Bool` strictly
       report_call(myifelse, (Integer, Int, Int); mode=:sound)</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr7">═════ 1 possible error found ═════</span>
<span class="sgr91">┌ @ REPL[1]:2 </span>goto %3 if not cond
<span class="sgr91">│ non-boolean `Integer` may be used in boolean context: </span><span class="sgr1">goto %3 if not cond<span class="sgr96">::Integer</span></span>
<span class="sgr91">└─────────────</span></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; function strange_sum(a)
           if rand(Bool)
               undefsum(a)
           else
               sum(a)
           end
       end</code><code class="nohighlight hljs ansi" style="display:block;">strange_sum (generic function with 1 method)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; # the default analysis pass will report both problems:
       # - `undefsum` is not defined
       # - `sum(a::Vector{Any})` can throw when `a` is empty
       @report_call strange_sum([])</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr7">═════ 2 possible errors found ═════</span>
<span class="sgr91">┌ @ REPL[4]:3 </span>Main.undefsum(a)
<span class="sgr91">│ `Main.undefsum` is not defined</span>
<span class="sgr91">└─────────────</span>
<span class="sgr35">┌ @ REPL[4]:5 </span>Main.sum(a)
<span class="sgr35">│</span><span class="sgr34">┌ @ reducedim.jl:994 </span>Base.:(var&quot;#sum#806&quot;)(:, pairs(NamedTuple()), #self#, a)
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">┌ @ reducedim.jl:994 </span>Base._sum(a, dims)
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">┌ @ reducedim.jl:998 </span>Base.:(var&quot;#_sum#808&quot;)(pairs(NamedTuple()), #self#, a, _3)
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">┌ @ reducedim.jl:998 </span>Base._sum(identity, a, :)
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">┌ @ reducedim.jl:999 </span>Base.:(var&quot;#_sum#809&quot;)(pairs(NamedTuple()), #self#, f, a, _4)
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">┌ @ reducedim.jl:999 </span>mapreduce(f, Base.add_sum, a)
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">┌ @ reducedim.jl:357 </span>Base.:(var&quot;#mapreduce#799&quot;)(:, Base._InitialValue(), #self#, f, op, A)
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">┌ @ reducedim.jl:357 </span>Base._mapreduce_dim(f, op, init, A, dims)
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">┌ @ reducedim.jl:365 </span>Base._mapreduce(f, op, IndexStyle(A), A)
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">┌ @ reduce.jl:432 </span>Base.mapreduce_empty_iter(f, op, A, Base.IteratorEltype(A))
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">┌ @ reduce.jl:380 </span>Base.reduce_empty_iter(Base.MappingRF(f, op), itr, ItrEltype)
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">┌ @ reduce.jl:384 </span>Base.reduce_empty(op, eltype(itr))
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">┌ @ reduce.jl:361 </span>Base.mapreduce_empty(op.f, op.rf, T)
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">┌ @ reduce.jl:372 </span>Base.reduce_empty(op, T)
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">┌ @ reduce.jl:352 </span>Base.reduce_empty(+, T)
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">┌ @ reduce.jl:343 </span>zero(T)
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr91">┌ @ missing.jl:106 </span>Base.throw(Base.MethodError(zero, tuple(Base.Any)))
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr91">│ MethodError: no method matching zero(::Type{Any}): </span><span class="sgr1">Base.throw(Base.MethodError(zero, tuple(Base.Any)<span class="sgr96">::Tuple{DataType}</span>)<span class="sgr96">::MethodError</span>)</span>
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr91">└──────────────────</span></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; # the typo detection pass will only report the &quot;typo&quot;
       @report_call mode=:typo strange_sum([])</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr7">═════ 1 possible error found ═════</span>
<span class="sgr91">┌ @ REPL[4]:3 </span>Main.undefsum(a)
<span class="sgr91">│ `Main.undefsum` is not defined</span>
<span class="sgr91">└─────────────</span></code></pre><p>We can use <a href="#JET.@test_call"><code>@test_call</code></a> and <a href="#JET.test_call"><code>test_call</code></a> to assert that your program is free from problems that <code>@report_call</code> can detect. They work nicely with <a href="https://docs.julialang.org/en/v1/stdlib/Test/"><code>Test</code> standard library</a>&#39;s unit-testing infrastructure:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; @test_call target_modules=(@__MODULE__,) foo(&quot;1 2 3&quot;)</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr32"><span class="sgr1">Test Passed</span></span></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; using Test</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; # we can get the nice summery using `@testset` !
       @testset &quot;JET testset&quot; begin
           @test_call target_modules=(@__MODULE__,) foo(&quot;1 2 3&quot;) # should pass
       
           test_call(myifelse, (Integer, Int, Int); mode=:sound)
       
           @test_call broken=true foo(&quot;1 2 3&quot;) # `broken` and `skip` options are supported
       
           @test foo(&quot;1 2 3&quot;) == 6 # of course other `Test` macros can be used in the same place
       end</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr37">JET testset: </span><span class="sgr91"><span class="sgr1">JET-test failed</span></span> at <span class="sgr1">/home/runner/work/JET.jl/JET.jl/src/JET.jl:1502</span>
  Expression: (JET.test_call)(Main.myifelse, (Integer, Int64, Int64); mode = sound)
  <span class="sgr7">═════ 1 possible error found ═════</span>
  <span class="sgr91">┌ @ REPL[1]:2 </span>goto %3 if not cond
  <span class="sgr91">│ non-boolean `Integer` may be used in boolean context: </span><span class="sgr1">goto %3 if not cond<span class="sgr96">::Integer</span></span>
  <span class="sgr91">└─────────────</span>
  
<span class="sgr1">Test Summary: | <span class="sgr32">Pass  </span><span class="sgr91">Fail  </span><span class="sgr33">Broken  </span><span class="sgr36">Total  </span>Time</span>
JET testset   | <span class="sgr32">   2  </span><span class="sgr91">   1  </span><span class="sgr33">     1  </span><span class="sgr36">    4  </span>2.5s
ERROR: <span class="sgr91">Some tests did not pass: 2 passed, 1 failed, 0 errored, 1 broken.</span></code></pre><p>JET uses JET itself in its test pipeline: JET&#39;s static analysis has been proven to be very useful and helped its development a lot. If interested, take a peek at <a href="https://github.com/aviatesk/JET.jl/blob/master/test/runtests.jl">JET&#39;s <code>&quot;self check !!!&quot;</code> testset</a>.</p><p>Lastly, let&#39;s see the example that demonstrates JET can analyze a &quot;top-level&quot; program. The top-level analysis should be considered as a somewhat experimental feature, and at this moment you may need additional configurations to run it correctly. Please read the descriptions of <a href="#jetanalysis-toplevel-entry">top-level entry points</a> and choose an appropriate entry point for your use case. Here we run <a href="#JET.report_file"><code>report_file</code></a> on <a href="https://github.com/aviatesk/JET.jl/blob/master/demo.jl">demo.jl</a>. It automatically extracts and loads &quot;definitions&quot; of functions, structs and such, and then analyzes their &quot;usages&quot; statically:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; report_file(normpath(Base.pkgdir(JET), &quot;demo.jl&quot;))</code><code class="nohighlight hljs ansi" style="display:block;">[toplevel-info] virtualized the context of Main (took 0.023 sec)
[toplevel-info] entered into /home/runner/work/JET.jl/JET.jl/demo.jl
[toplevel-info]  exited from /home/runner/work/JET.jl/JET.jl/demo.jl (took 0.814 sec)
<span class="sgr7">═════ 7 possible errors found ═════</span>
<span class="sgr91">┌ @ /home/runner/work/JET.jl/JET.jl/demo.jl:9 </span>fib(m)
<span class="sgr91">│ `m` is not defined</span>
<span class="sgr91">└─────────────────────────────────────────────</span>
<span class="sgr35">┌ @ /home/runner/work/JET.jl/JET.jl/demo.jl:10 </span>fib(&quot;1000&quot;)
<span class="sgr35">│</span><span class="sgr34">┌ @ /home/runner/work/JET.jl/JET.jl/demo.jl:6 </span>n :≤ 2
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">┌ @ operators.jl:392 </span>x &lt; y
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr91">┌ @ operators.jl:343 </span>isless(x, y)
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr91">│ no matching method found `isless(::String, ::Int64)`: </span><span class="sgr1">isless(x<span class="sgr96">::String</span>, y<span class="sgr96">::Int64</span>)</span>
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr91">└────────────────────</span>
<span class="sgr35">┌ @ /home/runner/work/JET.jl/JET.jl/demo.jl:28 </span>foo(1.2)
<span class="sgr35">│</span><span class="sgr34">┌ @ /home/runner/work/JET.jl/JET.jl/demo.jl:20 </span>bar(v)
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">┌ @ /home/runner/work/JET.jl/JET.jl/demo.jl:25 </span>v.fdl
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr91">┌ @ Base.jl:37 </span>Base.getfield(x, f)
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr91">│ type Ty{Float64} has no field fdl</span>
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr91">└──────────────</span>
<span class="sgr35">┌ @ /home/runner/work/JET.jl/JET.jl/demo.jl:29 </span>foo(&quot;1&quot;)
<span class="sgr35">│</span><span class="sgr34">┌ @ /home/runner/work/JET.jl/JET.jl/demo.jl:20 </span>bar(v)
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr91">┌ @ /home/runner/work/JET.jl/JET.jl/demo.jl:26 </span>convert(Number, v.fld)
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr91">│ no matching method found `convert(::Type{Number}, ::String)`: </span><span class="sgr1">convert(Number, (v<span class="sgr96">::Ty{String}</span>).fld<span class="sgr96">::String</span>)</span>
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr91">└──────────────────────────────────────────────</span>
<span class="sgr35">┌ @ /home/runner/work/JET.jl/JET.jl/demo.jl:40 </span>badmerge(NamedTuple{(:x, :y)}(tuple(1, 2)), NamedTuple{(:y, :z)}(tuple(3, 1)))
<span class="sgr35">│</span><span class="sgr91">┌ @ /home/runner/work/JET.jl/JET.jl/demo.jl:33 </span>getfield(a, x)
<span class="sgr35">│</span><span class="sgr91">│ `x` is not defined</span>
<span class="sgr35">│</span><span class="sgr91">└──────────────────────────────────────────────</span>
<span class="sgr35">│</span><span class="sgr91">┌ @ /home/runner/work/JET.jl/JET.jl/demo.jl:33 </span>getfield(b, y)
<span class="sgr35">│</span><span class="sgr91">│ `y` is not defined</span>
<span class="sgr35">│</span><span class="sgr91">└──────────────────────────────────────────────</span>
<span class="sgr35">│</span><span class="sgr91">┌ @ /home/runner/work/JET.jl/JET.jl/demo.jl:33 </span>getfield(b, z)
<span class="sgr35">│</span><span class="sgr91">│ `z` is not defined</span>
<span class="sgr35">│</span><span class="sgr91">└──────────────────────────────────────────────</span></code></pre><h2 id="Errors-kinds-and-how-to-fix-them"><a class="docs-heading-anchor" href="#Errors-kinds-and-how-to-fix-them">Errors kinds and how to fix them</a><a id="Errors-kinds-and-how-to-fix-them-1"></a><a class="docs-heading-anchor-permalink" href="#Errors-kinds-and-how-to-fix-them" title="Permalink"></a></h2><h3 id="no-matching-method-found"><a class="docs-heading-anchor" href="#no-matching-method-found"><code>no matching method found</code></a><a id="no-matching-method-found-1"></a><a class="docs-heading-anchor-permalink" href="#no-matching-method-found" title="Permalink"></a></h3><h4 id="Description"><a class="docs-heading-anchor" href="#Description">Description</a><a id="Description-1"></a><a class="docs-heading-anchor-permalink" href="#Description" title="Permalink"></a></h4><p>This error occurs when running the code might throw a <code>MethodError</code> at runtime. Similar to normal <code>MethodErrors</code>, this happens if a function is being called without a method matching the given argument types.</p><p>This is the most common error detected in most Julia code.</p><h4 id="Example"><a class="docs-heading-anchor" href="#Example">Example</a><a id="Example-1"></a><a class="docs-heading-anchor-permalink" href="#Example" title="Permalink"></a></h4><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; f(x::Integer) = x + one(x);</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; g(x) = f(x);</code><code class="nohighlight hljs ansi" style="display:block;"></code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @report_call g(1.0)</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr7">═════ 1 possible error found ═════</span>
<span class="sgr91">┌ @ REPL[2]:1 </span>Main.f(x)
<span class="sgr91">│ no matching method found `f(::Float64)`: </span><span class="sgr1">Main.f(x<span class="sgr96">::Float64</span>)</span>
<span class="sgr91">└─────────────</span></code></pre><h4 id="How-to-fix"><a class="docs-heading-anchor" href="#How-to-fix">How to fix</a><a id="How-to-fix-1"></a><a class="docs-heading-anchor-permalink" href="#How-to-fix" title="Permalink"></a></h4><p>This error indicates some kind of type error in your code. You fix it like you would fix a regular <code>MethodError</code> thrown at runtime.</p><h3 id="no-matching-method-found-(x/y-union-split)"><a class="docs-heading-anchor" href="#no-matching-method-found-(x/y-union-split)"><code>no matching method found (x/y union split)</code></a><a id="no-matching-method-found-(x/y-union-split)-1"></a><a class="docs-heading-anchor-permalink" href="#no-matching-method-found-(x/y-union-split)" title="Permalink"></a></h3><h4 id="Description-2"><a class="docs-heading-anchor" href="#Description-2">Description</a><a class="docs-heading-anchor-permalink" href="#Description-2" title="Permalink"></a></h4><p>This error occurs when a variable <code>x</code> is inferred to be a union type, and <code>x</code> being one or more of the union&#39;s members would lead to a <code>MethodError</code>. For example, if the compiler infers <code>x</code> to be of type <code>Union{A, B}</code>, and then a function <code>f(x)</code> is called which would lead to a <code>MethodError</code> if <code>x</code> is a <code>A</code>, this error would occur.</p><p>More technically, this happens when one or more branches created by the compiler through union splitting contains a <code>no matching method found</code> error.</p><h4 id="Example-2"><a class="docs-heading-anchor" href="#Example-2">Example</a><a class="docs-heading-anchor-permalink" href="#Example-2" title="Permalink"></a></h4><p>Minimal example:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; struct Foo
           x::Union{Int, String}
       end</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; # Errors if x.x isa String.
       # The compiler doesn&#39;t know if it&#39;s a String or Int
       f(x) = x.x + 1;</code><code class="nohighlight hljs ansi" style="display:block;"></code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @report_call f(Foo(1))</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr7">═════ 1 possible error found ═════</span>
<span class="sgr91">┌ @ REPL[2]:1 </span>x.x Main.:+ 1
<span class="sgr91">│ no matching method found `+(::String, ::Int64)` (1/2 union split): </span><span class="sgr1">((x<span class="sgr96">::Main.Foo</span>).x<span class="sgr96">::Union{Int64, String}</span> Main.:+ 1)</span>
<span class="sgr91">└─────────────</span></code></pre><p>More common example:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; function pos_after_tab(v::AbstractArray{UInt8})
           # findfirst can return `nothing` on no match
           p = findfirst(isequal(UInt8(&#39;\t&#39;)), v)
           p + 1
       end</code><code class="nohighlight hljs ansi" style="display:block;">pos_after_tab (generic function with 1 method)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @report_call pos_after_tab(codeunits(&quot;a\tb&quot;))</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr7">═════ 1 possible error found ═════</span>
<span class="sgr91">┌ @ REPL[1]:4 </span>p Main.:+ 1
<span class="sgr91">│ no matching method found `+(::Nothing, ::Int64)` (1/2 union split): </span><span class="sgr1">(p Main.:+ 1)</span>
<span class="sgr91">└─────────────</span></code></pre><h4 id="How-to-fix-2"><a class="docs-heading-anchor" href="#How-to-fix-2">How to fix</a><a class="docs-heading-anchor-permalink" href="#How-to-fix-2" title="Permalink"></a></h4><p>This error is unique in that idiomatic Julia code may still lead to this error. For example, in the <code>pos_after_tab</code> function above, if the input vector does not have a <code>&#39;\t&#39;</code> byte, <code>p</code> will be <code>nothing</code>, and a <code>MethodError</code> will be thrown when <code>nothing + 1</code> is attempted. However, in many situations, the possibility of such a <code>MethodError</code> is not a mistake, but rather an idiomatic way of erroring.</p><p>There are different possiblities to address this kind of error. Let&#39;s take the <code>pos_after_tab</code> example:</p><p>If you actually <em>could</em> expect <code>p</code> to legitimately be <code>nothing</code> for valid input (i.e. the input could lack a <code>&#39;\t&#39;</code> byte), then your function should be written to take this edge case into account:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; function pos_after_tab(v::AbstractArray{UInt8})
           p = findfirst(isequal(UInt8(&#39;\t&#39;)), v)
           if p === nothing # handle the nothing case
               return nothing
           else
               return p + 1
           end
       end;</code><code class="nohighlight hljs ansi" style="display:block;"></code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @report_call pos_after_tab(codeunits(&quot;a\tb&quot;))</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr92">No errors detected</span></code></pre><p>By adding the <code>if p === nothing</code> check, the compiler will know that the type of <code>p</code> must be <code>Nothing</code> inside the <code>if</code> block, and <code>Int</code> in the <code>else</code> block. This way, the compiler knows a <code>MethodError</code> is not possible, and the error will disappear.</p><p>If you expect a <code>&#39;\t&#39;</code> byte to always be present, such that <code>findfirst</code> always should return an <code>Int</code> for valid input, you can add a typeassert in the function to assert that the return value of <code>findfirst</code> must be, say, an <code>Integer</code>. Then, the compiler will know that if the typeassert passes, the value returned by <code>findfirst</code> cannot be <code>nothing</code> (and hence in this case must be <code>Int</code>):</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; function pos_after_tab(v::AbstractArray{UInt8})
           p = findfirst(isequal(UInt8(&#39;\t&#39;)), v)::Integer
           p + 1
       end;</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @report_call pos_after_tab(codeunits(&quot;a\tb&quot;))</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr92">No errors detected</span></code></pre><p>The code will still error at runtime due to the typeassert if <code>findfirst</code> returns <code>nothing</code>, but JET will no longer detect it as an error, because the programmer, by adding the typeassert, explicitly acknowledge that the compiler&#39;s inference may not be precise enough, and helps the compiler.</p><p>Note that adding a typeassert also improves code quality:</p><ul><li>The programmer&#39;s intent to never observe <code>nothing</code> is communicated clearly</li><li>After the typeassert passes, <code>p</code> is inferred to be <code>Int</code> instead of a union, and this more precise type inference generates more efficient code.</li><li>More precise inference reduces the risk of invalidations from the code, improving latency.</li></ul><p>A special case occurs when loading <code>Union</code>-typed fields from structs. Julia does not realize that loading the same field multiple times from a mutable struct necessarily returns the same object. Hence, in the following example:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; mutable struct Foo
           x::Union{Int, Nothing}
       end</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; function f(x)
           if x.x === nothing
               nothing
           else
               x.x + 1
           end
       end;</code><code class="nohighlight hljs ansi" style="display:block;"></code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @report_call f(Foo(1))</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr7">═════ 1 possible error found ═════</span>
<span class="sgr91">┌ @ REPL[2]:5 </span>x.x Main.:+ 1
<span class="sgr91">│ no matching method found `+(::Nothing, ::Int64)` (1/2 union split): </span><span class="sgr1">((x<span class="sgr96">::Main.Foo</span>).x<span class="sgr96">::Union{Nothing, Int64}</span> Main.:+ 1)</span>
<span class="sgr91">└─────────────</span></code></pre><p>We might reasonably expect the compiler to know that in the <code>else</code> branch, <code>x.x</code> must be an <code>Int</code>, since it just checked that it is not <code>nothing</code>. However, the compiler does not know that the value obtained from loading the <code>x</code> field in the expression <code>x.x</code> on the like with the if statement in this case is the same value as the value obtained when loading the <code>x</code> field in the <code>x.x + 1</code> statement<sup class="footnote-reference"><a id="citeref-3" href="#footnote-3">[3]</a></sup>. You can solve this issue by assigning <code>x.x</code> to a variable:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; function f(x)
           y = x.x
           if y === nothing
               nothing
           else
               y + 1
           end
       end;</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @report_call f(Foo(1))</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr92">No errors detected</span></code></pre><h3 id="X-is-not-defined"><a class="docs-heading-anchor" href="#X-is-not-defined"><code>X is not defined</code></a><a id="X-is-not-defined-1"></a><a class="docs-heading-anchor-permalink" href="#X-is-not-defined" title="Permalink"></a></h3><h4 id="Description-3"><a class="docs-heading-anchor" href="#Description-3">Description</a><a class="docs-heading-anchor-permalink" href="#Description-3" title="Permalink"></a></h4><p>This happens when a name <code>X</code> is used in a function, but no object named <code>X</code> can be found.</p><h4 id="Example-3"><a class="docs-heading-anchor" href="#Example-3">Example</a><a class="docs-heading-anchor-permalink" href="#Example-3" title="Permalink"></a></h4><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; f(x) = foo(x) + 1;</code><code class="nohighlight hljs ansi" style="display:block;"></code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @report_call f(1)</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr7">═════ 1 possible error found ═════</span>
<span class="sgr91">┌ @ REPL[1]:1 </span>Main.foo(x)
<span class="sgr91">│ `Main.foo` is not defined</span>
<span class="sgr91">└─────────────</span></code></pre><h4 id="How-to-fix-3"><a class="docs-heading-anchor" href="#How-to-fix-3">How to fix</a><a class="docs-heading-anchor-permalink" href="#How-to-fix-3" title="Permalink"></a></h4><p>This error can have a couple of causes:</p><ul><li><code>X</code> is misspelled. If so, correct the typo</li><li><code>X</code> exists, but cannot be reached from the scope of the function. If so, pass it in as an argument to the offending function.</li></ul><h3 id="type-T-has-no-field-F"><a class="docs-heading-anchor" href="#type-T-has-no-field-F"><code>type T has no field F</code></a><a id="type-T-has-no-field-F-1"></a><a class="docs-heading-anchor-permalink" href="#type-T-has-no-field-F" title="Permalink"></a></h3><h4 id="Description-4"><a class="docs-heading-anchor" href="#Description-4">Description</a><a class="docs-heading-anchor-permalink" href="#Description-4" title="Permalink"></a></h4><p>This error occurs when <code>Core.getfield</code> is (indirectly) called with a nonexisting and hardcoded field name. For example, if an object have a field called <code>vec</code> and you type it <code>vector</code>.</p><h4 id="Example-4"><a class="docs-heading-anchor" href="#Example-4">Example</a><a class="docs-heading-anchor-permalink" href="#Example-4" title="Permalink"></a></h4><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; struct Foo
           my_field
       end</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; f(x) = x.my_feild; # NB: Typo!</code><code class="nohighlight hljs ansi" style="display:block;"></code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @report_call f(Foo(1))</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr7">═════ 1 possible error found ═════</span>
<span class="sgr35">┌ @ REPL[2]:1 </span>x.my_feild
<span class="sgr35">│</span><span class="sgr91">┌ @ Base.jl:37 </span>Base.getfield(x, f)
<span class="sgr35">│</span><span class="sgr91">│ type Main.Foo has no field my_feild</span>
<span class="sgr35">│</span><span class="sgr91">└──────────────</span></code></pre><h4 id="How-to-fix-4"><a class="docs-heading-anchor" href="#How-to-fix-4">How to fix</a><a class="docs-heading-anchor-permalink" href="#How-to-fix-4" title="Permalink"></a></h4><p>This error often occurs when the field name is mistyped. Correct the typo.</p><h3 id="BoundsError:-Attempt-to-access-T-at-index-[i]"><a class="docs-heading-anchor" href="#BoundsError:-Attempt-to-access-T-at-index-[i]"><code>BoundsError: Attempt to access T at index [i]</code></a><a id="BoundsError:-Attempt-to-access-T-at-index-[i]-1"></a><a class="docs-heading-anchor-permalink" href="#BoundsError:-Attempt-to-access-T-at-index-[i]" title="Permalink"></a></h3><h4 id="Description-5"><a class="docs-heading-anchor" href="#Description-5">Description</a><a class="docs-heading-anchor-permalink" href="#Description-5" title="Permalink"></a></h4><p>This error occurs when it is known at compile time that the call will throw a <code>BoundsError</code>. Note that most <code>BoundsErrors</code> cannot be predicted at compile time. For the compiler to know a function attempts to access a container out of bounds, both the container length and the index value must be known at compiletime. Hence, the error is detected for a <code>Tuple</code> input in the example below, but not for a <code>Vector</code> input.</p><h4 id="Example-5"><a class="docs-heading-anchor" href="#Example-5">Example</a><a class="docs-heading-anchor-permalink" href="#Example-5" title="Permalink"></a></h4><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; get_fourth(x) = x[4]</code><code class="nohighlight hljs ansi" style="display:block;">get_fourth (generic function with 1 method)</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @report_call get_fourth((1,2,3))</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr7">═════ 1 possible error found ═════</span>
<span class="sgr35">┌ @ REPL[1]:1 </span>x[4]
<span class="sgr35">│</span><span class="sgr91">┌ @ tuple.jl:31 </span>Base.getfield(t, i, $(Expr(:boundscheck)))
<span class="sgr35">│</span><span class="sgr91">│ BoundsError: attempt to access Tuple{Int64, Int64, Int64} at index [4]</span>
<span class="sgr35">│</span><span class="sgr91">└───────────────</span></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @report_call get_fourth([1,2,3]) # NB: False negative!</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr92">No errors detected</span></code></pre><h4 id="How-to-fix-5"><a class="docs-heading-anchor" href="#How-to-fix-5">How to fix</a><a class="docs-heading-anchor-permalink" href="#How-to-fix-5" title="Permalink"></a></h4><p>If this error appears, the offending code uses a bad index. Since the error most often occurs when the index is hardcoded, simply fix the index value.</p><h3 id="may-throw-[...]"><a class="docs-heading-anchor" href="#may-throw-[...]"><code>may throw [...]</code></a><a id="may-throw-[...]-1"></a><a class="docs-heading-anchor-permalink" href="#may-throw-[...]" title="Permalink"></a></h3><h4 id="Description-6"><a class="docs-heading-anchor" href="#Description-6">Description</a><a class="docs-heading-anchor-permalink" href="#Description-6" title="Permalink"></a></h4><p>This error indicates that JET detected the possibility of an exception. By default, JET will not report this error, unless a function is inferred to <em>always</em> throw, AND the exception is not caught in a try statement. In &quot;sound&quot; mode, this error is reported if the function <em>may</em> throw.</p><h4 id="Example-6"><a class="docs-heading-anchor" href="#Example-6">Example</a><a class="docs-heading-anchor-permalink" href="#Example-6" title="Permalink"></a></h4><p>In this example, the function is known at compile time to throw an uncaught exception, and so is reported by default:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; f(x) = x isa Integer ? throw(&quot;Integer&quot;) : nothing;</code><code class="nohighlight hljs ansi" style="display:block;"></code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @report_call f(1)</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr7">═════ 1 possible error found ═════</span>
<span class="sgr91">┌ @ REPL[1]:1 </span>Main.f(::Int64)
<span class="sgr91">│ may throw: </span><span class="sgr1">Main.throw(&quot;Integer&quot;)</span>
<span class="sgr91">└─────────────</span></code></pre><p>In this example, it&#39;s not known at compile time whether it throws, and therefore, JET reports no errors by default. In sound mode, the error is reported.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; f(x) = x == 9873984732 ? nothing : throw(&quot;Bad value&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">f (generic function with 1 method)</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @report_call f(1)</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr92">No errors detected</span></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @report_call mode=:sound f(1)</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr7">═════ 1 possible error found ═════</span>
<span class="sgr91">┌ @ REPL[1]:1 </span>Main.f(::Int64)
<span class="sgr91">│ may throw: </span><span class="sgr1">Main.throw(&quot;Bad value&quot;)</span>
<span class="sgr91">└─────────────</span></code></pre><p>In this example, the exception is handled, so JET reports no errors by default. In sound mode, the error is reported:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; g() = throw();</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; f() = try
           g()
       catch
           nothing
       end;</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; f()</code><code class="nohighlight hljs ansi" style="display:block;"></code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @report_call f()</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr92">No errors detected</span></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @report_call mode=:sound f()</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr7">═════ 1 possible error found ═════</span>
<span class="sgr35">┌ @ REPL[2]:2 </span>Main.g()
<span class="sgr35">│</span><span class="sgr91">┌ @ REPL[1]:1 </span>Main.g()
<span class="sgr35">│</span><span class="sgr91">│ may throw: </span><span class="sgr1">Main.throw()</span>
<span class="sgr35">│</span><span class="sgr91">└─────────────</span></code></pre><h2 id="jetanalysis-entry"><a class="docs-heading-anchor" href="#jetanalysis-entry">Entry Points</a><a id="jetanalysis-entry-1"></a><a class="docs-heading-anchor-permalink" href="#jetanalysis-entry" title="Permalink"></a></h2><h3 id="jetanalysis-interactive-entry"><a class="docs-heading-anchor" href="#jetanalysis-interactive-entry">Interactive Entry Points</a><a id="jetanalysis-interactive-entry-1"></a><a class="docs-heading-anchor-permalink" href="#jetanalysis-interactive-entry" title="Permalink"></a></h3><p>JET offers interactive analysis entry points that can be used similarly to <a href="https://docs.julialang.org/en/v1/base/base/#Base.code_typed"><code>code_typed</code></a> and its family:</p><article class="docstring"><header><a class="docstring-binding" id="JET.@report_call" href="#JET.@report_call"><code>JET.@report_call</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@report_call [jetconfigs...] f(args...)</code></pre><p>Evaluates the arguments to the function call, determines its types, and then calls <a href="#JET.report_call"><code>report_call</code></a> on the resulting expression. As with <code>@code_typed</code> and its family, any of <a href="../config/#JET-configurations">JET configurations</a> can be given as the optional arguments like this:</p><pre><code class="language-julia-repl hljs"># reports `rand(::Type{Bool})` with `aggressive_constant_propagation` configuration turned off
julia&gt; @report_call aggressive_constant_propagation=false rand(Bool)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aviatesk/JET.jl/blob/51de5545fb6f2968cb57d5ec7d362531d257e424/src/JET.jl#L1290-L1301">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JET.report_call" href="#JET.report_call"><code>JET.report_call</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">report_call(f, [types];
            analyzer::Type{&lt;:AbstractAnalyzer} = JETAnalyzer,
            jetconfigs...) -&gt; JETCallResult
report_call(tt::Type{&lt;:Tuple};
            analyzer::Type{&lt;:AbstractAnalyzer} = JETAnalyzer,
            jetconfigs...) -&gt; JETCallResult</code></pre><p>Analyzes the generic function call with the given type signature with <code>analyzer</code>. And finally returns the analysis result as <a href="../internals/#JET.JETCallResult"><code>JETCallResult</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aviatesk/JET.jl/blob/51de5545fb6f2968cb57d5ec7d362531d257e424/src/JET.jl#L1306-L1316">source</a></section></article><h3 id="jetanalysis-test-integration"><a class="docs-heading-anchor" href="#jetanalysis-test-integration"><code>Test</code> Integration</a><a id="jetanalysis-test-integration-1"></a><a class="docs-heading-anchor-permalink" href="#jetanalysis-test-integration" title="Permalink"></a></h3><p>JET also exports entries that are fully integrated with <a href="https://docs.julialang.org/en/v1/stdlib/Test/"><code>Test</code> standard library</a>&#39;s unit-testing infrastructure. It can be used in your test suite to assert your program is free from errors that JET can detect:</p><article class="docstring"><header><a class="docstring-binding" id="JET.@test_call" href="#JET.@test_call"><code>JET.@test_call</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@test_call [jetconfigs...] [broken=false] [skip=false] f(args...)</code></pre><p>Runs <a href="#JET.@report_call"><code>@report_call jetconfigs... f(args...)</code></a> and tests that the generic function call <code>f(args...)</code> is free from problems that <code>@report_call</code> can detect. If executed inside <code>@testset</code>, returns a <code>Pass</code> result if it is, a <code>Fail</code> result if it contains any error points detected, or an <code>Error</code> result if this macro encounters an unexpected error. When the test <code>Fail</code>s, abstract call stack to each problem location will also be printed to <code>stdout</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; @test_call sincos(10)
Test Passed
  Expression: #= none:1 =# JET.@test_call sincos(10)</code></pre><p>As with <a href="#JET.@report_call"><code>@report_call</code></a>, any of <a href="https://aviatesk.github.io/JET.jl/dev/config/">JET configurations</a> or analyzer specific configurations can be given as the optional arguments <code>jetconfigs...</code> like this:</p><pre><code class="language-julia-repl hljs">julia&gt; cond = false

julia&gt; function f(n)
           # `cond` is untyped, and will be reported by the sound analysis pass,
           # while JET&#39;s default analysis pass will ignore it
           if cond
               return sin(n)
           else
               return cos(n)
           end
       end;

julia&gt; @test_call f(10)
Test Passed
  Expression: #= none:1 =# JET.@test_call f(10)

julia&gt; @test_call mode=:sound f(10)
JET-test failed at none:1
  Expression: #= none:1 =# JET.@test_call mode = :sound f(10)
  ═════ 1 possible error found ═════
  ┌ @ none:2 goto %4 if not cond
  │ non-boolean (Any) used in boolean context: goto %4 if not cond
  └──────────

ERROR: There was an error during testing</code></pre><p><code>@test_call</code> is fully integrated with <a href="https://docs.julialang.org/en/v1/stdlib/Test/"><code>Test</code> standard library</a>&#39;s unit-testing infrastructure. It means, the result of <code>@test_call</code> will be included in the final <code>@testset</code> summary, it supports <code>skip</code> and <code>broken</code> annotations as like <code>@test</code> and its family:</p><pre><code class="language-julia-repl hljs">julia&gt; using JET, Test

# Julia can&#39;t propagate the type constraint `ref[]::Number` to `sin(ref[])`, JET will report `NoMethodError`
julia&gt; f(ref) = isa(ref[], Number) ? sin(ref[]) : nothing;

# we can make it type-stable if we extract `ref[]` into a local variable `x`
julia&gt; g(ref) = (x = ref[]; isa(x, Number) ? sin(x) : nothing);

julia&gt; @testset &quot;check errors&quot; begin
           ref = Ref{Union{Nothing,Int}}(0)
           @test_call f(ref)             # fail
           @test_call g(ref)             # fail
           @test_call broken=true f(ref) # annotated as broken, thus still &quot;pass&quot;
       end
check errors: JET-test failed at REPL[9]:3
  Expression: #= REPL[9]:3 =# JET.@test_call f(ref)
  ═════ 1 possible error found ═════
  ┌ @ REPL[7]:1 sin(ref[])
  │ no matching method found for `sin(::Nothing)` (1/2 union split): sin((ref::Base.RefValue{Union{Nothing, Int64}})[]::Union{Nothing, Int64})::Union{}
  └─────────────

Test Summary: | Pass  Fail  Broken  Total
check errors  |    1     1       1      3
ERROR: Some tests did not pass: 1 passed, 1 failed, 0 errored, 1 broken.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aviatesk/JET.jl/blob/51de5545fb6f2968cb57d5ec7d362531d257e424/src/JET.jl#L1345-L1420">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JET.test_call" href="#JET.test_call"><code>JET.test_call</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">test_call(f, [types]; broken::Bool = false, skip::Bool = false, jetconfigs...)
test_call(tt::Type{&lt;:Tuple}; broken::Bool = false, skip::Bool = false, jetconfigs...)</code></pre><p>Runs <a href="#JET.report_call"><code>report_call(f, types; jetconfigs...</code></a> and tests that the generic function call <code>f(args...)</code> is free from problems that <code>report_call</code> can detect. Except that it takes a type signature rather than a call expression, this function works in the same way as <a href="#JET.@test_call"><code>@test_call</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aviatesk/JET.jl/blob/51de5545fb6f2968cb57d5ec7d362531d257e424/src/JET.jl#L1490-L1498">source</a></section></article><h3 id="jetanalysis-toplevel-entry"><a class="docs-heading-anchor" href="#jetanalysis-toplevel-entry">Top-level Entry Points</a><a id="jetanalysis-toplevel-entry-1"></a><a class="docs-heading-anchor-permalink" href="#jetanalysis-toplevel-entry" title="Permalink"></a></h3><p>JET can also analyze your &quot;top-level&quot; program: it can just take your Julia script or package and will report possible errors.</p><p>Note that JET will analyze your top-level program &quot;half-statically&quot;: JET will selectively interpret and load &quot;definitions&quot; (like a function or struct definition) and try to simulate Julia&#39;s top-level code execution process. While it tries to avoid executing any other parts of code like function calls and analyzes them based on abstract interpretation instead (and this is a part where JET statically analyzes your code). If you&#39;re interested in how JET selects &quot;top-level definitions&quot;, please see <a href="../internals/#JET.virtual_process"><code>JET.virtual_process</code></a>.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>Because JET will interpret &quot;definitions&quot; in your code, that part of top-level analysis certainly <em>runs</em> your code. So we should note that JET can cause some side effects from your code; for example, JET will try to expand all the macros used in your code, and so the side effects involved with macro expansions will also happen in JET&#39;s analysis process.</p></div></div><article class="docstring"><header><a class="docstring-binding" id="JET.report_file" href="#JET.report_file"><code>JET.report_file</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">report_file(filename::AbstractString;
            jetconfigs...) -&gt; JETToplevelResult</code></pre><p>Analyzes <code>filename</code> and returns <a href="../internals/#JET.JETToplevelResult"><code>JETToplevelResult</code></a>.</p><p>This function will look for <code>.JET.toml</code> configuration file in the directory of <code>filename</code>, and search <em>up</em> the file tree until any <code>.JET.toml</code> is (or isn&#39;t) found. When found, the configurations specified in the file will be applied. See <a href="../config/#config-file">JET&#39;s configuration file</a> for more details.</p><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>When you want to analyze your package, but any file actually using it isn&#39;t available, the <code>analyze_from_definitions</code> option can be useful (see <a href="../config/#JET.ToplevelConfig"><code>ToplevelConfig</code></a>&#39;s <code>analyze_from_definitions</code> option). <br/>For example, JET can analyze JET itself like below:</p><pre><code class="language-julia-repl hljs"># from the root directory of JET.jl
julia&gt; report_file(&quot;src/JET.jl&quot;;
                   analyze_from_definitions = true)</code></pre><p>See also: <a href="#JET.report_package"><code>report_package</code></a></p></div></div><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>This function will enable the <code>toplevel_logger</code> configuration by default with the default logging level. You can still explicitly specify and configure it:</p><pre><code class="language-julia hljs">report_file(args...;
            toplevel_logger = nothing, # suppress toplevel logger
            jetconfigs...) # other configurations</code></pre><p>See <a href="../config/#toplevel-config">JET&#39;s top-level analysis configurations</a> for more details.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aviatesk/JET.jl/blob/51de5545fb6f2968cb57d5ec7d362531d257e424/src/JET.jl#L831-L863">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JET.report_and_watch_file" href="#JET.report_and_watch_file"><code>JET.report_and_watch_file</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">report_and_watch_file(filename::AbstractString;
                      jetconfigs...)</code></pre><p>Watches <code>filename</code> and keeps re-triggering analysis with <a href="#JET.report_file"><code>report_file</code></a> on code update. JET will try to analyze all the <code>include</code>d files reachable from <code>filename</code>, and it will re-trigger analysis if there is code update detected in any of the <code>include</code>d files.</p><p>This function internally uses <a href="https://timholy.github.io/Revise.jl/stable/">Revise.jl</a> to track code updates. Revise also offers possibilities to track changes in files that are not directly analyzed by JET, or even changes in <code>Base</code> files. See <a href="../config/#watch-config">watch configurations</a> for more details.</p><p>See also: <a href="#JET.report_file"><code>report_file</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aviatesk/JET.jl/blob/51de5545fb6f2968cb57d5ec7d362531d257e424/src/JET.jl#L1108-L1122">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JET.report_package" href="#JET.report_package"><code>JET.report_package</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">report_package(package::Union{AbstractString,Module};
               jetconfigs...) -&gt; JETToplevelResult</code></pre><p>Analyzes <code>package</code> in the same way as <a href="#JET.report_file"><code>report_file</code></a> with the special default configurations, which are especially tuned for package analysis (see below for details). <code>package</code> can be either a <code>Module</code> or a <code>String</code>. In the latter case it must be the name of a package in your current environment.</p><p>This function configures analysis with the following configurations:</p><ul><li><code>analyze_from_definitions = true</code>: allows JET to enter analysis without top-level call sites; this is useful for package analysis since a package itself usually has only definitions but not usages (i.e. call sites)</li><li><code>concretization_patterns = [:(x_)]</code>: concretizes every top-level code in a given <code>package</code>; concretizations are generally preferred for successful analysis as far as they&#39;re cheap, and a package definition doesn&#39;t contain heavy computations in general cases</li></ul><p>See <a href="../config/#JET.ToplevelConfig"><code>ToplevelConfig</code></a> for more details.</p><hr/><pre><code class="nohighlight hljs">report_package([io::IO = stdout];
               jetconfigs...) -&gt; res::ReportResult</code></pre><p>Like above but analyzes the package of the current project.</p><p>See also: <a href="#JET.report_file"><code>report_file</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aviatesk/JET.jl/blob/51de5545fb6f2968cb57d5ec7d362531d257e424/src/JET.jl#L990-L1016">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JET.report_text" href="#JET.report_text"><code>JET.report_text</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">report_text(text::AbstractString,
            filename::AbstractString = &quot;top-level&quot;;
            jetconfigs...) -&gt; JETToplevelResult</code></pre><p>Analyzes <code>text</code> and returns <a href="../internals/#JET.JETToplevelResult"><code>JETToplevelResult</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aviatesk/JET.jl/blob/51de5545fb6f2968cb57d5ec7d362531d257e424/src/JET.jl#L1047-L1053">source</a></section></article><h2 id="jetanalysis-config"><a class="docs-heading-anchor" href="#jetanalysis-config">Configurations</a><a id="jetanalysis-config-1"></a><a class="docs-heading-anchor-permalink" href="#jetanalysis-config" title="Permalink"></a></h2><p>In addition to <a href="../config/#JET-configurations">general configurations</a>, the error analysis can take the following specific configurations:</p><article class="docstring"><header><a class="docstring-binding" id="JET.JETAnalyzer" href="#JET.JETAnalyzer"><code>JET.JETAnalyzer</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Every <a href="#jetanalysis-entry">entry point of error analysis</a> can accept any of <a href="../config/#JET-configurations">general JET configurations</a> as well as the following additional configurations that are specific to the error analysis.</p><hr/><ul><li><p><code>mode::Symbol = :basic</code>:<br/>Switches the error analysis pass. Each analysis pass reports errors according to their own &quot;error&quot; definition. JET by default offers the following modes:</p><ul><li><code>mode = :basic</code>: the default error analysis pass. This analysis pass is tuned to be useful for general Julia development by reporting common problems, but also note that it is not enough strict to guarantee that your program never throws runtime errors.<br/>See <a href="#JET.BasicPass"><code>BasicPass</code></a> for more details.</li><li><code>mode = :sound</code>: the sound error analysis pass. If this pass doesn&#39;t report any errors, then your program is assured to run without any runtime errors (unless JET&#39;s error definition is not accurate and/or there is an implementation flaw).<br/>See <a href="#JET.SoundPass"><code>SoundPass</code></a> for more details.</li><li><code>mode = :typo</code>: a typo detection pass A simple analysis pass to detect &quot;typo&quot;s in your program. This analysis pass is essentially a subset of the default basic pass (<a href="#JET.BasicPass"><code>BasicPass</code></a>), and it only reports undefined global reference and undefined field access. This might be useful especially for a very complex code base, because even the basic pass tends to be too noisy (spammed with too many errors) for such a case.<br/>See <a href="#JET.TypoPass"><code>TypoPass</code></a> for more details.</li></ul><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>You can also set up your own analysis using JET&#39;s <a href="../generated-plugin-api/#AbstractAnalyzer-Framework"><code>AbstractAnalyzer</code>-Framework</a>.</p></div></div></li></ul><hr/></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aviatesk/JET.jl/blob/51de5545fb6f2968cb57d5ec7d362531d257e424/src/analyzers/jetanalyzer.jl#L1-L32">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JET.BasicPass" href="#JET.BasicPass"><code>JET.BasicPass</code></a> — <span class="docstring-category">Type</span></header><section><div><p>The basic (default) error analysis pass.</p><p>TODO: elaborate this documentation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aviatesk/JET.jl/blob/51de5545fb6f2968cb57d5ec7d362531d257e424/src/analyzers/jetanalyzer.jl#L125-L129">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JET.SoundPass" href="#JET.SoundPass"><code>JET.SoundPass</code></a> — <span class="docstring-category">Type</span></header><section><div><p>The sound error analysis pass.</p><p>TODO: elaborate this documentation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aviatesk/JET.jl/blob/51de5545fb6f2968cb57d5ec7d362531d257e424/src/analyzers/jetanalyzer.jl#L151-L155">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JET.TypoPass" href="#JET.TypoPass"><code>JET.TypoPass</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A typo detection pass.</p><p>TODO: elaborate this documentation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aviatesk/JET.jl/blob/51de5545fb6f2968cb57d5ec7d362531d257e424/src/analyzers/jetanalyzer.jl#L161-L165">source</a></section></article><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-1"><a class="tag is-link" href="#citeref-1">1</a>We used <code>target_modules</code> just for the sake of demonstration. To make it more   idiomatic, we should initialize <code>a</code> as typed vector <code>a = Int[]</code>, and then we won&#39;t   get any problem from <code>sum(a)</code> even without the <code>target_modules</code> configuration.</li><li class="footnote" id="footnote-2"><a class="tag is-link" href="#citeref-2">2</a>JET offers the framework to define your own abstract interpretation-based analysis.   See <a href="../generated-plugin-api/#AbstractAnalyzer-Framework"><code>AbstractAnalyzer</code>-Framework</a> if interested.</li><li class="footnote" id="footnote-3"><a class="tag is-link" href="#citeref-3">3</a>For immutable structs, the Julia compiler can figure out type constraints imposed on   aliased field loads if you&#39;re using Julia version higher than <code>v&quot;1.10.0-DEV.25&quot;</code>.</li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../tutorial/">« Tutorial</a><a class="docs-footer-nextpage" href="../optanalysis/">Optimization Analysis »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.23 on <span class="colophon-date" title="Wednesday 18 January 2023 09:16">Wednesday 18 January 2023</span>. Using Julia version 1.10.0-DEV.387.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
